# Infrastructure Manager Configuration for Secure API Gateway Architecture
# This configuration deploys a production-ready API gateway using Cloud Endpoints,
# Cloud Armor, and Cloud Load Balancing with comprehensive security policies.

apiVersion: v1
kind: InfrastructureManager
metadata:
  name: secure-api-gateway
  description: "Secure API Gateway with Cloud Endpoints, Cloud Armor, and Load Balancing"

# Input variables for customization
variables:
  project_id:
    type: string
    description: "Google Cloud Project ID"
    required: true
  
  region:
    type: string
    description: "Primary region for resources"
    default: "us-central1"
    
  zone:
    type: string
    description: "Primary zone for compute resources"
    default: "us-central1-a"
    
  api_name:
    type: string
    description: "Name for the API service"
    default: "secure-api"
    
  environment:
    type: string
    description: "Environment name (dev, staging, prod)"
    default: "dev"
    
  rate_limit_threshold:
    type: integer
    description: "Rate limit threshold (requests per minute)"
    default: 100
    
  ban_duration_seconds:
    type: integer
    description: "Ban duration in seconds for rate limit violations"
    default: 300

# Resource definitions
resources:
  # Enable required APIs
  - name: enable-compute-api
    type: gcp-types/serviceusage-v1:services
    properties:
      name: projects/$(ref.project_id.value)/services/compute.googleapis.com
      
  - name: enable-endpoints-api
    type: gcp-types/serviceusage-v1:services
    properties:
      name: projects/$(ref.project_id.value)/services/servicemanagement.googleapis.com
      
  - name: enable-service-control-api
    type: gcp-types/serviceusage-v1:services
    properties:
      name: projects/$(ref.project_id.value)/services/servicecontrol.googleapis.com

  # Backend service VM instance with startup script
  - name: backend-service-instance
    type: compute.v1.instance
    properties:
      zone: $(ref.zone.value)
      machineType: zones/$(ref.zone.value)/machineTypes/e2-medium
      networkInterfaces:
        - network: global/networks/default
          accessConfigs:
            - name: external-nat
              type: ONE_TO_ONE_NAT
      disks:
        - boot: true
          autoDelete: true
          initializeParams:
            sourceImage: projects/debian-cloud/global/images/family/debian-11
            diskSizeGb: 20
            diskType: zones/$(ref.zone.value)/diskTypes/pd-standard
      tags:
        items:
          - backend-service
          - http-server
      metadata:
        items:
          - key: startup-script
            value: |
              #!/bin/bash
              # Install Python and Flask for demo API
              apt-get update
              apt-get install -y python3 python3-pip
              pip3 install flask
              
              # Create demo API server
              cat > /opt/api-server.py << 'EOF'
              from flask import Flask, jsonify, request
              import datetime
              import os
              
              app = Flask(__name__)
              
              @app.route("/health", methods=["GET"])
              def health():
                  return jsonify({
                      "status": "healthy", 
                      "timestamp": datetime.datetime.now().isoformat(),
                      "instance": os.environ.get("HOSTNAME", "unknown")
                  })
              
              @app.route("/api/v1/users", methods=["GET"])
              def get_users():
                  return jsonify({
                      "users": [
                          {"id": 1, "name": "Alice", "role": "admin"},
                          {"id": 2, "name": "Bob", "role": "user"},
                          {"id": 3, "name": "Carol", "role": "viewer"}
                      ],
                      "total": 3
                  })
              
              @app.route("/api/v1/data", methods=["POST"])
              def create_data():
                  data = request.get_json()
                  if not data:
                      return jsonify({"error": "No data provided"}), 400
                  return jsonify({
                      "message": "Data received successfully",
                      "data": data,
                      "id": "data-12345",
                      "timestamp": datetime.datetime.now().isoformat()
                  })
              
              @app.route("/api/v1/status", methods=["GET"])
              def api_status():
                  return jsonify({
                      "api_version": "1.0.0",
                      "status": "operational",
                      "endpoints": ["/health", "/api/v1/users", "/api/v1/data", "/api/v1/status"]
                  })
              
              if __name__ == "__main__":
                  app.run(host="0.0.0.0", port=8080, debug=False)
              EOF
              
              # Start the API server as a service
              cat > /etc/systemd/system/api-server.service << 'EOF'
              [Unit]
              Description=Demo API Server
              After=network.target
              
              [Service]
              Type=simple
              User=root
              WorkingDirectory=/opt
              ExecStart=/usr/bin/python3 /opt/api-server.py
              Restart=always
              RestartSec=3
              
              [Install]
              WantedBy=multi-user.target
              EOF
              
              # Enable and start the service
              systemctl daemon-reload
              systemctl enable api-server
              systemctl start api-server
              
              # Create log rotation
              cat > /etc/logrotate.d/api-server << 'EOF'
              /var/log/api-server.log {
                  daily
                  rotate 7
                  compress
                  delaycompress
                  missingok
                  notifempty
                  create 644 root root
              }
              EOF
    dependsOn:
      - enable-compute-api

  # Create OpenAPI specification as a configmap-like resource
  - name: openapi-specification
    type: gcp-types/storage-v1:buckets
    properties:
      name: $(ref.project_id.value)-api-specs-$(ref.environment.value)
      location: $(ref.region.value)
      storageClass: STANDARD
      versioning:
        enabled: true

  # Cloud Armor security policy with comprehensive rules
  - name: api-security-policy
    type: compute.v1.securityPolicy
    properties:
      name: api-security-policy-$(ref.environment.value)
      description: "Comprehensive security policy for API gateway with rate limiting and threat protection"
      type: CLOUD_ARMOR
      # Default rule - allow all traffic that doesn't match other rules
      rules:
        # Rate limiting rule - 100 requests per minute per IP
        - priority: 1000
          match:
            versionedExpr: SRC_IPS_V1
            config:
              srcIpRanges:
                - "*"
          action: rate_based_ban
          rateLimitOptions:
            conformAction: allow
            exceedAction: deny_429
            enforceOnKey: IP
            banDurationSec: $(ref.ban_duration_seconds.value)
            rateLimitThreshold:
              count: $(ref.rate_limit_threshold.value)
              intervalSec: 60
          description: "Rate limiting: 100 requests per minute per IP"
          
        # XSS protection rule
        - priority: 2000
          match:
            expr:
              expression: "evaluatePreconfiguredExpr('xss-canary')"
          action: deny_403
          description: "Block XSS attacks"
          
        # SQL injection protection rule
        - priority: 3000
          match:
            expr:
              expression: "evaluatePreconfiguredExpr('sqli-canary')"
          action: deny_403
          description: "Block SQL injection attacks"
          
        # Protocol attack protection
        - priority: 4000
          match:
            expr:
              expression: "evaluatePreconfiguredExpr('protocolattack-canary')"
          action: deny_403
          description: "Block protocol attacks"
          
        # Session fixation protection
        - priority: 5000
          match:
            expr:
              expression: "evaluatePreconfiguredExpr('sessionfixation-canary')"
          action: deny_403
          description: "Block session fixation attacks"
          
        # Geographic restriction example (customize as needed)
        - priority: 6000
          match:
            expr:
              expression: "origin.region_code == 'CN' || origin.region_code == 'KP'"
          action: deny_403
          description: "Block traffic from specific regions"
          
        # Block common bot patterns
        - priority: 7000
          match:
            expr:
              expression: "has(request.headers['user-agent']) && request.headers['user-agent'].matches('(?i).*(bot|crawler|spider|scraper).*')"
          action: deny_403
          description: "Block common bot patterns"
          
        # Default allow rule
        - priority: 2147483647
          match:
            versionedExpr: SRC_IPS_V1
            config:
              srcIpRanges:
                - "*"
          action: allow
          description: "Default allow rule"
    dependsOn:
      - enable-compute-api

  # ESP (Endpoints Service Proxy) instance
  - name: esp-proxy-instance
    type: compute.v1.instance
    properties:
      zone: $(ref.zone.value)
      machineType: zones/$(ref.zone.value)/machineTypes/e2-medium
      networkInterfaces:
        - network: global/networks/default
          accessConfigs:
            - name: external-nat
              type: ONE_TO_ONE_NAT
      disks:
        - boot: true
          autoDelete: true
          initializeParams:
            sourceImage: projects/cos-cloud/global/images/family/cos-stable
            diskSizeGb: 20
            diskType: zones/$(ref.zone.value)/diskTypes/pd-standard
      tags:
        items:
          - esp-proxy
          - http-server
          - https-server
      metadata:
        items:
          - key: gce-container-declaration
            value: |
              spec:
                containers:
                  - name: esp-proxy
                    image: gcr.io/endpoints-release/endpoints-runtime:2
                    env:
                      - name: ESPv2_ARGS
                        value: "--service=$(ref.api_name.value).endpoints.$(ref.project_id.value).cloud.goog --rollout_strategy=managed --backend=http://$(ref.backend-service-instance.networkInterfaces[0].networkIP):8080 --cors_preset=basic --log_level=info"
                    ports:
                      - containerPort: 8080
                        hostPort: 8080
                        protocol: TCP
                    resources:
                      requests:
                        memory: "512Mi"
                        cpu: "250m"
                      limits:
                        memory: "1Gi"
                        cpu: "500m"
                restartPolicy: Always
          - key: google-logging-enabled
            value: "true"
          - key: google-monitoring-enabled
            value: "true"
      serviceAccounts:
        - email: default
          scopes:
            - https://www.googleapis.com/auth/cloud-platform
            - https://www.googleapis.com/auth/service.management.readonly
            - https://www.googleapis.com/auth/servicecontrol
    dependsOn:
      - backend-service-instance
      - enable-endpoints-api

  # Firewall rule for ESP proxy
  - name: esp-proxy-firewall-rule
    type: compute.v1.firewall
    properties:
      name: allow-esp-proxy-$(ref.environment.value)
      network: global/networks/default
      allowed:
        - IPProtocol: tcp
          ports:
            - "8080"
            - "80"
            - "443"
      sourceRanges:
        - "0.0.0.0/0"
      targetTags:
        - esp-proxy
      description: "Allow HTTP/HTTPS traffic to ESP proxy instances"
    dependsOn:
      - enable-compute-api

  # Firewall rule for backend service
  - name: backend-service-firewall-rule
    type: compute.v1.firewall
    properties:
      name: allow-backend-service-$(ref.environment.value)
      network: global/networks/default
      allowed:
        - IPProtocol: tcp
          ports:
            - "8080"
      sourceTags:
        - esp-proxy
      targetTags:
        - backend-service
      description: "Allow traffic from ESP proxy to backend services"
    dependsOn:
      - enable-compute-api

  # Instance group for ESP proxy instances
  - name: esp-proxy-instance-group
    type: compute.v1.instanceGroup
    properties:
      zone: $(ref.zone.value)
      name: esp-proxy-group-$(ref.environment.value)
      description: "Instance group for ESP proxy instances"
      network: global/networks/default
    dependsOn:
      - esp-proxy-instance

  # Add ESP proxy instance to the instance group
  - name: add-esp-instance-to-group
    type: compute.v1.instanceGroup
    properties:
      zone: $(ref.zone.value)
      name: esp-proxy-group-$(ref.environment.value)
      instances:
        - zones/$(ref.zone.value)/instances/$(ref.esp-proxy-instance.name)
    dependsOn:
      - esp-proxy-instance-group

  # Health check for ESP proxy
  - name: esp-health-check
    type: compute.v1.httpHealthCheck
    properties:
      name: esp-health-check-$(ref.environment.value)
      description: "Health check for ESP proxy instances"
      port: 8080
      requestPath: "/health"
      checkIntervalSec: 30
      timeoutSec: 10
      healthyThreshold: 2
      unhealthyThreshold: 3
    dependsOn:
      - enable-compute-api

  # Backend service with Cloud Armor integration
  - name: esp-backend-service
    type: compute.v1.backendService
    properties:
      name: esp-backend-service-$(ref.environment.value)
      description: "Backend service for ESP proxy with Cloud Armor protection"
      protocol: HTTP
      portName: http
      timeoutSec: 30
      connectionDraining:
        drainingTimeoutSec: 60
      healthChecks:
        - $(ref.esp-health-check.selfLink)
      backends:
        - group: $(ref.esp-proxy-instance-group.selfLink)
          balancingMode: UTILIZATION
          maxUtilization: 0.8
          capacityScaler: 1.0
      securityPolicy: $(ref.api-security-policy.selfLink)
      loadBalancingScheme: EXTERNAL
      sessionAffinity: NONE
      compressionMode: AUTOMATIC
    dependsOn:
      - api-security-policy
      - esp-health-check
      - add-esp-instance-to-group

  # URL map for routing
  - name: esp-url-map
    type: compute.v1.urlMap
    properties:
      name: esp-url-map-$(ref.environment.value)
      description: "URL map for API gateway routing"
      defaultService: $(ref.esp-backend-service.selfLink)
      hostRules:
        - hosts:
            - "*"
          pathMatcher: api-matcher
      pathMatchers:
        - name: api-matcher
          defaultService: $(ref.esp-backend-service.selfLink)
          pathRules:
            - paths:
                - "/health"
                - "/api/*"
              service: $(ref.esp-backend-service.selfLink)
    dependsOn:
      - esp-backend-service

  # Static IP address for the load balancer
  - name: esp-gateway-ip
    type: compute.v1.globalAddress
    properties:
      name: esp-gateway-ip-$(ref.environment.value)
      description: "Static IP address for API gateway"
      ipVersion: IPV4
      addressType: EXTERNAL
    dependsOn:
      - enable-compute-api

  # HTTP target proxy
  - name: esp-http-proxy
    type: compute.v1.targetHttpProxy
    properties:
      name: esp-http-proxy-$(ref.environment.value)
      description: "HTTP target proxy for API gateway"
      urlMap: $(ref.esp-url-map.selfLink)
    dependsOn:
      - esp-url-map

  # HTTPS target proxy (for production SSL termination)
  - name: esp-https-proxy
    type: compute.v1.targetHttpsProxy
    properties:
      name: esp-https-proxy-$(ref.environment.value)
      description: "HTTPS target proxy for API gateway (SSL termination)"
      urlMap: $(ref.esp-url-map.selfLink)
      # Note: SSL certificate would be added here for production use
      # sslCertificates:
      #   - projects/$(ref.project_id.value)/global/sslCertificates/api-gateway-cert
    dependsOn:
      - esp-url-map

  # Global forwarding rule for HTTP traffic
  - name: esp-http-forwarding-rule
    type: compute.v1.globalForwardingRule
    properties:
      name: esp-http-forwarding-rule-$(ref.environment.value)
      description: "HTTP forwarding rule for API gateway"
      IPAddress: $(ref.esp-gateway-ip.address)
      IPProtocol: TCP
      portRange: "80"
      target: $(ref.esp-http-proxy.selfLink)
      loadBalancingScheme: EXTERNAL
    dependsOn:
      - esp-gateway-ip
      - esp-http-proxy

  # Global forwarding rule for HTTPS traffic
  - name: esp-https-forwarding-rule
    type: compute.v1.globalForwardingRule
    properties:
      name: esp-https-forwarding-rule-$(ref.environment.value)
      description: "HTTPS forwarding rule for API gateway"
      IPAddress: $(ref.esp-gateway-ip.address)
      IPProtocol: TCP
      portRange: "443"
      target: $(ref.esp-https-proxy.selfLink)
      loadBalancingScheme: EXTERNAL
    dependsOn:
      - esp-gateway-ip
      - esp-https-proxy

# Outputs for verification and integration
outputs:
  gateway_ip_address:
    description: "Static IP address of the API gateway"
    value: $(ref.esp-gateway-ip.address)
    
  api_endpoint_url:
    description: "HTTP endpoint URL for the API gateway"
    value: "http://$(ref.esp-gateway-ip.address)"
    
  api_https_endpoint_url:
    description: "HTTPS endpoint URL for the API gateway (requires SSL certificate)"
    value: "https://$(ref.esp-gateway-ip.address)"
    
  backend_instance_name:
    description: "Name of the backend service instance"
    value: $(ref.backend-service-instance.name)
    
  esp_proxy_instance_name:
    description: "Name of the ESP proxy instance"
    value: $(ref.esp-proxy-instance.name)
    
  security_policy_name:
    description: "Name of the Cloud Armor security policy"
    value: $(ref.api-security-policy.name)
    
  backend_service_name:
    description: "Name of the load balancer backend service"
    value: $(ref.esp-backend-service.name)
    
  project_id:
    description: "Google Cloud Project ID used for deployment"
    value: $(ref.project_id.value)
    
  region:
    description: "Primary region for the deployment"
    value: $(ref.region.value)
    
  environment:
    description: "Environment name for the deployment"
    value: $(ref.environment.value)

# Metadata for the deployment
metadata:
  version: "1.0.0"
  created_by: "Infrastructure Manager"
  description: "Secure API Gateway Architecture with Cloud Endpoints and Cloud Armor"
  documentation: "https://cloud.google.com/endpoints/docs"
  support_level: "production-ready"
  cost_estimate: "$50-100/month for production workloads"
  security_features:
    - "DDoS protection via Cloud Armor"
    - "Web Application Firewall (WAF)"
    - "Rate limiting per IP address"
    - "OWASP Top 10 protection"
    - "Geographic traffic filtering"
    - "Bot protection"
  performance_features:
    - "Global load balancing"
    - "Health checks and failover"
    - "Connection draining"
    - "Automatic compression"
    - "Session affinity options"