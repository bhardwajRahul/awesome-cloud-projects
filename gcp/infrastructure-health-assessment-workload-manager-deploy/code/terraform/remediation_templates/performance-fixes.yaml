# Performance Optimization Template for Infrastructure Health Assessment
# This template applies performance best practices and optimizations identified
# during infrastructure health assessments to improve workload efficiency.

apiVersion: v1
kind: ConfigMap
metadata:
  name: performance-tuning-config
  labels:
    app: performance-optimizer
    component: configuration
    optimization-type: performance
data:
  performance-settings.yaml: |
    optimization:
      cpu_limits_enabled: true
      memory_limits_enabled: true
      auto_scaling_enabled: true
      resource_quotas_enabled: true
      monitoring_enabled: true
    
    thresholds:
      cpu_utilization_target: 70
      memory_utilization_target: 80
      response_time_threshold_ms: 500
      error_rate_threshold_percent: 1
    
    scaling:
      min_replicas: 2
      max_replicas: 10
      scale_up_threshold: 70
      scale_down_threshold: 30
      scale_up_period_seconds: 60
      scale_down_period_seconds: 300

---
# Horizontal Pod Autoscaler for dynamic scaling
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: workload-performance-hpa
  labels:
    app: performance-optimizer
    component: autoscaler
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: target-workload
  minReplicas: 2
  maxReplicas: 10
  
  metrics:
  # CPU utilization metrics
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  
  # Memory utilization metrics
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  
  # Custom metrics for application performance
  - type: Pods
    pods:
      metric:
        name: requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  
  # Scaling behavior configuration
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max
    
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
      - type: Pods
        value: 1
        periodSeconds: 60
      selectPolicy: Min

---
# Vertical Pod Autoscaler for right-sizing resources
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: workload-performance-vpa
  labels:
    app: performance-optimizer
    component: vertical-autoscaler
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: target-workload
  
  updatePolicy:
    updateMode: "Auto"
    minReplicas: 2
  
  resourcePolicy:
    containerPolicies:
    - containerName: "*"
      minAllowed:
        cpu: "50m"
        memory: "64Mi"
      maxAllowed:
        cpu: "2"
        memory: "4Gi"
      controlledResources: ["cpu", "memory"]
      controlledValues: RequestsAndLimits

---
# Performance-optimized Deployment template
apiVersion: apps/v1
kind: Deployment
metadata:
  name: performance-optimized-workload
  labels:
    app: performance-workload
    component: optimized-deployment
    performance-tier: high
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  
  selector:
    matchLabels:
      app: performance-workload
  
  template:
    metadata:
      labels:
        app: performance-workload
        performance-tier: high
      annotations:
        # Performance tuning annotations
        performance.optimization/cpu-policy: "performance"
        performance.optimization/memory-policy: "optimized"
        cluster-autoscaler.kubernetes.io/safe-to-evict: "true"
    
    spec:
      # Performance-optimized scheduling
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values: ["performance-workload"]
              topologyKey: kubernetes.io/hostname
        
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            preference:
              matchExpressions:
              - key: node.kubernetes.io/instance-type
                operator: In
                values: ["c2-standard-4", "c2-standard-8", "n2-highcpu-4"]
      
      # Resource optimization
      nodeSelector:
        performance-tier: "high"
      
      tolerations:
      - key: "performance-dedicated"
        operator: "Equal"
        value: "true"
        effect: "NoSchedule"
      
      # Performance-optimized containers
      containers:
      - name: optimized-container
        image: gcr.io/project/optimized-app:latest
        imagePullPolicy: IfNotPresent
        
        # Optimized resource allocation
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
            ephemeral-storage: "1Gi"
          limits:
            memory: "512Mi"
            cpu: "500m"
            ephemeral-storage: "2Gi"
        
        # Performance-tuned environment variables
        env:
        - name: GOMAXPROCS
          valueFrom:
            resourceFieldRef:
              resource: limits.cpu
        - name: JAVA_OPTS
          value: "-XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseStringDeduplication"
        - name: NODE_OPTIONS
          value: "--max-old-space-size=400"
        - name: PYTHONUNBUFFERED
          value: "1"
        
        # Health checks optimized for performance
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 2
          failureThreshold: 3
          successThreshold: 1
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 2
          failureThreshold: 2
          successThreshold: 1
        
        # Startup probe for slow-starting applications
        startupProbe:
          httpGet:
            path: /startup
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 2
          failureThreshold: 30
          successThreshold: 1
        
        # Performance-optimized volume mounts
        volumeMounts:
        - name: cache-volume
          mountPath: /cache
        - name: tmp-volume
          mountPath: /tmp
      
      # Performance-optimized volumes
      volumes:
      - name: cache-volume
        emptyDir:
          medium: Memory
          sizeLimit: "128Mi"
      - name: tmp-volume
        emptyDir:
          sizeLimit: "256Mi"
      
      # DNS and networking optimizations
      dnsPolicy: ClusterFirst
      dnsConfig:
        options:
        - name: ndots
          value: "2"
        - name: edns0
      
      # Security context for performance
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      
      # Termination grace period optimization
      terminationGracePeriodSeconds: 30

---
# Resource Quota for performance optimization
apiVersion: v1
kind: ResourceQuota
metadata:
  name: performance-resource-quota
  labels:
    app: performance-optimizer
    component: resource-quota
spec:
  hard:
    requests.cpu: "10"
    requests.memory: "20Gi"
    limits.cpu: "20"
    limits.memory: "40Gi"
    requests.storage: "100Gi"
    persistentvolumeclaims: "10"
    pods: "50"
    services: "10"
    secrets: "10"
    configmaps: "10"

---
# LimitRange for consistent resource allocation
apiVersion: v1
kind: LimitRange
metadata:
  name: performance-limit-range
  labels:
    app: performance-optimizer
    component: limit-range
spec:
  limits:
  # Default limits for containers
  - default:
      cpu: "500m"
      memory: "512Mi"
      ephemeral-storage: "2Gi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
      ephemeral-storage: "1Gi"
    type: Container
  
  # Limits for persistent volume claims
  - max:
      storage: "50Gi"
    min:
      storage: "1Gi"
    type: PersistentVolumeClaim

---
# Service with performance optimizations
apiVersion: v1
kind: Service
metadata:
  name: performance-optimized-service
  labels:
    app: performance-workload
    component: service
  annotations:
    # Performance annotations
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    cloud.google.com/neg: '{"ingress": true}'
    cloud.google.com/backend-config: '{"default": "performance-backend-config"}'
spec:
  type: ClusterIP
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800
  
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP
  
  selector:
    app: performance-workload

---
# BackendConfig for GKE performance optimizations
apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: performance-backend-config
  labels:
    app: performance-optimizer
    component: backend-config
spec:
  # Connection draining timeout
  connectionDraining:
    drainingTimeoutSec: 60
  
  # Session affinity for performance
  sessionAffinity:
    affinityType: "CLIENT_IP"
    affinityCookieTtlSec: 3600
  
  # Health check optimizations
  healthCheck:
    checkIntervalSec: 10
    timeoutSec: 5
    healthyThreshold: 2
    unhealthyThreshold: 3
    type: HTTP
    requestPath: /health
    port: 8080
  
  # Load balancing optimization
  customRequestHeaders:
    headers:
    - "X-Performance-Optimized:true"

---
# PodDisruptionBudget for availability during scaling
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: performance-workload-pdb
  labels:
    app: performance-optimizer
    component: pod-disruption-budget
spec:
  minAvailable: 50%
  selector:
    matchLabels:
      app: performance-workload