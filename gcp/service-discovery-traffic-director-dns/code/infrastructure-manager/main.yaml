# Infrastructure Manager Configuration for Service Discovery with Traffic Director and Cloud DNS
# This configuration deploys an intelligent service discovery system using Google Cloud Traffic Director
# and Cloud DNS for advanced traffic management and load balancing across multiple zones

# Template metadata
metadata:
  name: service-discovery-traffic-director-dns
  description: "Intelligent service discovery system with Traffic Director and Cloud DNS"
  version: "1.0"

# Template imports for modular resource management
imports:
  - path: https://www.googleapis.com/compute/v1/projects/PROJECT_ID/global/instanceTemplates
    name: instance-template
  - path: https://www.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances
    name: compute-instance
  - path: https://www.googleapis.com/compute/v1/projects/PROJECT_ID/global/networks
    name: vpc-network
  - path: https://www.googleapis.com/compute/v1/projects/PROJECT_ID/regions/REGION/subnetworks
    name: subnet
  - path: https://www.googleapis.com/dns/v1/projects/PROJECT_ID/managedZones
    name: dns-zone

# Input parameters for customization
parameters:
  projectId:
    type: string
    description: "Google Cloud Project ID"
    pattern: "^[a-z][a-z0-9-]{4,28}[a-z0-9]$"
  
  region:
    type: string
    description: "Primary region for deployment"
    default: "us-central1"
    enum: ["us-central1", "us-east1", "us-west1", "europe-west1", "asia-east1"]
  
  serviceName:
    type: string
    description: "Name of the microservice"
    default: "microservice"
    pattern: "^[a-z][a-z0-9-]{2,20}[a-z0-9]$"
  
  domainName:
    type: string
    description: "Domain name for service discovery"
    default: "example.com"
    pattern: "^[a-z0-9.-]+$"
  
  instanceMachineType:
    type: string
    description: "Machine type for service instances"
    default: "e2-medium"
    enum: ["e2-micro", "e2-small", "e2-medium", "e2-standard-2", "e2-standard-4"]
  
  enablePublicDns:
    type: boolean
    description: "Enable public DNS zone for external access"
    default: false
  
  healthCheckPath:
    type: string
    description: "Health check endpoint path"
    default: "/health"
  
  serviceVip:
    type: string
    description: "Virtual IP address for the service"
    default: "10.0.1.100"
    pattern: "^10\\.0\\.[0-9]{1,3}\\.[0-9]{1,3}$"

# Resource definitions
resources:
  # VPC Network for service mesh
  service-mesh-vpc:
    type: compute.v1.network
    properties:
      name: "${serviceName}-vpc"
      description: "VPC network for service mesh infrastructure"
      autoCreateSubnetworks: false
      routingConfig:
        routingMode: "GLOBAL"
    metadata:
      dependsOn: []

  # Subnet for service instances
  service-mesh-subnet:
    type: compute.v1.subnetwork
    properties:
      name: "${serviceName}-subnet"
      description: "Subnet for service mesh instances"
      network: "$(ref.service-mesh-vpc.selfLink)"
      region: "${region}"
      ipCidrRange: "10.0.0.0/24"
      enableFlowLogs: true
      logConfig:
        enable: true
        flowSampling: 0.5
        aggregationInterval: "INTERVAL_10_SEC"
    metadata:
      dependsOn: ["service-mesh-vpc"]

  # Firewall rule for HTTP traffic
  allow-http-traffic:
    type: compute.v1.firewall
    properties:
      name: "${serviceName}-allow-http"
      description: "Allow HTTP traffic to service instances"
      network: "$(ref.service-mesh-vpc.selfLink)"
      direction: "INGRESS"
      priority: 1000
      sourceRanges: ["10.0.0.0/8"]
      targetTags: ["${serviceName}-instance"]
      allowed:
        - IPProtocol: "tcp"
          ports: ["80", "443"]
    metadata:
      dependsOn: ["service-mesh-vpc"]

  # Firewall rule for health check traffic
  allow-health-check:
    type: compute.v1.firewall
    properties:
      name: "${serviceName}-allow-health-check"
      description: "Allow Google Cloud health check traffic"
      network: "$(ref.service-mesh-vpc.selfLink)"
      direction: "INGRESS"
      priority: 1000
      sourceRanges: ["130.211.0.0/22", "35.191.0.0/16"]
      targetTags: ["${serviceName}-instance"]
      allowed:
        - IPProtocol: "tcp"
          ports: ["80"]
    metadata:
      dependsOn: ["service-mesh-vpc"]

  # Instance template for service deployment
  service-instance-template:
    type: compute.v1.instanceTemplate
    properties:
      name: "${serviceName}-template"
      description: "Instance template for microservice deployment"
      properties:
        machineType: "${instanceMachineType}"
        networkInterfaces:
          - network: "$(ref.service-mesh-vpc.selfLink)"
            subnetwork: "$(ref.service-mesh-subnet.selfLink)"
            accessConfigs: []  # No external IP for security
        serviceAccounts:
          - email: "default"
            scopes:
              - "https://www.googleapis.com/auth/cloud-platform"
        tags:
          items: ["${serviceName}-instance", "http-server"]
        disks:
          - boot: true
            autoDelete: true
            initializeParams:
              sourceImage: "projects/debian-cloud/global/images/family/debian-11"
              diskType: "pd-standard"
              diskSizeGb: 20
        metadata:
          items:
            - key: "startup-script"
              value: |
                #!/bin/bash
                # Update system packages
                apt-get update
                apt-get install -y nginx jq curl
                
                # Get instance metadata
                ZONE=$(curl -H "Metadata-Flavor: Google" \
                  http://metadata.google.internal/computeMetadata/v1/instance/zone | cut -d/ -f4)
                INSTANCE_NAME=$(hostname)
                
                # Configure nginx as a simple web service
                cat > /var/www/html/index.html << EOF
                {
                  "service": "${serviceName}",
                  "zone": "$ZONE",
                  "instance": "$INSTANCE_NAME",
                  "timestamp": "$(date -Iseconds)",
                  "health": "healthy",
                  "version": "1.0"
                }
                EOF
                
                # Configure health check endpoint
                cat > /var/www/html${healthCheckPath} << EOF
                {
                  "status": "healthy",
                  "timestamp": "$(date -Iseconds)",
                  "service": "${serviceName}",
                  "checks": {
                    "nginx": "$(systemctl is-active nginx)",
                    "disk_space": "$(df -h / | awk 'NR==2 {print $5}')"
                  }
                }
                EOF
                
                # Configure nginx for proper JSON response
                cat > /etc/nginx/sites-available/default << EOF
                server {
                    listen 80 default_server;
                    listen [::]:80 default_server;
                    
                    root /var/www/html;
                    index index.html;
                    
                    server_name _;
                    
                    location / {
                        add_header Content-Type application/json;
                        try_files \$uri \$uri/ =404;
                    }
                    
                    location ${healthCheckPath} {
                        add_header Content-Type application/json;
                        try_files \$uri =404;
                    }
                    
                    # Enable access logs for monitoring
                    access_log /var/log/nginx/access.log;
                    error_log /var/log/nginx/error.log;
                }
                EOF
                
                # Start and enable nginx
                systemctl enable nginx
                systemctl restart nginx
                
                # Log successful startup
                echo "Service ${serviceName} started successfully on $INSTANCE_NAME in $ZONE" | \
                  logger -t "startup-script"
    metadata:
      dependsOn: ["service-mesh-subnet"]

  # Service instances in Zone A
  service-instance-a1:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-a-1"
      zone: "${region}-a"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  service-instance-a2:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-a-2"
      zone: "${region}-a"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  # Service instances in Zone B
  service-instance-b1:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-b-1"
      zone: "${region}-b"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  service-instance-b2:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-b-2"
      zone: "${region}-b"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  # Service instances in Zone C
  service-instance-c1:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-c-1"
      zone: "${region}-c"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  service-instance-c2:
    type: compute.v1.instance
    properties:
      name: "${serviceName}-${region}-c-2"
      zone: "${region}-c"
      sourceInstanceTemplate: "$(ref.service-instance-template.selfLink)"
    metadata:
      dependsOn: ["service-instance-template"]

  # Network Endpoint Groups for Traffic Director
  neg-zone-a:
    type: compute.v1.networkEndpointGroup
    properties:
      name: "${serviceName}-neg-a"
      description: "Network Endpoint Group for zone A"
      zone: "${region}-a"
      networkEndpointType: "GCE_VM_IP_PORT"
      network: "$(ref.service-mesh-vpc.selfLink)"
      subnetwork: "$(ref.service-mesh-subnet.selfLink)"
      defaultPort: 80
    metadata:
      dependsOn: ["service-mesh-subnet"]

  neg-zone-b:
    type: compute.v1.networkEndpointGroup
    properties:
      name: "${serviceName}-neg-b"
      description: "Network Endpoint Group for zone B"
      zone: "${region}-b"
      networkEndpointType: "GCE_VM_IP_PORT"
      network: "$(ref.service-mesh-vpc.selfLink)"
      subnetwork: "$(ref.service-mesh-subnet.selfLink)"
      defaultPort: 80
    metadata:
      dependsOn: ["service-mesh-subnet"]

  neg-zone-c:
    type: compute.v1.networkEndpointGroup
    properties:
      name: "${serviceName}-neg-c"
      description: "Network Endpoint Group for zone C"
      zone: "${region}-c"
      networkEndpointType: "GCE_VM_IP_PORT"
      network: "$(ref.service-mesh-vpc.selfLink)"
      subnetwork: "$(ref.service-mesh-subnet.selfLink)"
      defaultPort: 80
    metadata:
      dependsOn: ["service-mesh-subnet"]

  # Health check for service monitoring
  service-health-check:
    type: compute.v1.healthCheck
    properties:
      name: "${serviceName}-health-check"
      description: "Health check for microservice instances"
      type: "HTTP"
      httpHealthCheck:
        port: 80
        requestPath: "${healthCheckPath}"
        proxyHeader: "NONE"
      checkIntervalSec: 10
      timeoutSec: 5
      healthyThreshold: 2
      unhealthyThreshold: 3
      logConfig:
        enable: true
    metadata:
      dependsOn: []

  # Backend service for Traffic Director
  service-backend:
    type: compute.v1.backendService
    properties:
      name: "${serviceName}-backend"
      description: "Backend service for intelligent traffic management"
      loadBalancingScheme: "INTERNAL_SELF_MANAGED"
      protocol: "HTTP"
      portName: "http"
      healthChecks:
        - "$(ref.service-health-check.selfLink)"
      connectionDraining:
        drainingTimeoutSec: 60
      backends:
        - group: "$(ref.neg-zone-a.selfLink)"
          balancingMode: "RATE"
          maxRatePerEndpoint: 100
          capacityScaler: 1.0
        - group: "$(ref.neg-zone-b.selfLink)"
          balancingMode: "RATE"
          maxRatePerEndpoint: 100
          capacityScaler: 1.0
        - group: "$(ref.neg-zone-c.selfLink)"
          balancingMode: "RATE"
          maxRatePerEndpoint: 100
          capacityScaler: 1.0
      localityLbPolicy: "ROUND_ROBIN"
      outlierDetection:
        consecutiveErrors: 3
        interval: 10
        baseEjectionTime: 30
        maxEjectionPercent: 50
    metadata:
      dependsOn: ["neg-zone-a", "neg-zone-b", "neg-zone-c", "service-health-check"]

  # URL map for traffic routing
  service-url-map:
    type: compute.v1.urlMap
    properties:
      name: "${serviceName}-url-map"
      description: "URL map for intelligent service discovery routing"
      defaultService: "$(ref.service-backend.selfLink)"
      pathMatchers:
        - name: "service-matcher"
          defaultService: "$(ref.service-backend.selfLink)"
          pathRules:
            - paths: ["/*"]
              service: "$(ref.service-backend.selfLink)"
            - paths: ["${healthCheckPath}"]
              service: "$(ref.service-backend.selfLink)"
      hostRules:
        - hosts: ["${serviceName}.${domainName}"]
          pathMatcher: "service-matcher"
    metadata:
      dependsOn: ["service-backend"]

  # Target HTTP proxy for Traffic Director
  service-http-proxy:
    type: compute.v1.targetHttpProxy
    properties:
      name: "${serviceName}-proxy"
      description: "HTTP proxy for Traffic Director service mesh"
      urlMap: "$(ref.service-url-map.selfLink)"
    metadata:
      dependsOn: ["service-url-map"]

  # Global forwarding rule for service access
  service-forwarding-rule:
    type: compute.v1.globalForwardingRule
    properties:
      name: "${serviceName}-forwarding-rule"
      description: "Global forwarding rule for intelligent service discovery"
      loadBalancingScheme: "INTERNAL_SELF_MANAGED"
      IPAddress: "${serviceVip}"
      ports: ["80"]
      target: "$(ref.service-http-proxy.selfLink)"
      network: "$(ref.service-mesh-vpc.selfLink)"
      subnetwork: "$(ref.service-mesh-subnet.selfLink)"
    metadata:
      dependsOn: ["service-http-proxy", "service-mesh-subnet"]

  # Private DNS zone for internal service discovery
  private-dns-zone:
    type: dns.v1.managedZone
    properties:
      name: "${serviceName}-private-zone"
      description: "Private DNS zone for internal service discovery"
      dnsName: "${serviceName}.${domainName}."
      visibility: "private"
      privateVisibilityConfig:
        networks:
          - networkUrl: "$(ref.service-mesh-vpc.selfLink)"
      dnssecConfig:
        state: "off"  # Disabled for internal zones
    metadata:
      dependsOn: ["service-mesh-vpc"]

  # Public DNS zone (conditional)
  public-dns-zone:
    type: dns.v1.managedZone
    properties:
      name: "${serviceName}-public-zone"
      description: "Public DNS zone for external service access"
      dnsName: "${serviceName}.${domainName}."
      visibility: "public"
      dnssecConfig:
        state: "on"
        defaultKeySpecs:
          - keyType: "keySigning"
            algorithm: "rsasha256"
            keyLength: 2048
          - keyType: "zoneSigning"
            algorithm: "rsasha256"
            keyLength: 1024
    metadata:
      dependsOn: []
      condition: "${enablePublicDns}"

  # DNS A record pointing to Traffic Director VIP
  service-dns-record:
    type: dns.v1.resourceRecordSet
    properties:
      name: "${serviceName}.${domainName}."
      type: "A"
      ttl: 300
      managedZone: "$(ref.private-dns-zone.name)"
      rrdatas:
        - "${serviceVip}"
    metadata:
      dependsOn: ["private-dns-zone", "service-forwarding-rule"]

  # SRV record for service discovery
  service-srv-record:
    type: dns.v1.resourceRecordSet
    properties:
      name: "_http._tcp.${serviceName}.${domainName}."
      type: "SRV"
      ttl: 300
      managedZone: "$(ref.private-dns-zone.name)"
      rrdatas:
        - "10 5 80 ${serviceName}.${domainName}."
    metadata:
      dependsOn: ["private-dns-zone", "service-dns-record"]

  # Health check DNS record for monitoring
  health-dns-record:
    type: dns.v1.resourceRecordSet
    properties:
      name: "health.${serviceName}.${domainName}."
      type: "A"
      ttl: 60
      managedZone: "$(ref.private-dns-zone.name)"
      rrdatas:
        - "${serviceVip}"
    metadata:
      dependsOn: ["private-dns-zone", "service-forwarding-rule"]

# Outputs for verification and integration
outputs:
  serviceVip:
    description: "Virtual IP address of the service"
    value: "${serviceVip}"
  
  serviceDnsName:
    description: "DNS name for service discovery"
    value: "${serviceName}.${domainName}"
  
  healthCheckUrl:
    description: "Health check endpoint URL"
    value: "http://${serviceName}.${domainName}${healthCheckPath}"
  
  privateDnsZone:
    description: "Private DNS zone name"
    value: "$(ref.private-dns-zone.name)"
  
  publicDnsZone:
    description: "Public DNS zone name (if enabled)"
    value: "$(ref.public-dns-zone.name)"
    condition: "${enablePublicDns}"
  
  vpcNetwork:
    description: "VPC network self-link"
    value: "$(ref.service-mesh-vpc.selfLink)"
  
  subnet:
    description: "Subnet self-link"
    value: "$(ref.service-mesh-subnet.selfLink)"
  
  backendService:
    description: "Backend service self-link"
    value: "$(ref.service-backend.selfLink)"
  
  forwardingRule:
    description: "Global forwarding rule self-link"
    value: "$(ref.service-forwarding-rule.selfLink)"
  
  instanceTemplate:
    description: "Instance template self-link"
    value: "$(ref.service-instance-template.selfLink)"
  
  deployedInstances:
    description: "List of deployed service instances"
    value:
      - "$(ref.service-instance-a1.name)"
      - "$(ref.service-instance-a2.name)"
      - "$(ref.service-instance-b1.name)"
      - "$(ref.service-instance-b2.name)"
      - "$(ref.service-instance-c1.name)"
      - "$(ref.service-instance-c2.name)"
  
  networkEndpointGroups:
    description: "Network Endpoint Groups for Traffic Director"
    value:
      - "$(ref.neg-zone-a.selfLink)"
      - "$(ref.neg-zone-b.selfLink)"
      - "$(ref.neg-zone-c.selfLink)"

# Configuration schema validation
schema:
  type: object
  properties:
    projectId:
      type: string
      minLength: 6
      maxLength: 30
    region:
      type: string
      enum: ["us-central1", "us-east1", "us-west1", "europe-west1", "asia-east1"]
    serviceName:
      type: string
      minLength: 3
      maxLength: 20
    domainName:
      type: string
      minLength: 4
      maxLength: 253
    instanceMachineType:
      type: string
      enum: ["e2-micro", "e2-small", "e2-medium", "e2-standard-2", "e2-standard-4"]
    enablePublicDns:
      type: boolean
    healthCheckPath:
      type: string
      pattern: "^/.*"
    serviceVip:
      type: string
      pattern: "^10\\.0\\.[0-9]{1,3}\\.[0-9]{1,3}$"
  required: ["projectId", "region", "serviceName", "domainName"]