# GraphQL Schema for Real-Time Chat Application
# This schema defines the complete data model for a real-time chat application
# with support for chat rooms, messages, reactions, user presence, and notifications

# Input types for creating and updating entities
input CreateChatRoomInput {
    name: String!
    description: String
    isPrivate: Boolean
}

input UpdateChatRoomInput {
    id: ID!
    name: String
    description: String
    isPrivate: Boolean
}

input CreateMessageInput {
    content: String!
    messageType: MessageType
    chatRoomId: ID!
    authorName: String!
    replyToId: ID
    attachments: [String]
}

input UpdateMessageInput {
    id: ID!
    content: String
    editedAt: AWSDateTime
    isEdited: Boolean
}

input CreateReactionInput {
    emoji: String!
    messageId: ID!
    authorName: String!
}

input CreateNotificationInput {
    type: NotificationType!
    title: String!
    message: String!
    userId: String!
    relatedId: String
    actionUrl: String
}

input UpdateUserPresenceInput {
    status: PresenceStatus!
    currentRoom: String
    deviceInfo: String
}

# Paginated response types
type ChatRoomConnection {
    items: [ChatRoom]!
    nextToken: String
}

type MessageConnection {
    items: [Message]!
    nextToken: String
}

type ReactionConnection {
    items: [Reaction]!
    nextToken: String
}

type NotificationConnection {
    items: [Notification]!
    nextToken: String
}

type UserPresenceConnection {
    items: [UserPresence]!
    nextToken: String
}

# Main entity types
type ChatRoom {
    id: ID!
    name: String!
    description: String
    isPrivate: Boolean!
    createdBy: String!
    members: [String]
    lastActivity: AWSDateTime
    messageCount: Int
    messages(limit: Int, nextToken: String, sortDirection: ModelSortDirection): MessageConnection
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type Message {
    id: ID!
    content: String!
    messageType: MessageType!
    author: String!
    authorName: String!
    chatRoomId: ID!
    chatRoom: ChatRoom
    replyToId: ID
    replyTo: Message
    replies(limit: Int, nextToken: String): MessageConnection
    reactions(limit: Int, nextToken: String): ReactionConnection
    attachments: [String]
    editedAt: AWSDateTime
    isEdited: Boolean
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type Reaction {
    id: ID!
    emoji: String!
    author: String!
    authorName: String!
    messageId: ID!
    message: Message
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type UserPresence {
    id: ID!
    userId: String!
    userName: String!
    status: PresenceStatus!
    lastSeen: AWSDateTime!
    currentRoom: String
    deviceInfo: String
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

type Notification {
    id: ID!
    type: NotificationType!
    title: String!
    message: String!
    userId: String!
    isRead: Boolean
    relatedId: String
    actionUrl: String
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
}

# Custom types for real-time operations
type TypingIndicator {
    userId: String!
    userName: String!
    chatRoomId: ID!
    timestamp: AWSDateTime!
}

# Enums
enum MessageType {
    TEXT
    IMAGE
    FILE
    SYSTEM
    TYPING
}

enum PresenceStatus {
    ONLINE
    AWAY
    BUSY
    OFFLINE
}

enum NotificationType {
    MESSAGE
    MENTION
    ROOM_INVITE
    SYSTEM
}

enum ModelSortDirection {
    ASC
    DESC
}

# Root Query type
type Query {
    # ChatRoom queries
    getChatRoom(id: ID!): ChatRoom
    listChatRooms(filter: TableFilterInput, limit: Int, nextToken: String): ChatRoomConnection
    
    # Message queries
    getMessage(id: ID!): Message
    listMessages(filter: TableFilterInput, limit: Int, nextToken: String): MessageConnection
    messagesByRoom(
        chatRoomId: ID!
        sortDirection: ModelSortDirection
        filter: TableFilterInput
        limit: Int
        nextToken: String
    ): MessageConnection
    
    # Reaction queries
    getReaction(id: ID!): Reaction
    listReactions(filter: TableFilterInput, limit: Int, nextToken: String): ReactionConnection
    reactionsByMessage(
        messageId: ID!
        sortDirection: ModelSortDirection
        filter: TableFilterInput
        limit: Int
        nextToken: String
    ): ReactionConnection
    
    # User presence queries
    getUserPresence(id: ID!): UserPresence
    listUserPresence(filter: TableFilterInput, limit: Int, nextToken: String): UserPresenceConnection
    
    # Notification queries
    getNotification(id: ID!): Notification
    listNotifications(filter: TableFilterInput, limit: Int, nextToken: String): NotificationConnection
}

# Root Mutation type
type Mutation {
    # ChatRoom mutations
    createChatRoom(input: CreateChatRoomInput!): ChatRoom
    updateChatRoom(input: UpdateChatRoomInput!): ChatRoom
    deleteChatRoom(input: DeleteChatRoomInput!): ChatRoom
    
    # Message mutations
    createMessage(input: CreateMessageInput!): Message
    updateMessage(input: UpdateMessageInput!): Message
    deleteMessage(input: DeleteMessageInput!): Message
    
    # Reaction mutations
    createReaction(input: CreateReactionInput!): Reaction
    deleteReaction(input: DeleteReactionInput!): Reaction
    
    # User presence mutations
    updateUserPresence(input: UpdateUserPresenceInput!): UserPresence
    
    # Notification mutations
    createNotification(input: CreateNotificationInput!): Notification
    markNotificationAsRead(id: ID!): Notification
    deleteNotification(input: DeleteNotificationInput!): Notification
    
    # Real-time operation mutations (handled by Lambda)
    startTyping(chatRoomId: ID!): TypingIndicator
    stopTyping(chatRoomId: ID!): TypingIndicator
    updatePresence(status: PresenceStatus!, currentRoom: String): UserPresence
    joinRoom(roomId: ID!): ChatRoom
    leaveRoom(roomId: ID!): ChatRoom
}

# Root Subscription type for real-time updates
type Subscription {
    # Message subscriptions
    onMessageCreated(chatRoomId: ID!): Message
        @aws_subscribe(mutations: ["createMessage"])
    
    onMessageUpdated(chatRoomId: ID!): Message
        @aws_subscribe(mutations: ["updateMessage"])
    
    onMessageDeleted(chatRoomId: ID!): Message
        @aws_subscribe(mutations: ["deleteMessage"])
    
    # Reaction subscriptions
    onReactionAdded(messageId: ID!): Reaction
        @aws_subscribe(mutations: ["createReaction"])
    
    onReactionRemoved(messageId: ID!): Reaction
        @aws_subscribe(mutations: ["deleteReaction"])
    
    # User presence subscriptions
    onUserPresenceChanged: UserPresence
        @aws_subscribe(mutations: ["updateUserPresence", "updatePresence"])
    
    # Notification subscriptions
    onNotificationReceived(userId: String!): Notification
        @aws_subscribe(mutations: ["createNotification"])
    
    # Real-time typing indicators
    onTypingStarted(chatRoomId: ID!): TypingIndicator
        @aws_subscribe(mutations: ["startTyping"])
    
    onTypingEnded(chatRoomId: ID!): TypingIndicator
        @aws_subscribe(mutations: ["stopTyping"])
    
    # Room membership subscriptions
    onRoomJoined(roomId: ID!): ChatRoom
        @aws_subscribe(mutations: ["joinRoom"])
    
    onRoomLeft(roomId: ID!): ChatRoom
        @aws_subscribe(mutations: ["leaveRoom"])
}

# Input types for delete operations
input DeleteChatRoomInput {
    id: ID!
}

input DeleteMessageInput {
    id: ID!
}

input DeleteReactionInput {
    id: ID!
}

input DeleteNotificationInput {
    id: ID!
}

# Table filter input for advanced querying
input TableFilterInput {
    and: [TableFilterInput]
    or: [TableFilterInput]
    not: TableFilterInput
    id: TableIDFilterInput
    createdAt: TableStringFilterInput
    updatedAt: TableStringFilterInput
}

input TableIDFilterInput {
    eq: ID
    ne: ID
    beginsWith: ID
    contains: ID
    notContains: ID
    between: [ID]
    gt: ID
    lt: ID
    gte: ID
    lte: ID
}

input TableStringFilterInput {
    eq: String
    ne: String
    beginsWith: String
    contains: String
    notContains: String
    between: [String]
    gt: String
    lt: String
    gte: String
    lte: String
}

input TableBooleanFilterInput {
    eq: Boolean
    ne: Boolean
}

input TableIntFilterInput {
    eq: Int
    ne: Int
    between: [Int]
    gt: Int
    lt: Int
    gte: Int
    lte: Int
}

input TableFloatFilterInput {
    eq: Float
    ne: Float
    between: [Float]
    gt: Float
    lt: Float
    gte: Float
    lte: Float
}

# Scalar types
scalar AWSDateTime
scalar AWSEmail
scalar AWSPhone
scalar AWSURL
scalar AWSIPAddress
scalar AWSTimestamp