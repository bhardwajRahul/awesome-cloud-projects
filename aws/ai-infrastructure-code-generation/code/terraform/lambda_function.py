"""
Lambda Function for Processing CloudFormation Templates
Generated by Amazon Q Developer and AWS Infrastructure Composer

This function validates CloudFormation templates uploaded to S3 and optionally
deploys infrastructure stacks based on configuration.
"""

import json
import boto3
import logging
import os
from urllib.parse import unquote_plus
from typing import Dict, List, Any, Optional

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients
s3_client = boto3.client('s3')
cfn_client = boto3.client('cloudformation')
sns_client = boto3.client('sns')

# Environment variables
BUCKET_NAME = os.environ.get('BUCKET_NAME')
AUTO_DEPLOY_PREFIX = os.environ.get('AUTO_DEPLOY_PREFIX', '${auto_deploy_prefix}')
ENABLE_AUTO_DEPLOYMENT = os.environ.get('ENABLE_AUTO_DEPLOYMENT', '${enable_auto_deployment}').lower() == 'true'
ENVIRONMENT = os.environ.get('ENVIRONMENT', 'dev')
APPLICATION_NAME = os.environ.get('APPLICATION_NAME', 'q-developer-automation')


def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Main Lambda handler for processing CloudFormation templates
    
    Args:
        event: S3 event notification
        context: Lambda runtime context
        
    Returns:
        Response dictionary with status and message
    """
    try:
        logger.info(f"Processing S3 event: {json.dumps(event, default=str)}")
        
        # Process each record in the event
        for record in event['Records']:
            try:
                # Extract S3 event information
                bucket = record['s3']['bucket']['name']
                key = unquote_plus(record['s3']['object']['key'])
                event_name = record['eventName']
                
                logger.info(f"Processing {event_name} for object: {key} in bucket: {bucket}")
                
                # Only process template files
                if not key.endswith('.json') or not key.startswith('templates/'):
                    logger.info(f"Skipping non-template file: {key}")
                    continue
                
                # Process the template
                process_template(bucket, key)
                
            except Exception as record_error:
                logger.error(f"Error processing record: {str(record_error)}")
                # Continue processing other records
                continue
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Template processing completed successfully',
                'environment': ENVIRONMENT,
                'timestamp': context.aws_request_id if context else 'unknown'
            })
        }
        
    except Exception as e:
        logger.error(f"Lambda execution error: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': f'Error processing templates: {str(e)}',
                'environment': ENVIRONMENT
            })
        }


def process_template(bucket: str, key: str) -> None:
    """
    Process a CloudFormation template file
    
    Args:
        bucket: S3 bucket name
        key: S3 object key
    """
    try:
        # Download template from S3
        logger.info(f"Downloading template: {key}")
        response = s3_client.get_object(Bucket=bucket, Key=key)
        template_body = response['Body'].read().decode('utf-8')
        
        # Parse template to check if it's valid JSON
        try:
            template_data = json.loads(template_body)
        except json.JSONDecodeError as json_error:
            logger.error(f"Invalid JSON in template {key}: {str(json_error)}")
            store_validation_error(bucket, key, f"Invalid JSON: {str(json_error)}")
            return
        
        # Validate CloudFormation template
        validation_result = validate_template(template_body, key)
        
        # Store validation results
        store_validation_result(bucket, key, validation_result)
        
        # Check for auto-deployment
        if should_auto_deploy(key, template_data):
            deploy_template(template_body, key, template_data, validation_result)
            
    except Exception as e:
        logger.error(f"Error processing template {key}: {str(e)}")
        store_validation_error(bucket, key, str(e))


def validate_template(template_body: str, template_key: str) -> Dict[str, Any]:
    """
    Validate CloudFormation template using AWS API
    
    Args:
        template_body: CloudFormation template content
        template_key: S3 object key for the template
        
    Returns:
        Validation result dictionary
    """
    try:
        logger.info(f"Validating template: {template_key}")
        
        # Validate template with CloudFormation
        validation_response = cfn_client.validate_template(
            TemplateBody=template_body
        )
        
        # Parse template for metadata
        template_data = json.loads(template_body)
        
        # Build validation result
        validation_result = {
            'template_file': template_key,
            'validation_status': 'VALID',
            'timestamp': boto3.session.Session().region_name,  # Using as timestamp placeholder
            'description': validation_response.get('Description', 'No description provided'),
            'parameters': validation_response.get('Parameters', []),
            'capabilities': validation_response.get('Capabilities', []),
            'capabilities_reason': validation_response.get('CapabilitiesReason', ''),
            'metadata': template_data.get('Metadata', {}),
            'resources_count': len(template_data.get('Resources', {})),
            'outputs_count': len(template_data.get('Outputs', {})),
            'environment': ENVIRONMENT,
            'processed_by': APPLICATION_NAME
        }
        
        logger.info(f"Template validation successful for {template_key}")
        return validation_result
        
    except Exception as validation_error:
        logger.error(f"Template validation failed for {template_key}: {str(validation_error)}")
        
        return {
            'template_file': template_key,
            'validation_status': 'INVALID',
            'timestamp': boto3.session.Session().region_name,  # Using as timestamp placeholder
            'error': str(validation_error),
            'error_type': type(validation_error).__name__,
            'environment': ENVIRONMENT,
            'processed_by': APPLICATION_NAME
        }


def should_auto_deploy(template_key: str, template_data: Dict[str, Any]) -> bool:
    """
    Determine if template should be automatically deployed
    
    Args:
        template_key: S3 object key for the template
        template_data: Parsed template content
        
    Returns:
        True if template should be auto-deployed
    """
    if not ENABLE_AUTO_DEPLOYMENT:
        return False
    
    # Check if template is in auto-deploy prefix
    if template_key.startswith(AUTO_DEPLOY_PREFIX):
        logger.info(f"Template {template_key} marked for auto-deployment (prefix match)")
        return True
    
    # Check metadata for auto-deploy flag
    metadata = template_data.get('Metadata', {})
    if metadata.get('AutoDeploy', False):
        logger.info(f"Template {template_key} marked for auto-deployment (metadata flag)")
        return True
    
    return False


def deploy_template(template_body: str, template_key: str, 
                   template_data: Dict[str, Any], validation_result: Dict[str, Any]) -> None:
    """
    Deploy CloudFormation template automatically
    
    Args:
        template_body: CloudFormation template content
        template_key: S3 object key for the template
        template_data: Parsed template content
        validation_result: Template validation results
    """
    try:
        # Generate stack name
        metadata = template_data.get('Metadata', {})
        stack_name = metadata.get('StackName', 
                                f"{APPLICATION_NAME}-{template_key.replace('.json', '').replace('/', '-')}")
        
        # Ensure stack name is valid (no underscores, max 128 chars)
        stack_name = stack_name.replace('_', '-').replace(' ', '-')[:128]
        
        logger.info(f"Auto-deploying stack: {stack_name}")
        
        # Check if stack already exists
        try:
            cfn_client.describe_stacks(StackName=stack_name)
            logger.info(f"Stack {stack_name} already exists, updating...")
            
            # Update existing stack
            cfn_client.update_stack(
                StackName=stack_name,
                TemplateBody=template_body,
                Capabilities=validation_result.get('capabilities', ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM']),
                Tags=[
                    {'Key': 'Source', 'Value': 'QDeveloperAutomation'},
                    {'Key': 'TemplateFile', 'Value': template_key},
                    {'Key': 'Environment', 'Value': ENVIRONMENT},
                    {'Key': 'Application', 'Value': APPLICATION_NAME},
                    {'Key': 'AutoDeployed', 'Value': 'true'}
                ]
            )
            
        except cfn_client.exceptions.ClientError as e:
            if 'does not exist' in str(e):
                # Create new stack
                cfn_client.create_stack(
                    StackName=stack_name,
                    TemplateBody=template_body,
                    Capabilities=validation_result.get('capabilities', ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM']),
                    OnFailure='ROLLBACK',
                    Tags=[
                        {'Key': 'Source', 'Value': 'QDeveloperAutomation'},
                        {'Key': 'TemplateFile', 'Value': template_key},
                        {'Key': 'Environment', 'Value': ENVIRONMENT},
                        {'Key': 'Application', 'Value': APPLICATION_NAME},
                        {'Key': 'AutoDeployed', 'Value': 'true'}
                    ]
                )
            else:
                raise e
        
        logger.info(f"Stack deployment initiated: {stack_name}")
        
        # Store deployment information
        deployment_info = {
            'template_file': template_key,
            'stack_name': stack_name,
            'deployment_status': 'INITIATED',
            'timestamp': boto3.session.Session().region_name,  # Using as timestamp placeholder
            'environment': ENVIRONMENT,
            'capabilities_used': validation_result.get('capabilities', [])
        }
        
        # Save deployment info to S3
        deployment_key = f"deployment-results/{template_key.replace('.json', '-deployment.json')}"
        s3_client.put_object(
            Bucket=BUCKET_NAME,
            Key=deployment_key,
            Body=json.dumps(deployment_info, indent=2),
            ContentType='application/json'
        )
        
    except Exception as deploy_error:
        logger.error(f"Auto-deployment failed for {template_key}: {str(deploy_error)}")
        
        # Store deployment error
        deployment_error = {
            'template_file': template_key,
            'deployment_status': 'FAILED',
            'error': str(deploy_error),
            'timestamp': boto3.session.Session().region_name,  # Using as timestamp placeholder
            'environment': ENVIRONMENT
        }
        
        error_key = f"deployment-results/{template_key.replace('.json', '-deployment-error.json')}"
        s3_client.put_object(
            Bucket=BUCKET_NAME,
            Key=error_key,
            Body=json.dumps(deployment_error, indent=2),
            ContentType='application/json'
        )


def store_validation_result(bucket: str, template_key: str, validation_result: Dict[str, Any]) -> None:
    """
    Store template validation results in S3
    
    Args:
        bucket: S3 bucket name
        template_key: Original template S3 key
        validation_result: Validation result dictionary
    """
    try:
        # Generate result file name
        result_key = f"validation-results/{template_key.replace('.json', '-validation.json')}"
        
        # Store validation results
        s3_client.put_object(
            Bucket=bucket,
            Key=result_key,
            Body=json.dumps(validation_result, indent=2),
            ContentType='application/json',
            Metadata={
                'template-file': template_key,
                'validation-status': validation_result['validation_status'],
                'environment': ENVIRONMENT
            }
        )
        
        logger.info(f"Validation results stored: {result_key}")
        
    except Exception as e:
        logger.error(f"Failed to store validation results for {template_key}: {str(e)}")


def store_validation_error(bucket: str, template_key: str, error_message: str) -> None:
    """
    Store template validation error in S3
    
    Args:
        bucket: S3 bucket name
        template_key: Original template S3 key
        error_message: Error message
    """
    try:
        # Create error result
        error_result = {
            'template_file': template_key,
            'validation_status': 'ERROR',
            'error': error_message,
            'timestamp': boto3.session.Session().region_name,  # Using as timestamp placeholder
            'environment': ENVIRONMENT,
            'processed_by': APPLICATION_NAME
        }
        
        # Generate error file name
        error_key = f"validation-results/{template_key.replace('.json', '-error.json')}"
        
        # Store error results
        s3_client.put_object(
            Bucket=bucket,
            Key=error_key,
            Body=json.dumps(error_result, indent=2),
            ContentType='application/json',
            Metadata={
                'template-file': template_key,
                'validation-status': 'ERROR',
                'environment': ENVIRONMENT
            }
        )
        
        logger.info(f"Validation error stored: {error_key}")
        
    except Exception as e:
        logger.error(f"Failed to store validation error for {template_key}: {str(e)}")