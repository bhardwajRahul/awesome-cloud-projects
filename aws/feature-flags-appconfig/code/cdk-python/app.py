#!/usr/bin/env python3
"""
AWS CDK Application for Feature Flags with AWS AppConfig

This CDK application deploys a complete feature flag management system using
AWS AppConfig, Lambda, and CloudWatch. It demonstrates best practices for
safe feature rollouts with monitoring and automatic rollback capabilities.

Author: Generated by AWS CDK for feature flags recipe
Version: 1.0
"""

import os
from typing import Dict, Any

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Duration,
    CfnOutput,
    RemovalPolicy,
    aws_appconfig as appconfig,
    aws_lambda as lambda_,
    aws_iam as iam,
    aws_cloudwatch as cloudwatch,
    aws_logs as logs,
)
from constructs import Construct


class FeatureFlagsAppConfigStack(Stack):
    """
    CDK Stack for Feature Flags with AWS AppConfig
    
    This stack creates:
    - AWS AppConfig application with feature flags
    - Lambda function with AppConfig integration
    - CloudWatch monitoring and alarms
    - IAM roles and policies for secure access
    - Deployment strategy for gradual rollouts
    """

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Stack parameters
        self.app_name = f"feature-demo-app-{self.node.addr[:6]}"
        self.environment_name = "production"
        self.profile_name = "feature-flags"

        # Create AWS AppConfig application
        self.appconfig_app = self._create_appconfig_application()
        
        # Create deployment strategy
        self.deployment_strategy = self._create_deployment_strategy()
        
        # Create Lambda execution role
        self.lambda_role = self._create_lambda_role()
        
        # Create Lambda function
        self.lambda_function = self._create_lambda_function()
        
        # Create CloudWatch alarm
        self.cloudwatch_alarm = self._create_cloudwatch_alarm()
        
        # Create service-linked role for AppConfig
        self.service_role = self._create_service_linked_role()
        
        # Create AppConfig environment with monitoring
        self.appconfig_environment = self._create_appconfig_environment()
        
        # Create configuration profile
        self.config_profile = self._create_configuration_profile()
        
        # Create initial configuration
        self.config_version = self._create_configuration_version()
        
        # Create stack outputs
        self._create_outputs()

    def _create_appconfig_application(self) -> appconfig.CfnApplication:
        """Create AWS AppConfig application"""
        return appconfig.CfnApplication(
            self, "AppConfigApplication",
            name=self.app_name,
            description="Feature flag demo application for safe deployments"
        )

    def _create_deployment_strategy(self) -> appconfig.CfnDeploymentStrategy:
        """Create deployment strategy for gradual rollout"""
        return appconfig.CfnDeploymentStrategy(
            self, "DeploymentStrategy",
            name=f"gradual-rollout-{self.node.addr[:6]}",
            description="Gradual rollout over 20 minutes with monitoring",
            deployment_duration_in_minutes=20,
            final_bake_time_in_minutes=10,
            growth_factor=25.0,
            growth_type="LINEAR",
            replicate_to="NONE"
        )

    def _create_lambda_role(self) -> iam.Role:
        """Create IAM role for Lambda function with AppConfig access"""
        role = iam.Role(
            self, "LambdaRole",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            description="Role for Lambda function to access AppConfig",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ]
        )

        # Add AppConfig permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "appconfig:StartConfigurationSession",
                    "appconfig:GetLatestConfiguration"
                ],
                resources=["*"]
            )
        )

        return role

    def _create_lambda_function(self) -> lambda_.Function:
        """Create Lambda function with AppConfig integration"""
        # Create CloudWatch log group with retention
        log_group = logs.LogGroup(
            self, "LambdaLogGroup",
            log_group_name=f"/aws/lambda/{self.app_name}-demo",
            retention=logs.RetentionDays.ONE_WEEK,
            removal_policy=RemovalPolicy.DESTROY
        )

        function = lambda_.Function(
            self, "FeatureFlagDemoFunction",
            function_name=f"{self.app_name}-demo",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            role=self.lambda_role,
            timeout=Duration.seconds(30),
            memory_size=256,
            log_group=log_group,
            environment={
                "APP_ID": self.appconfig_app.ref,
                "ENV_ID": "",  # Will be set after environment creation
                "PROFILE_ID": ""  # Will be set after profile creation
            },
            code=lambda_.Code.from_inline(self._get_lambda_code())
        )

        # Add AppConfig Lambda extension layer
        function.add_layers(
            lambda_.LayerVersion.from_layer_version_arn(
                self, "AppConfigLayer",
                layer_version_arn=f"arn:aws:lambda:{self.region}:027255383542:layer:AWS-AppConfig-Extension:82"
            )
        )

        return function

    def _create_cloudwatch_alarm(self) -> cloudwatch.Alarm:
        """Create CloudWatch alarm for monitoring Lambda errors"""
        return cloudwatch.Alarm(
            self, "LambdaErrorAlarm",
            alarm_name=f"lambda-error-rate-{self.node.addr[:6]}",
            alarm_description="Monitor Lambda function error rate for AppConfig rollback",
            metric=cloudwatch.Metric(
                namespace="AWS/Lambda",
                metric_name="Errors",
                dimensions_map={
                    "FunctionName": self.lambda_function.function_name
                },
                statistic="Sum",
                period=Duration.minutes(5)
            ),
            threshold=5,
            evaluation_periods=2,
            comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            treat_missing_data=cloudwatch.TreatMissingData.NOT_BREACHING
        )

    def _create_service_linked_role(self) -> iam.CfnServiceLinkedRole:
        """Create service-linked role for AppConfig monitoring"""
        return iam.CfnServiceLinkedRole(
            self, "AppConfigServiceLinkedRole",
            aws_service_name="appconfig.amazonaws.com",
            description="Service-linked role for AppConfig monitoring"
        )

    def _create_appconfig_environment(self) -> appconfig.CfnEnvironment:
        """Create AppConfig environment with monitoring"""
        environment = appconfig.CfnEnvironment(
            self, "AppConfigEnvironment",
            application_id=self.appconfig_app.ref,
            name=self.environment_name,
            description="Production environment with automated rollback",
            monitors=[
                appconfig.CfnEnvironment.MonitorsProperty(
                    alarm_arn=self.cloudwatch_alarm.alarm_arn,
                    alarm_role_arn=self.service_role.attr_arn
                )
            ]
        )

        # Update Lambda environment variables
        self.lambda_function.add_environment("ENV_ID", environment.ref)

        return environment

    def _create_configuration_profile(self) -> appconfig.CfnConfigurationProfile:
        """Create feature flag configuration profile"""
        profile = appconfig.CfnConfigurationProfile(
            self, "ConfigurationProfile",
            application_id=self.appconfig_app.ref,
            name=self.profile_name,
            location_uri="hosted",
            type="AWS.AppConfig.FeatureFlags",
            description="Feature flags for gradual rollout and A/B testing"
        )

        # Update Lambda environment variables
        self.lambda_function.add_environment("PROFILE_ID", profile.ref)

        return profile

    def _create_configuration_version(self) -> appconfig.CfnHostedConfigurationVersion:
        """Create initial feature flag configuration"""
        feature_flags_config = {
            "flags": {
                "new-checkout-flow": {
                    "name": "new-checkout-flow",
                    "enabled": False,
                    "attributes": {
                        "rollout-percentage": {
                            "constraints": {
                                "type": "number",
                                "required": True
                            }
                        },
                        "target-audience": {
                            "constraints": {
                                "type": "string",
                                "required": False
                            }
                        }
                    }
                },
                "enhanced-search": {
                    "name": "enhanced-search",
                    "enabled": True,
                    "attributes": {
                        "search-algorithm": {
                            "constraints": {
                                "type": "string",
                                "required": True
                            }
                        },
                        "cache-ttl": {
                            "constraints": {
                                "type": "number",
                                "required": False
                            }
                        }
                    }
                },
                "premium-features": {
                    "name": "premium-features",
                    "enabled": False,
                    "attributes": {
                        "feature-list": {
                            "constraints": {
                                "type": "string",
                                "required": False
                            }
                        }
                    }
                }
            },
            "attributes": {
                "rollout-percentage": {
                    "number": 0
                },
                "target-audience": {
                    "string": "beta-users"
                },
                "search-algorithm": {
                    "string": "elasticsearch"
                },
                "cache-ttl": {
                    "number": 300
                },
                "feature-list": {
                    "string": "advanced-analytics,priority-support"
                }
            }
        }

        return appconfig.CfnHostedConfigurationVersion(
            self, "ConfigurationVersion",
            application_id=self.appconfig_app.ref,
            configuration_profile_id=self.config_profile.ref,
            content_type="application/json",
            content=cdk.Fn.to_json_string(feature_flags_config),
            description="Initial feature flag configuration"
        )

    def _get_lambda_code(self) -> str:
        """Generate Lambda function code for feature flag demonstration"""
        return """
import json
import urllib.request
import urllib.error
import os

def lambda_handler(event, context):
    \"\"\"
    Lambda function demonstrating feature flag integration with AWS AppConfig
    
    This function retrieves feature flags from AppConfig and demonstrates
    how applications can use them to control feature behavior.
    \"\"\"
    # AppConfig Lambda extension endpoint
    appconfig_url = f"http://localhost:2772/applications/{os.environ['APP_ID']}/environments/{os.environ['ENV_ID']}/configurations/{os.environ['PROFILE_ID']}"
    
    try:
        # Retrieve feature flags from AppConfig
        request = urllib.request.Request(appconfig_url)
        with urllib.request.urlopen(request, timeout=10) as response:
            config_data = json.loads(response.read().decode())
        
        # Extract feature flags
        flags = config_data.get('flags', {})
        attributes = config_data.get('attributes', {})
        
        # Business logic using feature flags
        result = {
            'message': 'Feature flag demo response',
            'features': {}
        }
        
        # Check new checkout flow
        if flags.get('new-checkout-flow', {}).get('enabled', False):
            rollout_percentage = attributes.get('rollout-percentage', {}).get('number', 0)
            result['features']['checkout'] = {
                'enabled': True,
                'type': 'new-flow',
                'rollout_percentage': rollout_percentage
            }
        else:
            result['features']['checkout'] = {
                'enabled': False,
                'type': 'legacy-flow'
            }
        
        # Check enhanced search
        if flags.get('enhanced-search', {}).get('enabled', False):
            search_algorithm = attributes.get('search-algorithm', {}).get('string', 'basic')
            cache_ttl = attributes.get('cache-ttl', {}).get('number', 300)
            result['features']['search'] = {
                'enabled': True,
                'algorithm': search_algorithm,
                'cache_ttl': cache_ttl
            }
        else:
            result['features']['search'] = {
                'enabled': False,
                'algorithm': 'basic'
            }
        
        # Check premium features
        if flags.get('premium-features', {}).get('enabled', False):
            feature_list = attributes.get('feature-list', {}).get('string', '')
            result['features']['premium'] = {
                'enabled': True,
                'features': feature_list.split(',') if feature_list else []
            }
        else:
            result['features']['premium'] = {
                'enabled': False,
                'features': []
            }
        
        return {
            'statusCode': 200,
            'body': json.dumps(result, indent=2)
        }
        
    except urllib.error.HTTPError as e:
        print(f"HTTP Error retrieving feature flags: {e.code} - {e.reason}")
        return create_fallback_response(str(e))
    except urllib.error.URLError as e:
        print(f"URL Error retrieving feature flags: {str(e)}")
        return create_fallback_response(str(e))
    except json.JSONDecodeError as e:
        print(f"JSON decode error: {str(e)}")
        return create_fallback_response(str(e))
    except Exception as e:
        print(f"Unexpected error retrieving feature flags: {str(e)}")
        return create_fallback_response(str(e))

def create_fallback_response(error_msg):
    \"\"\"Create fallback response when feature flags are unavailable\"\"\"
    return {
        'statusCode': 200,
        'body': json.dumps({
            'message': 'Using default configuration due to error',
            'error': error_msg,
            'features': {
                'checkout': {'enabled': False, 'type': 'legacy-flow'},
                'search': {'enabled': False, 'algorithm': 'basic'},
                'premium': {'enabled': False, 'features': []}
            }
        }, indent=2)
    }
"""

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs for important resources"""
        CfnOutput(
            self, "AppConfigApplicationId",
            value=self.appconfig_app.ref,
            description="AWS AppConfig Application ID",
            export_name=f"{self.stack_name}-AppConfigApplicationId"
        )

        CfnOutput(
            self, "AppConfigEnvironmentId",
            value=self.appconfig_environment.ref,
            description="AWS AppConfig Environment ID",
            export_name=f"{self.stack_name}-AppConfigEnvironmentId"
        )

        CfnOutput(
            self, "ConfigurationProfileId",
            value=self.config_profile.ref,
            description="AWS AppConfig Configuration Profile ID",
            export_name=f"{self.stack_name}-ConfigurationProfileId"
        )

        CfnOutput(
            self, "DeploymentStrategyId",
            value=self.deployment_strategy.ref,
            description="AWS AppConfig Deployment Strategy ID",
            export_name=f"{self.stack_name}-DeploymentStrategyId"
        )

        CfnOutput(
            self, "LambdaFunctionName",
            value=self.lambda_function.function_name,
            description="Lambda Function Name for testing feature flags",
            export_name=f"{self.stack_name}-LambdaFunctionName"
        )

        CfnOutput(
            self, "LambdaFunctionArn",
            value=self.lambda_function.function_arn,
            description="Lambda Function ARN",
            export_name=f"{self.stack_name}-LambdaFunctionArn"
        )

        CfnOutput(
            self, "CloudWatchAlarmName",
            value=self.cloudwatch_alarm.alarm_name,
            description="CloudWatch Alarm for monitoring Lambda errors",
            export_name=f"{self.stack_name}-CloudWatchAlarmName"
        )


# CDK App instantiation
app = cdk.App()

# Get environment from context or use defaults
env = cdk.Environment(
    account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
    region=os.environ.get("CDK_DEFAULT_REGION")
)

# Create the feature flags stack
FeatureFlagsAppConfigStack(
    app, "FeatureFlagsAppConfigStack",
    env=env,
    description="Feature Flags with AWS AppConfig - CDK Implementation",
    tags={
        "Project": "feature-flags-appconfig",
        "Environment": "demo",
        "ManagedBy": "CDK"
    }
)

# Synthesize the CDK app
app.synth()