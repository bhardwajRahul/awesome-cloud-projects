#!/usr/bin/env python3
"""
CDK Python application for Serverless API Patterns with Lambda Authorizers and API Gateway

This application demonstrates comprehensive serverless API security using AWS API Gateway 
with custom Lambda authorizers. It implements both TOKEN and REQUEST authorizer patterns
for flexible authentication and authorization scenarios.

Architecture Overview:
- API Gateway REST API with hierarchical resource structure
- TOKEN-based Lambda authorizer for Bearer token validation
- REQUEST-based Lambda authorizer for context-aware authorization
- Protected and public Lambda functions for business logic
- Comprehensive IAM roles and permissions
- CloudWatch logging integration

Author: Generated by CDK Generator
Version: 1.0
"""

import os
from typing import Dict, Any

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Duration,
    CfnOutput,
    aws_lambda as _lambda,
    aws_apigateway as apigateway,
    aws_iam as iam,
    aws_logs as logs,
)
from constructs import Construct


class ServerlessApiPatternsStack(Stack):
    """
    CDK Stack for implementing serverless API patterns with Lambda authorizers.
    
    This stack creates:
    - Lambda functions for token-based and request-based authorization
    - API Gateway REST API with custom authorizers
    - Business logic Lambda functions (protected and public)
    - Proper IAM roles and permissions
    - CloudWatch log groups for monitoring
    """

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Generate unique suffix for resource naming
        unique_suffix = self.node.addr[-6:].lower()
        
        # Common Lambda runtime and architecture settings
        lambda_runtime = _lambda.Runtime.PYTHON_3_9
        lambda_architecture = _lambda.Architecture.X86_64
        lambda_timeout = Duration.seconds(30)

        # Create IAM role for Lambda functions
        lambda_execution_role = self._create_lambda_execution_role(unique_suffix)

        # Create Lambda authorizer functions
        token_authorizer = self._create_token_authorizer(
            unique_suffix, lambda_runtime, lambda_architecture, 
            lambda_timeout, lambda_execution_role
        )
        
        request_authorizer = self._create_request_authorizer(
            unique_suffix, lambda_runtime, lambda_architecture,
            lambda_timeout, lambda_execution_role
        )

        # Create business logic Lambda functions
        protected_api_function = self._create_protected_api_function(
            unique_suffix, lambda_runtime, lambda_architecture,
            lambda_timeout, lambda_execution_role
        )
        
        public_api_function = self._create_public_api_function(
            unique_suffix, lambda_runtime, lambda_architecture,
            lambda_timeout, lambda_execution_role
        )

        # Create API Gateway with authorizers and resources
        api_gateway = self._create_api_gateway(
            unique_suffix, token_authorizer, request_authorizer,
            protected_api_function, public_api_function
        )

        # Create CloudWatch log groups for better log organization
        self._create_log_groups(
            token_authorizer, request_authorizer, 
            protected_api_function, public_api_function
        )

        # Export important outputs
        self._create_outputs(api_gateway, token_authorizer, request_authorizer)

    def _create_lambda_execution_role(self, unique_suffix: str) -> iam.Role:
        """
        Create IAM role for Lambda function execution with necessary permissions.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            
        Returns:
            IAM Role for Lambda execution
        """
        role = iam.Role(
            self, "LambdaExecutionRole",
            role_name=f"api-auth-lambda-role-{unique_suffix}",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            description="Execution role for API Gateway authorizer and business logic Lambda functions",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ]
        )

        # Add custom policy for enhanced logging capabilities
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream", 
                    "logs:PutLogEvents",
                    "logs:DescribeLogGroups",
                    "logs:DescribeLogStreams"
                ],
                resources=[f"arn:aws:logs:{self.region}:{self.account}:*"]
            )
        )

        return role

    def _create_token_authorizer(
        self, unique_suffix: str, runtime: _lambda.Runtime,
        architecture: _lambda.Architecture, timeout: Duration,
        execution_role: iam.Role
    ) -> _lambda.Function:
        """
        Create token-based Lambda authorizer for Bearer token validation.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            runtime: Lambda runtime environment
            architecture: Lambda architecture (x86_64 or ARM64)
            timeout: Function timeout duration
            execution_role: IAM role for Lambda execution
            
        Returns:
            Lambda Function for token authorization
        """
        return _lambda.Function(
            self, "TokenAuthorizerFunction",
            function_name=f"token-authorizer-{unique_suffix}",
            runtime=runtime,
            architecture=architecture,
            handler="index.lambda_handler",
            timeout=timeout,
            role=execution_role,
            description="Token-based authorizer for API Gateway Bearer token validation",
            environment={
                "LOG_LEVEL": "INFO",
                "AUTHORIZER_TYPE": "TOKEN"
            },
            code=_lambda.Code.from_inline('''
import json
import logging
import os

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

def lambda_handler(event, context):
    """
    Token-based authorizer that validates Bearer tokens.
    
    This authorizer implements JWT-style token validation with support for
    different user roles and permissions. In production, replace the hardcoded
    tokens with proper JWT validation including signature verification,
    expiration checking, and claims validation.
    
    Args:
        event: API Gateway authorizer event containing token and method ARN
        context: Lambda context object
        
    Returns:
        IAM policy document with authorization decision
    """
    logger.info(f"Token Authorizer invoked: {json.dumps(event, default=str)}")
    
    try:
        # Extract token from event
        token = event.get('authorizationToken', '')
        method_arn = event.get('methodArn', '')
        
        if not token.startswith('Bearer '):
            logger.warning("Invalid token format - missing Bearer prefix")
            raise Exception('Unauthorized')
        
        # Extract actual token value
        actual_token = token.replace('Bearer ', '')
        logger.info(f"Validating token for method: {method_arn}")
        
        # Token validation logic (simplified for demo)
        # In production, implement proper JWT validation
        valid_tokens = {
            'admin-token': {
                'principalId': 'admin-user',
                'effect': 'Allow',
                'context': {
                    'role': 'admin',
                    'permissions': 'read,write,delete',
                    'user_id': 'admin-123',
                    'organization': 'example-org'
                }
            },
            'user-token': {
                'principalId': 'regular-user',
                'effect': 'Allow', 
                'context': {
                    'role': 'user',
                    'permissions': 'read',
                    'user_id': 'user-456',
                    'organization': 'example-org'
                }
            },
            'manager-token': {
                'principalId': 'manager-user',
                'effect': 'Allow',
                'context': {
                    'role': 'manager',
                    'permissions': 'read,write',
                    'user_id': 'manager-789',
                    'organization': 'example-org'
                }
            }
        }
        
        if actual_token not in valid_tokens:
            logger.warning(f"Invalid token provided: {actual_token[:10]}...")
            raise Exception('Unauthorized')
        
        token_info = valid_tokens[actual_token]
        logger.info(f"Token validated for principal: {token_info['principalId']}")
        
        # Generate IAM policy
        policy = generate_policy(
            token_info['principalId'],
            token_info['effect'],
            method_arn,
            token_info['context']
        )
        
        logger.info("Authorization successful")
        return policy
        
    except Exception as e:
        logger.error(f"Authorization failed: {str(e)}")
        raise Exception('Unauthorized')

def generate_policy(principal_id: str, effect: str, resource: str, context: dict = None) -> dict:
    """
    Generate IAM policy document for API Gateway authorization.
    
    Args:
        principal_id: Unique identifier for the authorized principal
        effect: Allow or Deny access
        resource: API Gateway method ARN
        context: Additional context to pass to downstream Lambda
        
    Returns:
        IAM policy document with authorization decision
    """
    policy = {
        'principalId': principal_id,
        'policyDocument': {
            'Version': '2012-10-17',
            'Statement': [
                {
                    'Action': 'execute-api:Invoke',
                    'Effect': effect,
                    'Resource': resource
                }
            ]
        }
    }
    
    # Add context for downstream Lambda functions
    if context:
        policy['context'] = {k: str(v) for k, v in context.items()}
    
    return policy
            ''')
        )

    def _create_request_authorizer(
        self, unique_suffix: str, runtime: _lambda.Runtime,
        architecture: _lambda.Architecture, timeout: Duration,
        execution_role: iam.Role
    ) -> _lambda.Function:
        """
        Create request-based Lambda authorizer for comprehensive request validation.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            runtime: Lambda runtime environment
            architecture: Lambda architecture (x86_64 or ARM64)
            timeout: Function timeout duration
            execution_role: IAM role for Lambda execution
            
        Returns:
            Lambda Function for request-based authorization
        """
        return _lambda.Function(
            self, "RequestAuthorizerFunction",
            function_name=f"request-authorizer-{unique_suffix}",
            runtime=runtime,
            architecture=architecture,
            handler="index.lambda_handler",
            timeout=timeout,
            role=execution_role,
            description="Request-based authorizer for comprehensive API Gateway request validation",
            environment={
                "LOG_LEVEL": "INFO",
                "AUTHORIZER_TYPE": "REQUEST"
            },
            code=_lambda.Code.from_inline('''
import json
import logging
import os
from urllib.parse import parse_qs

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

def lambda_handler(event, context):
    """
    Request-based authorizer that validates complete request context.
    
    This authorizer analyzes the full HTTP request including headers,
    query parameters, source IP, and other metadata to make authorization
    decisions. It supports multiple authentication methods and can implement
    complex business logic for access control.
    
    Args:
        event: API Gateway authorizer event with complete request context
        context: Lambda context object
        
    Returns:
        IAM policy document with authorization decision
    """
    logger.info(f"Request Authorizer invoked: {json.dumps(event, default=str)}")
    
    try:
        # Extract request details
        headers = event.get('headers', {}) or {}
        query_params = event.get('queryStringParameters', {}) or {}
        method_arn = event.get('methodArn', '')
        request_context = event.get('requestContext', {})
        identity = request_context.get('identity', {})
        source_ip = identity.get('sourceIp', 'unknown')
        user_agent = identity.get('userAgent', 'unknown')
        
        logger.info(f"Request from IP: {source_ip}, User-Agent: {user_agent}")
        logger.info(f"Headers: {list(headers.keys())}")
        logger.info(f"Query params: {list(query_params.keys())}")
        
        # Initialize authorization variables
        principal_id = 'unknown'
        effect = 'Deny'
        context_data = {
            'sourceIp': source_ip,
            'userAgent': user_agent,
            'authType': 'none'
        }
        
        # API Key validation (query parameter)
        api_key = query_params.get('api_key', '')
        if api_key == 'secret-api-key-123':
            principal_id = 'api-key-user'
            effect = 'Allow'
            context_data.update({
                'authType': 'api-key',
                'permissions': 'read,write',
                'user_id': 'apikey-user-123'
            })
            logger.info("Authorized via API key")
            
        # Custom header validation
        elif headers.get('X-Custom-Auth') == 'custom-auth-value':
            principal_id = 'custom-user'
            effect = 'Allow'
            context_data.update({
                'authType': 'custom-header',
                'permissions': 'read',
                'user_id': 'custom-user-456'
            })
            logger.info("Authorized via custom header")
            
        # IP-based validation (internal networks)
        elif source_ip.startswith('10.') or source_ip.startswith('172.') or source_ip.startswith('192.168.'):
            principal_id = 'internal-user'
            effect = 'Allow'
            context_data.update({
                'authType': 'ip-whitelist',
                'permissions': 'read,write,delete',
                'user_id': 'internal-user-789'
            })
            logger.info("Authorized via IP whitelist")
            
        # Organization-specific validation
        elif headers.get('X-Organization-Id') == 'example-org-123':
            org_token = headers.get('X-Organization-Token', '')
            if org_token == 'org-secret-token':
                principal_id = 'organization-user'
                effect = 'Allow'
                context_data.update({
                    'authType': 'organization',
                    'permissions': 'read,write',
                    'organization': 'example-org-123',
                    'user_id': 'org-user-999'
                })
                logger.info("Authorized via organization credentials")
        
        # Device-based validation
        elif headers.get('X-Device-Id'):
            device_id = headers.get('X-Device-Id')
            device_secret = headers.get('X-Device-Secret')
            # Simplified device validation
            if device_secret == 'device-secret-123':
                principal_id = f'device-{device_id}'
                effect = 'Allow'
                context_data.update({
                    'authType': 'device',
                    'permissions': 'read',
                    'device_id': device_id,
                    'user_id': f'device-{device_id}'
                })
                logger.info(f"Authorized device: {device_id}")
        
        if effect == 'Deny':
            logger.warning("Authorization denied - no valid credentials found")
            raise Exception('Unauthorized')
        
        # Generate IAM policy
        policy = generate_policy(principal_id, effect, method_arn, context_data)
        
        logger.info(f"Authorization successful for: {principal_id}")
        return policy
        
    except Exception as e:
        logger.error(f"Authorization failed: {str(e)}")
        raise Exception('Unauthorized')

def generate_policy(principal_id: str, effect: str, resource: str, context: dict = None) -> dict:
    """
    Generate IAM policy document for API Gateway authorization.
    
    Args:
        principal_id: Unique identifier for the authorized principal
        effect: Allow or Deny access
        resource: API Gateway method ARN
        context: Additional context to pass to downstream Lambda
        
    Returns:
        IAM policy document with authorization decision
    """
    policy = {
        'principalId': principal_id,
        'policyDocument': {
            'Version': '2012-10-17',
            'Statement': [
                {
                    'Action': 'execute-api:Invoke',
                    'Effect': effect,
                    'Resource': resource
                }
            ]
        }
    }
    
    # Add context for downstream Lambda functions
    if context:
        policy['context'] = {k: str(v) for k, v in context.items()}
    
    return policy
            ''')
        )

    def _create_protected_api_function(
        self, unique_suffix: str, runtime: _lambda.Runtime,
        architecture: _lambda.Architecture, timeout: Duration,
        execution_role: iam.Role
    ) -> _lambda.Function:
        """
        Create protected API Lambda function that requires authorization.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            runtime: Lambda runtime environment
            architecture: Lambda architecture (x86_64 or ARM64)
            timeout: Function timeout duration
            execution_role: IAM role for Lambda execution
            
        Returns:
            Lambda Function for protected API endpoints
        """
        return _lambda.Function(
            self, "ProtectedApiFunction",
            function_name=f"protected-api-{unique_suffix}",
            runtime=runtime,
            architecture=architecture,
            handler="index.lambda_handler",
            timeout=timeout,
            role=execution_role,
            description="Protected API function requiring authorization",
            environment={
                "LOG_LEVEL": "INFO",
                "API_VERSION": "1.0"
            },
            code=_lambda.Code.from_inline('''
import json
import logging
import os
import time
from datetime import datetime

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

def lambda_handler(event, context):
    """
    Protected API endpoint that serves authorized requests.
    
    This function demonstrates how to access authorization context
    passed from Lambda authorizers and implement role-based responses.
    The function provides different data based on user permissions
    and roles determined during authorization.
    
    Args:
        event: API Gateway proxy event with authorization context
        context: Lambda context object
        
    Returns:
        HTTP response with user-specific data
    """
    logger.info(f"Protected API invoked: {json.dumps(event, default=str)}")
    
    try:
        # Extract authorization context passed from authorizers
        request_context = event.get('requestContext', {})
        authorizer_context = request_context.get('authorizer', {})
        
        # Extract user information
        principal_id = authorizer_context.get('principalId', 'unknown')
        role = authorizer_context.get('role', 'user')
        permissions = authorizer_context.get('permissions', 'none')
        auth_type = authorizer_context.get('authType', 'token')
        source_ip = authorizer_context.get('sourceIp', 'unknown')
        user_id = authorizer_context.get('user_id', 'unknown')
        organization = authorizer_context.get('organization', 'unknown')
        
        logger.info(f"Authorized user: {principal_id}, Role: {role}, Auth: {auth_type}")
        
        # Parse permissions
        user_permissions = permissions.split(',') if permissions != 'none' else []
        
        # Build base response data
        response_data = {
            'message': 'Access granted to protected resource',
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'request_id': context.aws_request_id,
            'user': {
                'principalId': principal_id,
                'userId': user_id,
                'role': role,
                'permissions': user_permissions,
                'authType': auth_type,
                'sourceIp': source_ip,
                'organization': organization
            },
            'api': {
                'version': os.environ.get('API_VERSION', '1.0'),
                'environment': 'production',
                'region': os.environ.get('AWS_REGION', 'unknown')
            }
        }
        
        # Add role-specific data
        if 'read' in user_permissions:
            response_data['data'] = {
                'public_info': 'This information is available to all authenticated users',
                'user_specific': f'Welcome back, {principal_id}!'
            }
        
        if 'write' in user_permissions:
            response_data['data']['write_access'] = {
                'message': 'You have write permissions',
                'available_operations': ['create', 'update']
            }
        
        if 'delete' in user_permissions:
            response_data['data']['admin_access'] = {
                'message': 'You have administrative permissions',
                'available_operations': ['create', 'update', 'delete', 'manage_users']
            }
        
        # Add auth-type specific information
        if auth_type == 'api-key':
            response_data['auth_info'] = {
                'type': 'API Key Authentication',
                'security_level': 'Standard',
                'rate_limits': '1000 requests per hour'
            }
        elif auth_type == 'custom-header':
            response_data['auth_info'] = {
                'type': 'Custom Header Authentication',
                'security_level': 'Basic',
                'rate_limits': '500 requests per hour'
            }
        elif auth_type == 'ip-whitelist':
            response_data['auth_info'] = {
                'type': 'IP Whitelist Authentication',
                'security_level': 'High',
                'rate_limits': 'Unlimited (internal network)'
            }
        elif auth_type == 'organization':
            response_data['auth_info'] = {
                'type': 'Organization Authentication',
                'security_level': 'Enterprise',
                'rate_limits': '5000 requests per hour'
            }
        elif auth_type == 'device':
            response_data['auth_info'] = {
                'type': 'Device Authentication',
                'security_level': 'IoT',
                'rate_limits': '100 requests per hour'
            }
        else:
            response_data['auth_info'] = {
                'type': 'Token Authentication',
                'security_level': 'Standard',
                'rate_limits': '2000 requests per hour'
            }
        
        # Add sample protected data
        response_data['protected_data'] = {
            'secret_value': f'Confidential data for {role} users',
            'access_level': role,
            'data_classification': 'Internal Use Only',
            'last_accessed': datetime.utcnow().isoformat() + 'Z'
        }
        
        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
                'X-Request-ID': context.aws_request_id,
                'X-User-Role': role
            },
            'body': json.dumps(response_data, indent=2)
        }
        
    except Exception as e:
        logger.error(f"Error processing protected API request: {str(e)}")
        return {
            'statusCode': 500,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'error': 'Internal server error',
                'message': 'An error occurred processing your request',
                'request_id': context.aws_request_id
            })
        }
            ''')
        )

    def _create_public_api_function(
        self, unique_suffix: str, runtime: _lambda.Runtime,
        architecture: _lambda.Architecture, timeout: Duration,
        execution_role: iam.Role
    ) -> _lambda.Function:
        """
        Create public API Lambda function that doesn't require authorization.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            runtime: Lambda runtime environment
            architecture: Lambda architecture (x86_64 or ARM64)
            timeout: Function timeout duration
            execution_role: IAM role for Lambda execution
            
        Returns:
            Lambda Function for public API endpoints
        """
        return _lambda.Function(
            self, "PublicApiFunction",
            function_name=f"public-api-{unique_suffix}",
            runtime=runtime,
            architecture=architecture,
            handler="index.lambda_handler",
            timeout=timeout,
            role=execution_role,
            description="Public API function accessible without authorization",
            environment={
                "LOG_LEVEL": "INFO",
                "API_VERSION": "1.0"
            },
            code=_lambda.Code.from_inline('''
import json
import logging
import os
import time
from datetime import datetime

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

def lambda_handler(event, context):
    """
    Public API endpoint accessible without authorization.
    
    This function demonstrates a public endpoint that provides
    general information about the API without requiring authentication.
    It's useful for health checks, API documentation, and public data.
    
    Args:
        event: API Gateway proxy event
        context: Lambda context object
        
    Returns:
        HTTP response with public API information
    """
    logger.info(f"Public API invoked: {json.dumps(event, default=str)}")
    
    try:
        # Extract request information
        http_method = event.get('httpMethod', 'GET')
        path = event.get('path', '/')
        query_params = event.get('queryStringParameters') or {}
        headers = event.get('headers', {})
        source_ip = event.get('requestContext', {}).get('identity', {}).get('sourceIp', 'unknown')
        user_agent = event.get('requestContext', {}).get('identity', {}).get('userAgent', 'unknown')
        
        logger.info(f"Request: {http_method} {path} from {source_ip}")
        
        # Build response data
        response_data = {
            'message': 'Welcome to the Serverless API Patterns Demo',
            'status': 'operational',
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'request_id': context.aws_request_id,
            'api_info': {
                'name': 'Serverless API Patterns with Lambda Authorizers',
                'version': os.environ.get('API_VERSION', '1.0'),
                'description': 'Demonstration of TOKEN and REQUEST authorizer patterns',
                'environment': 'production',
                'region': os.environ.get('AWS_REGION', 'unknown')
            },
            'endpoints': {
                'public': {
                    '/public': {
                        'description': 'Public endpoint (no authentication required)',
                        'methods': ['GET'],
                        'auth_required': False
                    }
                },
                'protected': {
                    '/protected': {
                        'description': 'Protected endpoint requiring Bearer token',
                        'methods': ['GET'],
                        'auth_required': True,
                        'auth_type': 'TOKEN',
                        'example_token': 'Bearer user-token or Bearer admin-token'
                    },
                    '/protected/admin': {
                        'description': 'Admin endpoint requiring request-based authorization',
                        'methods': ['GET'],
                        'auth_required': True,
                        'auth_type': 'REQUEST',
                        'auth_options': [
                            'API Key: ?api_key=secret-api-key-123',
                            'Custom Header: X-Custom-Auth: custom-auth-value',
                            'IP Whitelist: Internal network access',
                            'Organization: X-Organization-Id + X-Organization-Token',
                            'Device: X-Device-Id + X-Device-Secret'
                        ]
                    }
                }
            },
            'authentication_examples': {
                'token_auth': {
                    'description': 'Bearer token in Authorization header',
                    'example': 'Authorization: Bearer user-token',
                    'valid_tokens': [
                        'user-token (read permissions)',
                        'admin-token (full permissions)',
                        'manager-token (read/write permissions)'
                    ]
                },
                'request_auth': {
                    'description': 'Multiple authentication methods supported',
                    'examples': [
                        {
                            'method': 'API Key',
                            'example': 'GET /protected/admin?api_key=secret-api-key-123'
                        },
                        {
                            'method': 'Custom Header',
                            'example': 'X-Custom-Auth: custom-auth-value'
                        },
                        {
                            'method': 'Organization',
                            'example': 'X-Organization-Id: example-org-123\\nX-Organization-Token: org-secret-token'
                        },
                        {
                            'method': 'Device',
                            'example': 'X-Device-Id: device-123\\nX-Device-Secret: device-secret-123'
                        }
                    ]
                }
            },
            'features': [
                'TOKEN-based authorization with Bearer tokens',
                'REQUEST-based authorization with multiple auth methods',
                'Role-based access control (admin, manager, user)',
                'Authorization result caching (5 minutes TTL)',
                'Comprehensive request context analysis',
                'CloudWatch logging and monitoring',
                'CORS support for web applications'
            ],
            'security_patterns': {
                'token_authorizer': {
                    'use_cases': [
                        'JWT token validation',
                        'OAuth/OIDC integration',
                        'Simple bearer token schemes'
                    ],
                    'benefits': [
                        'Lightweight and fast',
                        'Efficient caching',
                        'Standard token formats'
                    ]
                },
                'request_authorizer': {
                    'use_cases': [
                        'IP address whitelisting',
                        'Custom authentication schemes',
                        'Multi-factor authentication',
                        'Request context validation'
                    ],
                    'benefits': [
                        'Maximum flexibility',
                        'Access to full request context',
                        'Complex business logic support'
                    ]
                }
            },
            'request_info': {
                'method': http_method,
                'path': path,
                'source_ip': source_ip,
                'user_agent': user_agent[:100] + '...' if len(user_agent) > 100 else user_agent,
                'query_parameters': list(query_params.keys()),
                'headers_received': len(headers)
            }
        }
        
        # Add query parameter information if provided
        if query_params:
            response_data['query_parameters_detail'] = {
                k: v for k, v in query_params.items() 
                if k.lower() not in ['password', 'secret', 'token', 'key']
            }
        
        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
                'X-Request-ID': context.aws_request_id,
                'X-API-Version': os.environ.get('API_VERSION', '1.0'),
                'Cache-Control': 'public, max-age=300'  # 5 minutes cache for public data
            },
            'body': json.dumps(response_data, indent=2)
        }
        
    except Exception as e:
        logger.error(f"Error processing public API request: {str(e)}")
        return {
            'statusCode': 500,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'error': 'Internal server error',
                'message': 'An error occurred processing your request',
                'request_id': context.aws_request_id
            })
        }
            ''')
        )

    def _create_api_gateway(
        self, unique_suffix: str, token_authorizer: _lambda.Function,
        request_authorizer: _lambda.Function, protected_function: _lambda.Function,
        public_function: _lambda.Function
    ) -> apigateway.RestApi:
        """
        Create API Gateway REST API with custom authorizers and resource structure.
        
        Args:
            unique_suffix: Unique identifier for resource naming
            token_authorizer: Lambda function for token-based authorization
            request_authorizer: Lambda function for request-based authorization
            protected_function: Lambda function for protected endpoints
            public_function: Lambda function for public endpoints
            
        Returns:
            API Gateway REST API instance
        """
        # Create REST API
        api = apigateway.RestApi(
            self, "ServerlessApiPatternsApi",
            rest_api_name=f"secure-api-{unique_suffix}",
            description="Serverless API with Lambda authorizers demonstration",
            default_cors_preflight_options=apigateway.CorsOptions(
                allow_origins=apigateway.Cors.ALL_ORIGINS,
                allow_methods=apigateway.Cors.ALL_METHODS,
                allow_headers=[
                    'Content-Type',
                    'X-Amz-Date',
                    'Authorization',
                    'X-Api-Key',
                    'X-Amz-Security-Token',
                    'X-Custom-Auth',
                    'X-Organization-Id',
                    'X-Organization-Token',
                    'X-Device-Id',
                    'X-Device-Secret'
                ]
            ),
            deploy=True,
            deployment_options=apigateway.StageOptions(
                stage_name="prod",
                description="Production stage with authorizers",
                cache_cluster_enabled=False,
                caching_enabled=False,
                data_trace_enabled=True,
                logging_level=apigateway.MethodLoggingLevel.INFO,
                metrics_enabled=True,
                throttling_rate_limit=1000,
                throttling_burst_limit=2000
            )
        )

        # Create Lambda integrations
        public_integration = apigateway.LambdaIntegration(
            public_function,
            proxy=True,
            allow_test_invoke=True
        )
        
        protected_integration = apigateway.LambdaIntegration(
            protected_function,
            proxy=True,
            allow_test_invoke=True
        )

        # Create TOKEN authorizer
        token_auth = apigateway.TokenAuthorizer(
            self, "TokenAuthorizer",
            handler=token_authorizer,
            identity_source="method.request.header.Authorization",
            results_cache_ttl=Duration.minutes(5),
            authorizer_name="TokenAuthorizer"
        )

        # Create REQUEST authorizer
        request_auth = apigateway.RequestAuthorizer(
            self, "RequestAuthorizer", 
            handler=request_authorizer,
            identity_sources=[
                "method.request.header.X-Custom-Auth",
                "method.request.querystring.api_key",
                "method.request.header.X-Organization-Id",
                "method.request.header.X-Device-Id"
            ],
            results_cache_ttl=Duration.minutes(5),
            authorizer_name="RequestAuthorizer"
        )

        # Create resource hierarchy
        # /public resource (no authorization)
        public_resource = api.root.add_resource("public")
        public_resource.add_method(
            "GET",
            public_integration,
            authorization_type=apigateway.AuthorizationType.NONE
        )

        # /protected resource (token authorization)
        protected_resource = api.root.add_resource("protected")
        protected_resource.add_method(
            "GET",
            protected_integration,
            authorization_type=apigateway.AuthorizationType.CUSTOM,
            authorizer=token_auth
        )

        # /protected/admin resource (request authorization)
        admin_resource = protected_resource.add_resource("admin")
        admin_resource.add_method(
            "GET",
            protected_integration,
            authorization_type=apigateway.AuthorizationType.CUSTOM,
            authorizer=request_auth
        )

        return api

    def _create_log_groups(
        self, token_authorizer: _lambda.Function, request_authorizer: _lambda.Function,
        protected_function: _lambda.Function, public_function: _lambda.Function
    ) -> None:
        """
        Create CloudWatch log groups for Lambda functions with proper retention.
        
        Args:
            token_authorizer: Token-based authorizer function
            request_authorizer: Request-based authorizer function  
            protected_function: Protected API function
            public_function: Public API function
        """
        functions = [
            ("TokenAuthorizerLogGroup", token_authorizer),
            ("RequestAuthorizerLogGroup", request_authorizer),
            ("ProtectedApiLogGroup", protected_function),
            ("PublicApiLogGroup", public_function)
        ]

        for log_group_id, function in functions:
            logs.LogGroup(
                self, log_group_id,
                log_group_name=f"/aws/lambda/{function.function_name}",
                retention=logs.RetentionDays.TWO_WEEKS,
                removal_policy=cdk.RemovalPolicy.DESTROY
            )

    def _create_outputs(
        self, api: apigateway.RestApi, token_authorizer: _lambda.Function,
        request_authorizer: _lambda.Function
    ) -> None:
        """
        Create CloudFormation outputs for important resource information.
        
        Args:
            api: API Gateway REST API
            token_authorizer: Token-based authorizer function
            request_authorizer: Request-based authorizer function
        """
        CfnOutput(
            self, "ApiGatewayUrl",
            value=api.url,
            description="API Gateway endpoint URL",
            export_name=f"{self.stack_name}-ApiUrl"
        )

        CfnOutput(
            self, "ApiGatewayId", 
            value=api.rest_api_id,
            description="API Gateway REST API ID",
            export_name=f"{self.stack_name}-ApiId"
        )

        CfnOutput(
            self, "TokenAuthorizerArn",
            value=token_authorizer.function_arn,
            description="Token authorizer Lambda function ARN",
            export_name=f"{self.stack_name}-TokenAuthArn"
        )

        CfnOutput(
            self, "RequestAuthorizerArn",
            value=request_authorizer.function_arn,
            description="Request authorizer Lambda function ARN",
            export_name=f"{self.stack_name}-RequestAuthArn"
        )

        CfnOutput(
            self, "PublicEndpoint",
            value=f"{api.url}public",
            description="Public API endpoint (no auth required)"
        )

        CfnOutput(
            self, "ProtectedEndpoint",
            value=f"{api.url}protected",
            description="Protected API endpoint (token auth required)"
        )

        CfnOutput(
            self, "AdminEndpoint",
            value=f"{api.url}protected/admin",
            description="Admin API endpoint (request auth required)"
        )

        CfnOutput(
            self, "TestCommands",
            value=f'''
# Test public endpoint
curl {api.url}public

# Test protected endpoint with user token
curl -H "Authorization: Bearer user-token" {api.url}protected

# Test admin endpoint with API key  
curl "{api.url}protected/admin?api_key=secret-api-key-123"

# Test admin endpoint with custom header
curl -H "X-Custom-Auth: custom-auth-value" {api.url}protected/admin
            ''',
            description="Example curl commands for testing the API"
        )


class ServerlessApiPatternsApp(cdk.App):
    """
    CDK Application for Serverless API Patterns with Lambda Authorizers.
    
    This application demonstrates comprehensive serverless API security patterns
    using AWS API Gateway with custom Lambda authorizers.
    """

    def __init__(self):
        super().__init__()

        # Create the main stack
        ServerlessApiPatternsStack(
            self, "ServerlessApiPatternsStack",
            description="Serverless API Patterns with Lambda Authorizers and API Gateway",
            tags={
                "Project": "ServerlessApiPatterns", 
                "Environment": "Demo",
                "Purpose": "Lambda Authorizer Demonstration",
                "ManagedBy": "CDK"
            }
        )


# Create and run the CDK application
app = ServerlessApiPatternsApp()
app.synth()