#!/usr/bin/env python3
"""
AWS CDK Python application for Infrastructure Automation with AWS Proton and CDK

This application creates standardized infrastructure templates that can be used
with AWS Proton for self-service infrastructure provisioning. It includes both
environment templates (shared infrastructure) and service templates (application-specific).

Architecture Components:
- Environment Template: VPC, ECS Cluster, and shared networking
- Service Template: Fargate services with Application Load Balancer
- IAM roles and policies for Proton service management
- S3 bucket for template storage

Author: Generated by CDK Python Recipe Generator
Version: 1.0
"""

import os
from typing import Dict, Any, Optional

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Environment,
    CfnOutput,
    RemovalPolicy,
    Duration,
    Tags
)
from aws_cdk import aws_ec2 as ec2
from aws_cdk import aws_ecs as ecs
from aws_cdk import aws_ecs_patterns as ecs_patterns
from aws_cdk import aws_iam as iam
from aws_cdk import aws_s3 as s3
from aws_cdk import aws_logs as logs
from aws_cdk import aws_elasticloadbalancingv2 as elbv2
from aws_cdk import aws_applicationautoscaling as autoscaling

from constructs import Construct


class ProtonSetupStack(Stack):
    """
    Stack that creates the foundational resources for AWS Proton.
    
    This includes:
    - IAM service role for Proton
    - S3 bucket for storing template bundles
    """
    
    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)
        
        project_name = kwargs.get('project_name', 'proton-automation')
        
        # Create IAM service role for AWS Proton
        self.service_role = iam.Role(
            self, "ProtonServiceRole",
            role_name=f"ProtonServiceRole-{project_name}",
            assumed_by=iam.ServicePrincipal("proton.amazonaws.com"),
            description="Service role for AWS Proton to manage infrastructure",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name("service-role/AWSProtonServiceRole")
            ]
        )
        
        # Create S3 bucket for storing Proton template bundles
        self.template_bucket = s3.Bucket(
            self, "ProtonTemplateBucket",
            bucket_name=f"proton-templates-{project_name}-{self.account}",
            encryption=s3.BucketEncryption.S3_MANAGED,
            block_public_access=s3.BlockPublicAccess.BLOCK_ALL,
            versioned=True,
            removal_policy=kwargs.get('removal_policy', RemovalPolicy.RETAIN),
            lifecycle_rules=[
                s3.LifecycleRule(
                    id="DeleteOldVersions",
                    enabled=True,
                    noncurrent_version_expiration=Duration.days(30)
                )
            ]
        )
        
        # Grant Proton service role access to the bucket
        self.template_bucket.grant_read(self.service_role)
        
        # Add tags
        Tags.of(self).add("Component", "ProtonSetup")


class ProtonEnvironmentTemplateStack(Stack):
    """
    Stack that creates the environment template infrastructure.
    
    This represents shared infrastructure that multiple services can use:
    - VPC with public and private subnets
    - ECS Cluster
    - Application Load Balancer
    - CloudWatch Log Group
    """
    
    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)
        
        project_name = kwargs.get('project_name', 'proton-automation')
        vpc_cidr = kwargs.get('vpc_cidr', '10.0.0.0/16')
        max_azs = kwargs.get('max_azs', 2)
        enable_nat_gateway = kwargs.get('enable_nat_gateway', True)
        
        # Create VPC with public and private subnets
        self.vpc = ec2.Vpc(
            self, "ProtonVPC",
            ip_addresses=ec2.IpAddresses.cidr(vpc_cidr),
            max_azs=max_azs,
            enable_dns_hostnames=kwargs.get('enable_dns_hostnames', True),
            enable_dns_support=kwargs.get('enable_dns_support', True),
            nat_gateways=1 if enable_nat_gateway else 0,
            subnet_configuration=[
                ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.PUBLIC,
                    name="PublicSubnet",
                    cidr_mask=24
                ),
                ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS if enable_nat_gateway else ec2.SubnetType.PRIVATE_ISOLATED,
                    name="PrivateSubnet",
                    cidr_mask=24
                )
            ]
        )
        
        # Create ECS Cluster
        self.cluster = ecs.Cluster(
            self, "ProtonECSCluster",
            cluster_name=f"{project_name}-cluster",
            vpc=self.vpc,
            enable_fargate_capacity_providers=True,
            capacity_providers=kwargs.get('cluster_capacity_providers', ['FARGATE', 'FARGATE_SPOT'])
        )
        
        # Create CloudWatch Log Group for environment
        self.log_group = logs.LogGroup(
            self, "EnvironmentLogGroup",
            log_group_name=f"/aws/ecs/{project_name}-environment",
            retention=logs.RetentionDays.ONE_WEEK,
            removal_policy=kwargs.get('removal_policy', RemovalPolicy.RETAIN)
        )
        
        # Create security group for ALB
        self.alb_security_group = ec2.SecurityGroup(
            self, "ALBSecurityGroup",
            vpc=self.vpc,
            description="Security group for Application Load Balancer",
            allow_all_outbound=True
        )
        
        # Allow HTTP traffic from internet
        self.alb_security_group.add_ingress_rule(
            peer=ec2.Peer.any_ipv4(),
            connection=ec2.Port.tcp(80),
            description="Allow HTTP traffic from internet"
        )
        
        # Allow HTTPS traffic from internet
        self.alb_security_group.add_ingress_rule(
            peer=ec2.Peer.any_ipv4(),
            connection=ec2.Port.tcp(443),
            description="Allow HTTPS traffic from internet"
        )
        
        # Create security group for ECS services
        self.ecs_security_group = ec2.SecurityGroup(
            self, "ECSSecurityGroup",
            vpc=self.vpc,
            description="Security group for ECS services",
            allow_all_outbound=True
        )
        
        # Allow traffic from ALB to ECS services
        self.ecs_security_group.add_ingress_rule(
            peer=self.alb_security_group,
            connection=ec2.Port.all_traffic(),
            description="Allow traffic from ALB"
        )
        
        # Add tags
        Tags.of(self).add("Component", "EnvironmentTemplate")


class ProtonServiceTemplateStack(Stack):
    """
    Stack that creates the service template for Fargate web services.
    
    This template can be used to deploy individual application services:
    - Fargate service with Application Load Balancer
    - Auto-scaling configuration
    - CloudWatch logging
    - Health checks
    """
    
    def __init__(self, scope: Construct, construct_id: str, vpc: Optional[ec2.Vpc] = None, 
                 cluster: Optional[ecs.Cluster] = None, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)
        
        project_name = kwargs.get('project_name', 'proton-automation')
        
        # If VPC and cluster not provided, create minimal ones for template
        if not vpc:
            vpc = ec2.Vpc(
                self, "ServiceVPC",
                ip_addresses=ec2.IpAddresses.cidr("10.1.0.0/16"),
                max_azs=2
            )
        
        if not cluster:
            cluster = ecs.Cluster(
                self, "ServiceCluster",
                vpc=vpc
            )
        
        # Create task definition
        task_definition = ecs.FargateTaskDefinition(
            self, "ServiceTaskDefinition",
            memory_limit_mib=512,
            cpu=256,
            family=f"{project_name}-service"
        )
        
        # Create CloudWatch log group for service
        service_log_group = logs.LogGroup(
            self, "ServiceLogGroup",
            log_group_name=f"/aws/ecs/{project_name}-service",
            retention=logs.RetentionDays.ONE_WEEK,
            removal_policy=kwargs.get('removal_policy', RemovalPolicy.RETAIN)
        )
        
        # Add container to task definition
        container = task_definition.add_container(
            "ServiceContainer",
            image=ecs.ContainerImage.from_registry("nginx:latest"),
            port_mappings=[
                ecs.PortMapping(
                    container_port=80,
                    protocol=ecs.Protocol.TCP
                )
            ],
            logging=ecs.LogDrivers.aws_logs(
                stream_prefix="service",
                log_group=service_log_group
            ),
            environment={
                "NODE_ENV": "production",
                "SERVICE_NAME": f"{project_name}-service"
            }
        )
        
        # Create Fargate service with Application Load Balancer
        self.fargate_service = ecs_patterns.ApplicationLoadBalancedFargateService(
            self, "ProtonFargateService",
            cluster=cluster,
            service_name=f"{project_name}-service",
            task_definition=task_definition,
            desired_count=1,
            public_load_balancer=True,
            listener_port=80,
            health_check_grace_period=Duration.seconds(60)
        )
        
        # Configure health check
        self.fargate_service.target_group.configure_health_check(
            path="/",
            healthy_http_codes="200,404",
            interval=Duration.seconds(30),
            timeout=Duration.seconds(5),
            healthy_threshold_count=2,
            unhealthy_threshold_count=3
        )
        
        # Configure auto scaling
        scaling_target = self.fargate_service.service.auto_scale_task_count(
            min_capacity=1,
            max_capacity=5
        )
        
        # Add CPU-based scaling
        scaling_target.scale_on_cpu_utilization(
            "CpuScaling",
            target_utilization_percent=70,
            scale_in_cooldown=Duration.seconds(300),
            scale_out_cooldown=Duration.seconds(300)
        )
        
        # Add memory-based scaling
        scaling_target.scale_on_memory_utilization(
            "MemoryScaling",
            target_utilization_percent=80,
            scale_in_cooldown=Duration.seconds(300),
            scale_out_cooldown=Duration.seconds(300)
        )
        
        # Add tags
        Tags.of(self).add("Component", "ServiceTemplate")


class InfrastructureAutomationApp(cdk.App):
    """
    Main CDK application for AWS Proton infrastructure automation.
    
    This app creates three main stacks:
    1. ProtonSetupStack - IAM roles and S3 bucket for Proton
    2. ProtonEnvironmentTemplateStack - Shared infrastructure template
    3. ProtonServiceTemplateStack - Application service template
    """
    
    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)
        
        # Get configuration from environment variables or use defaults
        config = self._get_configuration()
        
        # Define the environment for all stacks
        env = Environment(
            account=config.get('account_id', os.environ.get('CDK_DEFAULT_ACCOUNT')),
            region=config.get('region', os.environ.get('CDK_DEFAULT_REGION', 'us-east-1'))
        )
        
        # Create Proton setup stack with IAM roles and S3 bucket
        proton_setup = ProtonSetupStack(
            self, 
            "ProtonSetupStack",
            env=env,
            description="AWS Proton setup with IAM roles and S3 bucket for templates",
            **config
        )
        
        # Create environment template stack for shared infrastructure
        environment_template = ProtonEnvironmentTemplateStack(
            self,
            "ProtonEnvironmentTemplateStack", 
            env=env,
            description="Proton environment template with VPC and ECS cluster",
            **config
        )
        
        # Create service template stack for application services
        service_template = ProtonServiceTemplateStack(
            self,
            "ProtonServiceTemplateStack",
            env=env,
            description="Proton service template for Fargate web services",
            vpc=environment_template.vpc,
            cluster=environment_template.cluster,
            **config
        )
        
        # Add dependencies
        environment_template.add_dependency(proton_setup)
        service_template.add_dependency(environment_template)
        
        # Add common tags to all stacks
        Tags.of(self).add("Project", "InfrastructureAutomation")
        Tags.of(self).add("ManagedBy", "CDK")
        Tags.of(self).add("Purpose", "ProtonTemplates")
        
        # Add outputs for important resources
        CfnOutput(
            proton_setup,
            "ProtonServiceRoleArn",
            value=proton_setup.service_role.role_arn,
            description="ARN of the IAM role for AWS Proton service",
            export_name="ProtonServiceRoleArn"
        )
        
        CfnOutput(
            proton_setup,
            "TemplateBucketName", 
            value=proton_setup.template_bucket.bucket_name,
            description="Name of S3 bucket storing Proton templates",
            export_name="ProtonTemplateBucketName"
        )
        
        CfnOutput(
            environment_template,
            "VpcId",
            value=environment_template.vpc.vpc_id,
            description="ID of the VPC created by environment template",
            export_name="ProtonEnvironmentVpcId"
        )
        
        CfnOutput(
            environment_template,
            "ClusterName",
            value=environment_template.cluster.cluster_name,
            description="Name of the ECS cluster created by environment template", 
            export_name="ProtonEnvironmentClusterName"
        )
        
        CfnOutput(
            service_template,
            "LoadBalancerDNS",
            value=service_template.fargate_service.load_balancer.load_balancer_dns_name,
            description="DNS name of the Application Load Balancer",
            export_name="ServiceLoadBalancerDNS"
        )
        
        CfnOutput(
            service_template,
            "ServiceArn",
            value=service_template.fargate_service.service.service_arn,
            description="ARN of the ECS Fargate service",
            export_name="ServiceArn"
        )
    
    def _get_configuration(self) -> Dict[str, Any]:
        """
        Get configuration from environment variables with sensible defaults.
        
        Returns:
            Dict containing configuration parameters for the application.
        """
        return {
            'project_name': os.environ.get('PROJECT_NAME', 'proton-automation'),
            'environment_name': os.environ.get('ENVIRONMENT_NAME', 'development'),
            'vpc_cidr': os.environ.get('VPC_CIDR', '10.0.0.0/16'),
            'max_azs': int(os.environ.get('MAX_AZS', '2')),
            'enable_nat_gateway': os.environ.get('ENABLE_NAT_GATEWAY', 'true').lower() == 'true',
            'enable_dns_hostnames': True,
            'enable_dns_support': True,
            'cluster_capacity_providers': ['FARGATE', 'FARGATE_SPOT'],
            'log_retention_days': int(os.environ.get('LOG_RETENTION_DAYS', '7')),
            'removal_policy': RemovalPolicy.DESTROY if os.environ.get('REMOVAL_POLICY') == 'destroy' else RemovalPolicy.RETAIN
        }


def main() -> None:
    """
    Main entry point for the CDK application.
    
    This function creates and synthesizes the CDK application, making it ready
    for deployment via 'cdk deploy' command.
    """
    app = InfrastructureAutomationApp()
    app.synth()


if __name__ == "__main__":
    main()