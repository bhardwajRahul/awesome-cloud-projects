"""
AWS Config Rule Remediation Lambda Function

This Lambda function provides automated remediation for AWS Config rule violations.
It processes Config rule compliance change events and applies appropriate remediation actions.

Supported remediation actions:
- S3 bucket public access remediation
- Additional remediation actions can be added as needed

Author: Generated by Terraform recipe for infrastructure monitoring
Version: 1.0
"""

import json
import boto3
import logging
from botocore.exceptions import ClientError
from typing import Dict, Any, Optional

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS service clients
config_client = boto3.client('config')
s3_client = boto3.client('s3')
ssm_client = boto3.client('ssm')

def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Main Lambda handler function for processing Config compliance events.
    
    Args:
        event: EventBridge event containing Config rule compliance change
        context: Lambda context object
        
    Returns:
        Dict containing response status and details
    """
    logger.info(f"Received event: {json.dumps(event, default=str)}")
    
    try:
        # Extract event details
        detail = event.get('detail', {})
        config_rule_name = detail.get('configRuleName', '')
        
        # Get the evaluation result
        new_evaluation_result = detail.get('newEvaluationResult', {})
        compliance_type = new_evaluation_result.get('complianceType', '')
        
        # Get resource information
        evaluation_result_identifier = new_evaluation_result.get('evaluationResultIdentifier', {})
        evaluation_qualifier = evaluation_result_identifier.get('evaluationResultQualifier', {})
        resource_id = evaluation_qualifier.get('resourceId', '')
        resource_type = evaluation_qualifier.get('resourceType', '')
        
        logger.info(f"Processing rule: {config_rule_name}, Resource: {resource_id}, "
                   f"Type: {resource_type}, Compliance: {compliance_type}")
        
        # Only process non-compliant resources
        if compliance_type != 'NON_COMPLIANT':
            logger.info(f"Resource {resource_id} is compliant, no remediation needed")
            return create_response(200, "No remediation needed for compliant resource")
        
        # Route to appropriate remediation function
        remediation_result = route_remediation(config_rule_name, resource_id, resource_type)
        
        # Create OpsItem for tracking
        create_ops_item(config_rule_name, resource_id, resource_type, remediation_result)
        
        return create_response(200, f"Remediation processed for {resource_id}: {remediation_result}")
        
    except Exception as e:
        logger.error(f"Error processing event: {str(e)}")
        return create_response(500, f"Error processing remediation: {str(e)}")

def route_remediation(rule_name: str, resource_id: str, resource_type: str) -> str:
    """
    Route remediation request to appropriate handler based on Config rule.
    
    Args:
        rule_name: Name of the Config rule
        resource_id: ID of the non-compliant resource
        resource_type: Type of the resource
        
    Returns:
        String describing the remediation result
    """
    remediation_handlers = {
        's3-bucket-public-access-prohibited': remediate_s3_public_access,
        'encrypted-volumes': remediate_unencrypted_volume,
        'root-access-key-check': remediate_root_access_key,
        'iam-password-policy': remediate_iam_password_policy
    }
    
    handler = remediation_handlers.get(rule_name)
    if handler:
        return handler(resource_id, resource_type)
    else:
        logger.warning(f"No remediation handler found for rule: {rule_name}")
        return f"No automated remediation available for rule: {rule_name}"

def remediate_s3_public_access(resource_id: str, resource_type: str) -> str:
    """
    Remediate S3 bucket public access by enabling public access block.
    
    Args:
        resource_id: S3 bucket name
        resource_type: Resource type (should be AWS::S3::Bucket)
        
    Returns:
        String describing the remediation result
    """
    try:
        # Apply public access block configuration
        s3_client.put_public_access_block(
            Bucket=resource_id,
            PublicAccessBlockConfiguration={
                'BlockPublicAcls': True,
                'IgnorePublicAcls': True,
                'BlockPublicPolicy': True,
                'RestrictPublicBuckets': True
            }
        )
        
        logger.info(f"Successfully applied public access block to S3 bucket: {resource_id}")
        return f"Applied public access block to S3 bucket {resource_id}"
        
    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code == 'NoSuchBucket':
            logger.warning(f"S3 bucket {resource_id} not found")
            return f"S3 bucket {resource_id} not found"
        else:
            logger.error(f"Failed to remediate S3 bucket {resource_id}: {str(e)}")
            return f"Failed to remediate S3 bucket {resource_id}: {error_code}"
    except Exception as e:
        logger.error(f"Unexpected error remediating S3 bucket {resource_id}: {str(e)}")
        return f"Unexpected error remediating S3 bucket {resource_id}"

def remediate_unencrypted_volume(resource_id: str, resource_type: str) -> str:
    """
    Remediate unencrypted EBS volume (Note: Cannot encrypt existing volumes).
    
    Args:
        resource_id: EBS volume ID
        resource_type: Resource type (should be AWS::EC2::Volume)
        
    Returns:
        String describing the remediation result
    """
    logger.warning(f"Cannot automatically encrypt existing EBS volume {resource_id}")
    return f"Manual intervention required: Cannot encrypt existing volume {resource_id}. " \
           f"Consider creating encrypted snapshot and replacing volume."

def remediate_root_access_key(resource_id: str, resource_type: str) -> str:
    """
    Remediate root access key usage (Note: Cannot automatically delete root keys).
    
    Args:
        resource_id: AWS account ID
        resource_type: Resource type
        
    Returns:
        String describing the remediation result
    """
    logger.warning(f"Root access key detected for account {resource_id}")
    return f"Manual intervention required: Root access keys detected for account {resource_id}. " \
           f"Please delete root access keys and use IAM users instead."

def remediate_iam_password_policy(resource_id: str, resource_type: str) -> str:
    """
    Remediate IAM password policy compliance (Note: Requires manual review).
    
    Args:
        resource_id: AWS account ID
        resource_type: Resource type
        
    Returns:
        String describing the remediation result
    """
    logger.warning(f"IAM password policy non-compliance detected for account {resource_id}")
    return f"Manual review required: IAM password policy for account {resource_id} " \
           f"does not meet compliance requirements."

def create_ops_item(rule_name: str, resource_id: str, resource_type: str, remediation_result: str) -> Optional[str]:
    """
    Create Systems Manager OpsItem for tracking remediation.
    
    Args:
        rule_name: Config rule name
        resource_id: Resource ID
        resource_type: Resource type
        remediation_result: Result of remediation attempt
        
    Returns:
        OpsItem ID if created successfully, None otherwise
    """
    try:
        response = ssm_client.create_ops_item(
            Title=f"Config Rule Remediation: {rule_name}",
            Description=f"Automated remediation for resource {resource_id} of type {resource_type}. "
                       f"Rule: {rule_name}. Result: {remediation_result}",
            Priority=2,
            Source="Lambda-AutoRemediation",
            OperationalData={
                "ConfigRule": {
                    "Value": rule_name,
                    "Type": "SearchableString"
                },
                "ResourceId": {
                    "Value": resource_id,
                    "Type": "SearchableString"
                },
                "ResourceType": {
                    "Value": resource_type,
                    "Type": "SearchableString"
                },
                "RemediationResult": {
                    "Value": remediation_result,
                    "Type": "String"
                }
            },
            Tags=[
                {
                    "Key": "ConfigRule",
                    "Value": rule_name
                },
                {
                    "Key": "AutomatedRemediation",
                    "Value": "true"
                }
            ]
        )
        
        ops_item_id = response.get('OpsItemId', '')
        logger.info(f"Created OpsItem {ops_item_id} for remediation tracking")
        return ops_item_id
        
    except Exception as e:
        logger.error(f"Failed to create OpsItem: {str(e)}")
        return None

def create_response(status_code: int, message: str) -> Dict[str, Any]:
    """
    Create standardized Lambda response.
    
    Args:
        status_code: HTTP status code
        message: Response message
        
    Returns:
        Dict containing response data
    """
    return {
        'statusCode': status_code,
        'body': json.dumps({
            'message': message,
            'timestamp': json.dumps(None, default=str)  # Will use current timestamp
        })
    }

def get_resource_details(resource_id: str, resource_type: str) -> Optional[Dict[str, Any]]:
    """
    Get additional resource details from Config if needed.
    
    Args:
        resource_id: Resource ID
        resource_type: Resource type
        
    Returns:
        Resource configuration details or None
    """
    try:
        response = config_client.get_resource_config_history(
            resourceType=resource_type,
            resourceId=resource_id,
            limit=1
        )
        
        config_items = response.get('configurationItems', [])
        if config_items:
            return config_items[0]
        else:
            logger.warning(f"No configuration history found for {resource_type} {resource_id}")
            return None
            
    except Exception as e:
        logger.error(f"Failed to get resource details for {resource_id}: {str(e)}")
        return None