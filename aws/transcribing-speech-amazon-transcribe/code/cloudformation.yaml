AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Amazon Transcribe Speech Recognition Application - Creates S3 bucket, IAM roles, Lambda function, and supporting resources for comprehensive speech-to-text processing'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "General Configuration"
        Parameters:
          - ProjectName
          - Environment
      - Label:
          default: "S3 Configuration"
        Parameters:
          - BucketName
          - EnableS3Versioning
          - EnableS3Encryption
      - Label:
          default: "Lambda Configuration"
        Parameters:
          - LambdaFunctionName
          - LambdaRuntime
          - LambdaTimeout
          - LambdaMemorySize
      - Label:
          default: "Transcribe Configuration"
        Parameters:
          - DefaultLanguageCode
          - EnableContentFiltering
          - EnablePIIRedaction
      - Label:
          default: "Monitoring Configuration"
        Parameters:
          - EnableCloudWatchLogs
          - LogRetentionInDays
    ParameterLabels:
      ProjectName:
        default: "Project Name"
      Environment:
        default: "Environment"
      BucketName:
        default: "S3 Bucket Name"
      EnableS3Versioning:
        default: "Enable S3 Versioning"
      EnableS3Encryption:
        default: "Enable S3 Encryption"
      LambdaFunctionName:
        default: "Lambda Function Name"
      LambdaRuntime:
        default: "Lambda Runtime"
      LambdaTimeout:
        default: "Lambda Timeout"
      LambdaMemorySize:
        default: "Lambda Memory Size"
      DefaultLanguageCode:
        default: "Default Language Code"
      EnableContentFiltering:
        default: "Enable Content Filtering"
      EnablePIIRedaction:
        default: "Enable PII Redaction"
      EnableCloudWatchLogs:
        default: "Enable CloudWatch Logs"
      LogRetentionInDays:
        default: "Log Retention (Days)"

Parameters:
  ProjectName:
    Type: String
    Default: 'transcribe-speech-recognition'
    Description: 'Name of the project - used for resource naming and tagging'
    MinLength: 3
    MaxLength: 50
    AllowedPattern: '^[a-zA-Z][a-zA-Z0-9-]*$'
    ConstraintDescription: 'Must begin with a letter and contain only alphanumeric characters and hyphens'

  Environment:
    Type: String
    Default: 'dev'
    AllowedValues: ['dev', 'staging', 'prod']
    Description: 'Environment name for resource tagging and naming'

  BucketName:
    Type: String
    Default: ''
    Description: 'Name for the S3 bucket (leave empty to auto-generate)'
    MaxLength: 63
    AllowedPattern: '^$|^[a-z0-9][a-z0-9-]*[a-z0-9]$'
    ConstraintDescription: 'Must be a valid S3 bucket name (lowercase, alphanumeric, hyphens)'

  EnableS3Versioning:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable S3 bucket versioning for audio files and transcription outputs'

  EnableS3Encryption:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable S3 bucket encryption using AES-256'

  LambdaFunctionName:
    Type: String
    Default: 'transcribe-processor'
    Description: 'Name for the Lambda function that processes transcription results'
    MinLength: 1
    MaxLength: 50
    AllowedPattern: '^[a-zA-Z][a-zA-Z0-9-_]*$'
    ConstraintDescription: 'Must begin with a letter and contain only alphanumeric characters, hyphens, and underscores'

  LambdaRuntime:
    Type: String
    Default: 'python3.11'
    AllowedValues: ['python3.9', 'python3.10', 'python3.11', 'python3.12']
    Description: 'Python runtime version for Lambda function'

  LambdaTimeout:
    Type: Number
    Default: 300
    MinValue: 30
    MaxValue: 900
    Description: 'Lambda function timeout in seconds (30-900)'

  LambdaMemorySize:
    Type: Number
    Default: 512
    MinValue: 128
    MaxValue: 10240
    Description: 'Lambda function memory allocation in MB'

  DefaultLanguageCode:
    Type: String
    Default: 'en-US'
    AllowedValues: ['en-US', 'en-GB', 'en-AU', 'en-CA', 'en-IN', 'es-US', 'es-ES', 'fr-FR', 'fr-CA', 'de-DE', 'it-IT', 'pt-BR', 'ja-JP', 'ko-KR', 'zh-CN', 'ar-SA', 'hi-IN', 'nl-NL', 'sv-SE', 'da-DK', 'no-NO', 'fi-FI', 'ru-RU', 'pl-PL', 'tr-TR', 'he-IL', 'th-TH']
    Description: 'Default language code for transcription jobs'

  EnableContentFiltering:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable content filtering for inappropriate language'

  EnablePIIRedaction:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable PII (Personally Identifiable Information) redaction'

  EnableCloudWatchLogs:
    Type: String
    Default: 'true'
    AllowedValues: ['true', 'false']
    Description: 'Enable CloudWatch Logs for Lambda function'

  LogRetentionInDays:
    Type: Number
    Default: 30
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653]
    Description: 'CloudWatch Logs retention period in days'

Conditions:
  CreateBucketName: !Equals [!Ref BucketName, '']
  EnableS3VersioningCondition: !Equals [!Ref EnableS3Versioning, 'true']
  EnableS3EncryptionCondition: !Equals [!Ref EnableS3Encryption, 'true']
  EnableContentFilteringCondition: !Equals [!Ref EnableContentFiltering, 'true']
  EnablePIIRedactionCondition: !Equals [!Ref EnablePIIRedaction, 'true']
  EnableCloudWatchLogsCondition: !Equals [!Ref EnableCloudWatchLogs, 'true']

Resources:
  # S3 Bucket for audio files and transcription outputs
  TranscribeS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If 
        - CreateBucketName
        - !Sub '${ProjectName}-${Environment}-${AWS::Region}-${AWS::AccountId}'
        - !Ref BucketName
      BucketEncryption: !If
        - EnableS3EncryptionCondition
        - ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256
        - !Ref 'AWS::NoValue'
      VersioningConfiguration: !If
        - EnableS3VersioningCondition
        - Status: Enabled
        - !Ref 'AWS::NoValue'
      LifecycleConfiguration:
        Rules:
          - Id: DeleteIncompleteMultipartUploads
            Status: Enabled
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
          - Id: TransitionToIA
            Status: Enabled
            Transitions:
              - StorageClass: STANDARD_IA
                TransitionInDays: 30
          - Id: TransitionToGlacier
            Status: Enabled
            Transitions:
              - StorageClass: GLACIER
                TransitionInDays: 90
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpiration:
              NoncurrentDays: 365
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:*
            Function: !GetAtt TranscribeProcessorFunction.Arn
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: 'transcription-output/'
                  - Name: suffix
                    Value: '.json'
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-transcribe-bucket'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Amazon Transcribe audio storage and output'

  # S3 Bucket Policy for secure access
  TranscribeS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TranscribeS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: DenyInsecureConnections
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource:
              - !Sub '${TranscribeS3Bucket}/*'
              - !Sub '${TranscribeS3Bucket}'
            Condition:
              Bool:
                'aws:SecureTransport': 'false'
          - Sid: AllowTranscribeServiceAccess
            Effect: Allow
            Principal:
              Service: transcribe.amazonaws.com
            Action:
              - 's3:GetObject'
              - 's3:PutObject'
              - 's3:DeleteObject'
            Resource: !Sub '${TranscribeS3Bucket}/*'
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref 'AWS::AccountId'

  # IAM Role for Amazon Transcribe Service
  TranscribeServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-transcribe-service-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: transcribe.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref 'AWS::AccountId'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonTranscribeServiceRole
      Policies:
        - PolicyName: TranscribeS3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub '${TranscribeS3Bucket}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !Sub '${TranscribeS3Bucket}'
              - Effect: Allow
                Action:
                  - s3:GetBucketLocation
                Resource: !Sub '${TranscribeS3Bucket}'
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-transcribe-service-role'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Amazon Transcribe service access to S3'

  # IAM Role for Lambda Function
  TranscribeLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-lambda-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: TranscribeJobAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - transcribe:GetTranscriptionJob
                  - transcribe:ListTranscriptionJobs
                  - transcribe:StartTranscriptionJob
                  - transcribe:DeleteTranscriptionJob
                Resource: '*'
              - Effect: Allow
                Action:
                  - transcribe:GetVocabulary
                  - transcribe:ListVocabularies
                  - transcribe:CreateVocabulary
                  - transcribe:DeleteVocabulary
                  - transcribe:UpdateVocabulary
                Resource: '*'
              - Effect: Allow
                Action:
                  - transcribe:GetVocabularyFilter
                  - transcribe:ListVocabularyFilters
                  - transcribe:CreateVocabularyFilter
                  - transcribe:DeleteVocabularyFilter
                  - transcribe:UpdateVocabularyFilter
                Resource: '*'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub '${TranscribeS3Bucket}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !Sub '${TranscribeS3Bucket}'
        - PolicyName: CloudWatchLogsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${LambdaFunctionName}-${Environment}:*'
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-lambda-execution-role'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Lambda function execution role for transcription processing'

  # CloudWatch Log Group for Lambda Function
  TranscribeLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: EnableCloudWatchLogsCondition
    Properties:
      LogGroupName: !Sub '/aws/lambda/${LambdaFunctionName}-${Environment}'
      RetentionInDays: !Ref LogRetentionInDays
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-lambda-logs'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Lambda function logs for transcription processing'

  # Lambda Function for processing transcription results
  TranscribeProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${LambdaFunctionName}-${Environment}'
      Runtime: !Ref LambdaRuntime
      Handler: index.lambda_handler
      Role: !GetAtt TranscribeLambdaRole.Arn
      Timeout: !Ref LambdaTimeout
      MemorySize: !Ref LambdaMemorySize
      ReservedConcurrencyLimit: 10
      Environment:
        Variables:
          BUCKET_NAME: !Ref TranscribeS3Bucket
          DEFAULT_LANGUAGE_CODE: !Ref DefaultLanguageCode
          ENABLE_CONTENT_FILTERING: !Ref EnableContentFiltering
          ENABLE_PII_REDACTION: !Ref EnablePIIRedaction
          PROJECT_NAME: !Ref ProjectName
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          import logging
          from urllib.parse import unquote_plus
          
          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          # Initialize AWS clients
          transcribe = boto3.client('transcribe')
          s3 = boto3.client('s3')
          
          def lambda_handler(event, context):
              """
              Process Amazon Transcribe results and S3 events
              """
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  # Handle S3 event (transcription job completion)
                  if 'Records' in event and event['Records']:
                      return handle_s3_event(event)
                  
                  # Handle direct invocation with job name
                  elif 'jobName' in event:
                      return handle_job_status_request(event)
                  
                  # Handle API Gateway event
                  elif 'httpMethod' in event:
                      return handle_api_request(event)
                  
                  else:
                      logger.error("Unsupported event type")
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Unsupported event type'})
                      }
                      
              except Exception as e:
                  logger.error(f"Error processing event: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Processing error: {str(e)}'})
                  }
          
          def handle_s3_event(event):
              """
              Handle S3 event when transcription output is created
              """
              responses = []
              
              for record in event['Records']:
                  bucket_name = record['s3']['bucket']['name']
                  object_key = unquote_plus(record['s3']['object']['key'])
                  
                  logger.info(f"Processing S3 object: {object_key}")
                  
                  # Check if this is a transcription output file
                  if object_key.startswith('transcription-output/') and object_key.endswith('.json'):
                      # Extract job name from the file path
                      job_name = extract_job_name_from_path(object_key)
                      
                      if job_name:
                          response = process_transcription_result(job_name, bucket_name, object_key)
                          responses.append(response)
              
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': 'S3 event processed successfully',
                      'processed_files': len(responses),
                      'results': responses
                  })
              }
          
          def handle_job_status_request(event):
              """
              Handle direct job status request
              """
              job_name = event.get('jobName')
              
              if not job_name:
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': 'Job name not provided'})
                  }
              
              try:
                  response = transcribe.get_transcription_job(
                      TranscriptionJobName=job_name
                  )
                  
                  job_status = response['TranscriptionJob']['TranscriptionJobStatus']
                  
                  if job_status == 'COMPLETED':
                      transcript_uri = response['TranscriptionJob']['Transcript']['TranscriptFileUri']
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Transcription completed',
                              'jobName': job_name,
                              'status': job_status,
                              'transcriptUri': transcript_uri,
                              'timestamp': datetime.utcnow().isoformat()
                          })
                      }
                  elif job_status == 'FAILED':
                      failure_reason = response['TranscriptionJob'].get('FailureReason', 'Unknown error')
                      
                      return {
                          'statusCode': 200,
                          'body': json.dumps({
                              'message': 'Transcription failed',
                              'jobName': job_name,
                              'status': job_status,
                              'failureReason': failure_reason,
                              'timestamp': datetime.utcnow().isoformat()
                          })
                      }
                  else:
                      return {
                          'statusCode': 202,
                          'body': json.dumps({
                              'message': 'Transcription in progress',
                              'jobName': job_name,
                              'status': job_status,
                              'timestamp': datetime.utcnow().isoformat()
                          })
                      }
                      
              except Exception as e:
                  logger.error(f"Error getting job status: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': f'Error getting job status: {str(e)}'})
                  }
          
          def handle_api_request(event):
              """
              Handle API Gateway request
              """
              method = event['httpMethod']
              path = event['path']
              
              if method == 'GET' and path == '/status':
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'message': 'Transcribe processor is running',
                          'timestamp': datetime.utcnow().isoformat(),
                          'environment': os.environ.get('ENVIRONMENT', 'unknown')
                      })
                  }
              
              return {
                  'statusCode': 404,
                  'body': json.dumps({'error': 'Not found'})
              }
          
          def extract_job_name_from_path(object_key):
              """
              Extract job name from S3 object key
              """
              try:
                  # Extract filename without extension
                  filename = object_key.split('/')[-1]
                  job_name = filename.replace('.json', '')
                  return job_name
              except:
                  return None
          
          def process_transcription_result(job_name, bucket_name, object_key):
              """
              Process completed transcription result
              """
              try:
                  # Get the transcription result from S3
                  response = s3.get_object(Bucket=bucket_name, Key=object_key)
                  content = response['Body'].read().decode('utf-8')
                  transcript_data = json.loads(content)
                  
                  # Extract key information
                  transcript_text = transcript_data.get('results', {}).get('transcripts', [{}])[0].get('transcript', '')
                  
                  logger.info(f"Processed transcription for job {job_name}: {len(transcript_text)} characters")
                  
                  # Here you could add additional processing:
                  # - Store in database
                  # - Send notifications
                  # - Trigger downstream workflows
                  # - Perform sentiment analysis
                  # - Extract keywords
                  
                  return {
                      'jobName': job_name,
                      'transcriptLength': len(transcript_text),
                      'processed': True,
                      'timestamp': datetime.utcnow().isoformat()
                  }
                  
              except Exception as e:
                  logger.error(f"Error processing transcription result: {str(e)}")
                  return {
                      'jobName': job_name,
                      'error': str(e),
                      'processed': False,
                      'timestamp': datetime.utcnow().isoformat()
                  }
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-transcribe-processor'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: Purpose
          Value: 'Process Amazon Transcribe results and events'

  # Lambda Permission for S3 to invoke function
  TranscribeLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TranscribeProcessorFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub '${TranscribeS3Bucket}'
      SourceAccount: !Ref 'AWS::AccountId'

  # CloudWatch Alarm for Lambda Function Errors
  TranscribeLambdaErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${Environment}-lambda-errors'
      AlarmDescription: 'Alarm for Lambda function errors in transcription processing'
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref TranscribeProcessorFunction
      TreatMissingData: notBreaching
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-lambda-error-alarm'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # CloudWatch Alarm for Lambda Function Duration
  TranscribeLambdaDurationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${Environment}-lambda-duration'
      AlarmDescription: 'Alarm for Lambda function duration in transcription processing'
      MetricName: Duration
      Namespace: AWS/Lambda
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: !Ref LambdaTimeout
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref TranscribeProcessorFunction
      TreatMissingData: notBreaching
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-lambda-duration-alarm'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName

  # Parameter Store entries for configuration
  TranscribeConfigParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub '/${ProjectName}/${Environment}/transcribe/config'
      Type: String
      Value: !Sub |
        {
          "bucketName": "${TranscribeS3Bucket}",
          "serviceRoleArn": "${TranscribeServiceRole.Arn}",
          "lambdaFunctionName": "${TranscribeProcessorFunction}",
          "defaultLanguageCode": "${DefaultLanguageCode}",
          "enableContentFiltering": "${EnableContentFiltering}",
          "enablePIIRedaction": "${EnablePIIRedaction}",
          "region": "${AWS::Region}"
        }
      Description: 'Configuration parameters for Amazon Transcribe speech recognition application'
      Tags:
        Name: !Sub '${ProjectName}-${Environment}-transcribe-config'
        Environment: !Ref Environment
        Project: !Ref ProjectName

Outputs:
  S3BucketName:
    Description: 'Name of the S3 bucket for audio files and transcription outputs'
    Value: !Ref TranscribeS3Bucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  S3BucketArn:
    Description: 'ARN of the S3 bucket for audio files and transcription outputs'
    Value: !GetAtt TranscribeS3Bucket.Arn
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketArn'

  TranscribeServiceRoleArn:
    Description: 'ARN of the IAM role for Amazon Transcribe service'
    Value: !GetAtt TranscribeServiceRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TranscribeServiceRoleArn'

  LambdaFunctionName:
    Description: 'Name of the Lambda function for processing transcription results'
    Value: !Ref TranscribeProcessorFunction
    Export:
      Name: !Sub '${AWS::StackName}-LambdaFunctionName'

  LambdaFunctionArn:
    Description: 'ARN of the Lambda function for processing transcription results'
    Value: !GetAtt TranscribeProcessorFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaFunctionArn'

  LambdaExecutionRoleArn:
    Description: 'ARN of the IAM role for Lambda function execution'
    Value: !GetAtt TranscribeLambdaRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaExecutionRoleArn'

  AudioInputPrefix:
    Description: 'S3 prefix for uploading audio files'
    Value: 'audio-input/'
    Export:
      Name: !Sub '${AWS::StackName}-AudioInputPrefix'

  TranscriptionOutputPrefix:
    Description: 'S3 prefix for transcription output files'
    Value: 'transcription-output/'
    Export:
      Name: !Sub '${AWS::StackName}-TranscriptionOutputPrefix'

  CustomVocabularyPrefix:
    Description: 'S3 prefix for custom vocabulary files'
    Value: 'custom-vocabulary/'
    Export:
      Name: !Sub '${AWS::StackName}-CustomVocabularyPrefix'

  TrainingDataPrefix:
    Description: 'S3 prefix for training data files'
    Value: 'training-data/'
    Export:
      Name: !Sub '${AWS::StackName}-TrainingDataPrefix'

  ConfigParameterName:
    Description: 'Name of the SSM parameter containing configuration values'
    Value: !Ref TranscribeConfigParameter
    Export:
      Name: !Sub '${AWS::StackName}-ConfigParameterName'

  SampleTranscriptionCommand:
    Description: 'Sample CLI command to start a transcription job'
    Value: !Sub |
      aws transcribe start-transcription-job \
        --transcription-job-name "sample-job-$(date +%s)" \
        --language-code ${DefaultLanguageCode} \
        --media-format mp3 \
        --media MediaFileUri=s3://${TranscribeS3Bucket}/audio-input/sample-audio.mp3 \
        --output-bucket-name ${TranscribeS3Bucket} \
        --output-key transcription-output/sample-job-$(date +%s).json

  DeploymentInstructions:
    Description: 'Instructions for using the deployed infrastructure'
    Value: !Sub |
      1. Upload audio files to s3://${TranscribeS3Bucket}/audio-input/
      2. Create custom vocabulary files in s3://${TranscribeS3Bucket}/custom-vocabulary/
      3. Use the Transcribe service role ARN: ${TranscribeServiceRole.Arn}
      4. Monitor transcription results via Lambda function: ${TranscribeProcessorFunction}
      5. Access configuration via SSM parameter: ${TranscribeConfigParameter}