#!/usr/bin/env python3
"""
CDK Application for Automated Security Incident Response with Security Hub

This CDK application deploys a comprehensive automated security incident response
system using AWS Security Hub, EventBridge, Lambda, and SNS. The solution provides
real-time classification, remediation, and notification of security findings.

Author: Generated by CDK
Version: 1.0.0
"""

import os
from typing import Dict, Any

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Duration,
    CfnOutput,
    RemovalPolicy,
    aws_iam as iam,
    aws_lambda as lambda_,
    aws_events as events,
    aws_events_targets as targets,
    aws_sns as sns,
    aws_sns_subscriptions as subscriptions,
    aws_securityhub as securityhub,
    aws_logs as logs,
)
from constructs import Construct


class SecurityIncidentResponseStack(Stack):
    """
    CDK Stack for Automated Security Incident Response System
    
    This stack creates:
    - Security Hub configuration with custom standards
    - Lambda functions for classification, remediation, and notifications
    - EventBridge rules for automated workflow triggers
    - SNS topic for incident notifications
    - IAM roles with least privilege permissions
    - Security Hub insights for incident tracking
    """

    def __init__(
        self, 
        scope: Construct, 
        construct_id: str, 
        notification_email: str = "security-team@company.com",
        **kwargs: Any
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Generate unique suffix for resource names
        unique_suffix = self.node.addr[:8].lower()
        
        # Store notification email
        self.notification_email = notification_email

        # Create IAM role for Lambda functions
        self.lambda_role = self._create_lambda_execution_role(unique_suffix)

        # Create SNS topic for notifications
        self.sns_topic = self._create_sns_topic(unique_suffix)

        # Create Lambda functions
        self.classification_function = self._create_classification_function(unique_suffix)
        self.remediation_function = self._create_remediation_function(unique_suffix)
        self.notification_function = self._create_notification_function(unique_suffix)

        # Create EventBridge rules
        self._create_eventbridge_rules(unique_suffix)

        # Create Security Hub custom actions
        self._create_security_hub_custom_actions(unique_suffix)

        # Create Security Hub insights
        self._create_security_hub_insights(unique_suffix)

        # Create outputs
        self._create_outputs()

    def _create_lambda_execution_role(self, suffix: str) -> iam.Role:
        """
        Create IAM role for Lambda functions with necessary permissions
        
        Args:
            suffix: Unique suffix for resource naming
            
        Returns:
            IAM role for Lambda execution
        """
        role = iam.Role(
            self,
            f"IncidentResponseRole-{suffix}",
            role_name=f"SecurityIncidentResponseRole-{suffix}",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            description="Role for automated security incident response Lambda functions",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ],
        )

        # Add Security Hub permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "securityhub:GetFindings",
                    "securityhub:BatchUpdateFindings",
                    "securityhub:BatchImportFindings",
                    "securityhub:CreateInsight",
                    "securityhub:GetInsights",
                    "securityhub:GetInsightResults",
                ],
                resources=["*"],
            )
        )

        # Add SNS permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=["sns:Publish"],
                resources=[self.sns_topic.topic_arn if hasattr(self, 'sns_topic') else f"arn:aws:sns:{self.region}:{self.account}:security-incidents-{suffix}"],
            )
        )

        # Add EC2 permissions for security group remediation
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "ec2:DescribeSecurityGroups",
                    "ec2:AuthorizeSecurityGroupIngress",
                    "ec2:RevokeSecurityGroupIngress",
                    "ec2:CreateTags",
                ],
                resources=["*"],
            )
        )

        # Add S3 permissions for bucket policy remediation
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "s3:PutBucketPolicy",
                    "s3:GetBucketPolicy",
                    "s3:PutBucketPublicAccessBlock",
                ],
                resources=["*"],
            )
        )

        # Add IAM permissions for policy remediation
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "iam:AttachRolePolicy",
                    "iam:DetachRolePolicy",
                    "iam:PutRolePolicy",
                    "iam:DeleteRolePolicy",
                    "iam:ListAttachedRolePolicies",
                    "iam:ListRolePolicies",
                ],
                resources=["*"],
            )
        )

        return role

    def _create_sns_topic(self, suffix: str) -> sns.Topic:
        """
        Create SNS topic for security incident notifications
        
        Args:
            suffix: Unique suffix for resource naming
            
        Returns:
            SNS topic for notifications
        """
        topic = sns.Topic(
            self,
            f"SecurityIncidentsTopic-{suffix}",
            topic_name=f"security-incidents-{suffix}",
            display_name="Security Incidents Notification Topic",
            description="SNS topic for automated security incident notifications",
        )

        # Add email subscription if provided
        if self.notification_email and self.notification_email != "security-team@company.com":
            topic.add_subscription(
                subscriptions.EmailSubscription(self.notification_email)
            )

        return topic

    def _create_classification_function(self, suffix: str) -> lambda_.Function:
        """
        Create Lambda function for security finding classification
        
        Args:
            suffix: Unique suffix for resource naming
            
        Returns:
            Lambda function for classification
        """
        function = lambda_.Function(
            self,
            f"ClassificationFunction-{suffix}",
            function_name=f"security-classification-{suffix}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            role=self.lambda_role,
            timeout=Duration.minutes(5),
            memory_size=256,
            description="Classifies security findings for automated response",
            environment={
                "SNS_TOPIC_ARN": self.sns_topic.topic_arn,
                "LOG_LEVEL": "INFO",
            },
            log_retention=logs.RetentionDays.ONE_MONTH,
            code=lambda_.Code.from_inline('''
import json
import boto3
import logging
import os
from datetime import datetime

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

# Initialize AWS clients
securityhub = boto3.client('securityhub')
sns = boto3.client('sns')

def lambda_handler(event, context):
    """
    Lambda handler for security finding classification
    
    Args:
        event: EventBridge event containing Security Hub finding
        context: Lambda context object
        
    Returns:
        Response with classification results
    """
    try:
        # Extract finding details from EventBridge event
        finding = event['detail']['findings'][0]
        
        finding_id = finding['Id']
        product_arn = finding['ProductArn']
        severity = finding['Severity']['Label']
        title = finding['Title']
        description = finding['Description']
        
        logger.info(f"Processing finding: {finding_id} with severity: {severity}")
        
        # Classify finding based on severity and type
        classification = classify_finding(finding)
        
        # Update finding with classification
        response = securityhub.batch_update_findings(
            FindingIdentifiers=[
                {
                    'Id': finding_id,
                    'ProductArn': product_arn
                }
            ],
            Note={
                'Text': f'Auto-classified as {classification["category"]} - {classification["action"]}',
                'UpdatedBy': 'SecurityIncidentResponse'
            },
            UserDefinedFields={
                'AutoClassification': classification['category'],
                'RecommendedAction': classification['action'],
                'ProcessedAt': datetime.utcnow().isoformat(),
                'EscalationRequired': str(classification.get('escalate', False))
            }
        )
        
        logger.info(f"Successfully classified finding {finding_id} as {classification['category']}")
        
        # Return classification for downstream processing
        return {
            'statusCode': 200,
            'body': json.dumps({
                'findingId': finding_id,
                'classification': classification,
                'updated': True
            })
        }
        
    except Exception as e:
        logger.error(f"Error processing finding: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def classify_finding(finding):
    """
    Classify finding based on severity, type, and content
    
    Args:
        finding: Security Hub finding object
        
    Returns:
        Classification dictionary with category, action, and escalation flag
    """
    severity = finding['Severity']['Label']
    finding_type = finding.get('Types', ['Unknown'])[0]
    title = finding['Title'].lower()
    
    # High-priority security incidents
    if severity == 'CRITICAL':
        if 'root' in title or 'admin' in title:
            return {
                'category': 'CRITICAL_ADMIN_ISSUE',
                'action': 'IMMEDIATE_REVIEW_REQUIRED',
                'escalate': True
            }
        elif 'malware' in title or 'backdoor' in title:
            return {
                'category': 'MALWARE_DETECTED',
                'action': 'QUARANTINE_RESOURCE',
                'escalate': True
            }
        else:
            return {
                'category': 'CRITICAL_SECURITY_ISSUE',
                'action': 'INVESTIGATE_IMMEDIATELY',
                'escalate': True
            }
    
    # Medium-priority issues
    elif severity == 'HIGH':
        if 'mfa' in title:
            return {
                'category': 'MFA_COMPLIANCE_ISSUE',
                'action': 'ENFORCE_MFA_POLICY',
                'escalate': False
            }
        elif 'encryption' in title:
            return {
                'category': 'ENCRYPTION_COMPLIANCE',
                'action': 'ENABLE_ENCRYPTION',
                'escalate': False
            }
        else:
            return {
                'category': 'HIGH_SECURITY_ISSUE',
                'action': 'SCHEDULE_REMEDIATION',
                'escalate': False
            }
    
    # Lower priority issues
    else:
        return {
            'category': 'STANDARD_COMPLIANCE_ISSUE',
            'action': 'TRACK_FOR_REMEDIATION',
            'escalate': False
        }
            '''),
        )

        return function

    def _create_remediation_function(self, suffix: str) -> lambda_.Function:
        """
        Create Lambda function for automated security remediation
        
        Args:
            suffix: Unique suffix for resource naming
            
        Returns:
            Lambda function for remediation
        """
        function = lambda_.Function(
            self,
            f"RemediationFunction-{suffix}",
            function_name=f"security-remediation-{suffix}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            role=self.lambda_role,
            timeout=Duration.minutes(5),
            memory_size=512,
            description="Performs automated remediation of security findings",
            environment={
                "SNS_TOPIC_ARN": self.sns_topic.topic_arn,
                "LOG_LEVEL": "INFO",
            },
            log_retention=logs.RetentionDays.ONE_MONTH,
            code=lambda_.Code.from_inline('''
import json
import boto3
import logging
import os
from datetime import datetime

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

# Initialize AWS clients
ec2 = boto3.client('ec2')
iam = boto3.client('iam')
s3 = boto3.client('s3')
securityhub = boto3.client('securityhub')

def lambda_handler(event, context):
    """
    Lambda handler for automated security remediation
    
    Args:
        event: EventBridge event containing Security Hub finding
        context: Lambda context object
        
    Returns:
        Response with remediation results
    """
    try:
        # Extract finding details
        finding = event['detail']['findings'][0]
        finding_id = finding['Id']
        product_arn = finding['ProductArn']
        title = finding['Title']
        resources = finding.get('Resources', [])
        
        logger.info(f"Starting remediation for finding: {finding_id}")
        
        # Determine remediation action based on finding type
        remediation_result = perform_remediation(finding, resources)
        
        # Update finding with remediation status
        securityhub.batch_update_findings(
            FindingIdentifiers=[
                {
                    'Id': finding_id,
                    'ProductArn': product_arn
                }
            ],
            Note={
                'Text': f'Auto-remediation attempted: {remediation_result["action"]} - {remediation_result["status"]}',
                'UpdatedBy': 'SecurityIncidentResponse'
            },
            UserDefinedFields={
                'RemediationAction': remediation_result['action'],
                'RemediationStatus': remediation_result['status'],
                'RemediationTimestamp': datetime.utcnow().isoformat()
            },
            Workflow={
                'Status': 'RESOLVED' if remediation_result['status'] == 'SUCCESS' else 'NEW'
            }
        )
        
        logger.info(f"Remediation completed for finding {finding_id}: {remediation_result['status']}")
        
        return {
            'statusCode': 200,
            'body': json.dumps(remediation_result)
        }
        
    except Exception as e:
        logger.error(f"Error in remediation: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def perform_remediation(finding, resources):
    """
    Perform automated remediation based on finding type
    
    Args:
        finding: Security Hub finding object
        resources: List of affected resources
        
    Returns:
        Remediation result dictionary
    """
    title = finding['Title'].lower()
    
    try:
        # Security Group remediation
        if 'security group' in title and 'open' in title:
            return remediate_security_group(finding, resources)
        
        # S3 bucket policy remediation
        elif 's3' in title and 'public' in title:
            return remediate_s3_bucket(finding, resources)
        
        # IAM policy remediation
        elif 'iam' in title and 'policy' in title:
            return remediate_iam_policy(finding, resources)
        
        # Default action for other findings
        else:
            return {
                'action': 'MANUAL_REVIEW_REQUIRED',
                'status': 'PENDING',
                'message': 'Finding requires manual investigation'
            }
            
    except Exception as e:
        return {
            'action': 'REMEDIATION_FAILED',
            'status': 'ERROR',
            'message': str(e)
        }

def remediate_security_group(finding, resources):
    """
    Remediate overly permissive security group rules
    
    Args:
        finding: Security Hub finding object
        resources: List of affected resources
        
    Returns:
        Remediation result dictionary
    """
    for resource in resources:
        if resource['Type'] == 'AwsEc2SecurityGroup':
            sg_id = resource['Id'].split('/')[-1]
            
            try:
                # Get security group details
                response = ec2.describe_security_groups(GroupIds=[sg_id])
                sg = response['SecurityGroups'][0]
                
                # Remove overly permissive rules (0.0.0.0/0)
                for rule in sg.get('IpPermissions', []):
                    for ip_range in rule.get('IpRanges', []):
                        if ip_range.get('CidrIp') == '0.0.0.0/0':
                            # Create a copy of the rule for revocation
                            revoke_rule = {
                                'IpProtocol': rule['IpProtocol'],
                                'IpRanges': [ip_range]
                            }
                            if 'FromPort' in rule:
                                revoke_rule['FromPort'] = rule['FromPort']
                            if 'ToPort' in rule:
                                revoke_rule['ToPort'] = rule['ToPort']
                            
                            ec2.revoke_security_group_ingress(
                                GroupId=sg_id,
                                IpPermissions=[revoke_rule]
                            )
                            
                            # Add more restrictive rule (example: private network)
                            restricted_rule = revoke_rule.copy()
                            restricted_rule['IpRanges'] = [{'CidrIp': '10.0.0.0/8', 'Description': 'Internal network only'}]
                            
                            ec2.authorize_security_group_ingress(
                                GroupId=sg_id,
                                IpPermissions=[restricted_rule]
                            )
                            
                            logger.info(f"Restricted security group {sg_id} rule")
                
                return {
                    'action': 'SECURITY_GROUP_RESTRICTED',
                    'status': 'SUCCESS',
                    'message': f'Restricted security group {sg_id} access'
                }
                
            except Exception as e:
                logger.error(f"Error remediating security group {sg_id}: {str(e)}")
                return {
                    'action': 'SECURITY_GROUP_REMEDIATION_FAILED',
                    'status': 'ERROR',
                    'message': str(e)
                }
    
    return {
        'action': 'NO_SECURITY_GROUP_FOUND',
        'status': 'SKIPPED',
        'message': 'No security group resource found in finding'
    }

def remediate_s3_bucket(finding, resources):
    """
    Remediate public S3 bucket access
    
    Args:
        finding: Security Hub finding object
        resources: List of affected resources
        
    Returns:
        Remediation result dictionary
    """
    for resource in resources:
        if resource['Type'] == 'AwsS3Bucket':
            bucket_name = resource['Id'].split('/')[-1]
            
            try:
                # Apply restrictive bucket policy
                restrictive_policy = {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Sid": "DenyPublicRead",
                            "Effect": "Deny",
                            "Principal": "*",
                            "Action": "s3:GetObject",
                            "Resource": f"arn:aws:s3:::{bucket_name}/*",
                            "Condition": {
                                "Bool": {
                                    "aws:SecureTransport": "false"
                                }
                            }
                        }
                    ]
                }
                
                s3.put_bucket_policy(
                    Bucket=bucket_name,
                    Policy=json.dumps(restrictive_policy)
                )
                
                # Block public access
                s3.put_public_access_block(
                    Bucket=bucket_name,
                    PublicAccessBlockConfiguration={
                        'BlockPublicAcls': True,
                        'IgnorePublicAcls': True,
                        'BlockPublicPolicy': True,
                        'RestrictPublicBuckets': True
                    }
                )
                
                return {
                    'action': 'S3_BUCKET_SECURED',
                    'status': 'SUCCESS',
                    'message': f'Applied restrictive policy to bucket {bucket_name}'
                }
                
            except Exception as e:
                logger.error(f"Error remediating S3 bucket {bucket_name}: {str(e)}")
                return {
                    'action': 'S3_BUCKET_REMEDIATION_FAILED',
                    'status': 'ERROR',
                    'message': str(e)
                }
    
    return {
        'action': 'NO_S3_BUCKET_FOUND',
        'status': 'SKIPPED',
        'message': 'No S3 bucket resource found in finding'
    }

def remediate_iam_policy(finding, resources):
    """
    Remediate overly permissive IAM policies
    
    Args:
        finding: Security Hub finding object
        resources: List of affected resources
        
    Returns:
        Remediation result dictionary
    """
    # IAM policy changes require manual review for security
    return {
        'action': 'IAM_POLICY_REVIEW_REQUIRED',
        'status': 'PENDING',
        'message': 'IAM policy changes require manual review for security'
    }
            '''),
        )

        return function

    def _create_notification_function(self, suffix: str) -> lambda_.Function:
        """
        Create Lambda function for security incident notifications
        
        Args:
            suffix: Unique suffix for resource naming
            
        Returns:
            Lambda function for notifications
        """
        function = lambda_.Function(
            self,
            f"NotificationFunction-{suffix}",
            function_name=f"security-notification-{suffix}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            role=self.lambda_role,
            timeout=Duration.minutes(5),
            memory_size=256,
            description="Sends notifications for security incidents",
            environment={
                "SNS_TOPIC_ARN": self.sns_topic.topic_arn,
                "LOG_LEVEL": "INFO",
                "AWS_REGION": self.region,
            },
            log_retention=logs.RetentionDays.ONE_MONTH,
            code=lambda_.Code.from_inline(f'''
import json
import boto3
import logging
import os
from datetime import datetime

# Configure logging
log_level = os.environ.get('LOG_LEVEL', 'INFO')
logger = logging.getLogger()
logger.setLevel(getattr(logging, log_level))

# Initialize AWS clients
sns = boto3.client('sns')

# Get environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
AWS_REGION = os.environ['AWS_REGION']

def lambda_handler(event, context):
    """
    Lambda handler for security incident notifications
    
    Args:
        event: EventBridge event containing Security Hub finding
        context: Lambda context object
        
    Returns:
        Response with notification results
    """
    try:
        # Extract finding details
        finding = event['detail']['findings'][0]
        
        finding_id = finding['Id']
        severity = finding['Severity']['Label']
        title = finding['Title']
        description = finding['Description']
        account_id = finding['AwsAccountId']
        region = finding['Resources'][0]['Region'] if finding['Resources'] else 'Unknown'
        
        logger.info(f"Sending notification for finding: {{finding_id}} with severity: {{severity}}")
        
        # Create notification message
        message = create_notification_message(finding, severity, title, description, account_id, region)
        
        # Send notification
        response = sns.publish(
            TopicArn=SNS_TOPIC_ARN,
            Message=message,
            Subject=f'Security Alert: {{severity}} - {{title[:50]}}...' if len(title) > 50 else f'Security Alert: {{severity}} - {{title}}'
        )
        
        logger.info(f"Notification sent for finding {{finding_id}}: {{response['MessageId']}}")
        
        return {{
            'statusCode': 200,
            'body': json.dumps({{
                'messageId': response['MessageId'],
                'finding': finding_id,
                'severity': severity
            }})
        }}
        
    except Exception as e:
        logger.error(f"Error sending notification: {{str(e)}}")
        return {{
            'statusCode': 500,
            'body': json.dumps({{'error': str(e)}})
        }}

def create_notification_message(finding, severity, title, description, account_id, region):
    """
    Create formatted notification message
    
    Args:
        finding: Security Hub finding object
        severity: Finding severity level
        title: Finding title
        description: Finding description
        account_id: AWS account ID
        region: AWS region
        
    Returns:
        Formatted notification message string
    """
    
    # Determine escalation based on severity
    escalation_level = "🔴 CRITICAL" if severity == "CRITICAL" else "🟠 HIGH" if severity == "HIGH" else "🟡 MEDIUM"
    
    # Extract resource information
    resources = []
    for resource in finding.get('Resources', []):
        resources.append(f"- {{resource['Type']}}: {{resource['Id']}}")
    
    resource_list = "\\n".join(resources) if resources else "No specific resources identified"
    
    # Create comprehensive message
    message = f"""
{{escalation_level}} SECURITY INCIDENT ALERT

======================================
INCIDENT DETAILS
======================================

Finding ID: {{finding['Id']}}
Severity: {{severity}}
Title: {{title}}

Account: {{account_id}}
Region: {{region}}
Timestamp: {{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}} UTC

======================================
DESCRIPTION
======================================

{{description}}

======================================
AFFECTED RESOURCES
======================================

{{resource_list}}

======================================
RECOMMENDED ACTIONS
======================================

1. Review the finding details in AWS Security Hub
2. Investigate the affected resources
3. Apply necessary remediation steps
4. Update the finding status when resolved

======================================
SECURITY HUB LINK
======================================

https://console.aws.amazon.com/securityhub/home?region={{region}}#/findings?search=Id%3D{{finding['Id'].replace(':', '%3A').replace('/', '%2F')}}

This is an automated alert from AWS Security Hub Incident Response System.
"""

    return message
            '''),
        )

        return function

    def _create_eventbridge_rules(self, suffix: str) -> None:
        """
        Create EventBridge rules for automated incident response
        
        Args:
            suffix: Unique suffix for resource naming
        """
        # Rule for high/critical severity findings
        critical_rule = events.Rule(
            self,
            f"CriticalFindingsRule-{suffix}",
            rule_name=f"security-hub-findings-critical-{suffix}",
            description="Triggers incident response for high/critical security findings",
            event_pattern=events.EventPattern(
                source=["aws.securityhub"],
                detail_type=["Security Hub Findings - Imported"],
                detail={
                    "findings": {
                        "Severity": {
                            "Label": ["HIGH", "CRITICAL"]
                        },
                        "RecordState": ["ACTIVE"],
                        "WorkflowState": ["NEW"]
                    }
                }
            ),
        )

        # Add targets to critical rule
        critical_rule.add_target(targets.LambdaFunction(self.classification_function))
        critical_rule.add_target(targets.LambdaFunction(self.remediation_function))
        critical_rule.add_target(targets.LambdaFunction(self.notification_function))

        # Rule for medium severity findings (notification only)
        medium_rule = events.Rule(
            self,
            f"MediumFindingsRule-{suffix}",
            rule_name=f"security-hub-findings-medium-{suffix}",
            description="Triggers notifications for medium severity security findings",
            event_pattern=events.EventPattern(
                source=["aws.securityhub"],
                detail_type=["Security Hub Findings - Imported"],
                detail={
                    "findings": {
                        "Severity": {
                            "Label": ["MEDIUM"]
                        },
                        "RecordState": ["ACTIVE"],
                        "WorkflowState": ["NEW"]
                    }
                }
            ),
        )

        # Add targets to medium rule
        medium_rule.add_target(targets.LambdaFunction(self.classification_function))
        medium_rule.add_target(targets.LambdaFunction(self.notification_function))

        # Rule for manual escalation custom actions
        escalation_rule = events.Rule(
            self,
            f"ManualEscalationRule-{suffix}",
            rule_name=f"security-hub-manual-escalation-{suffix}",
            description="Handles manual escalation of security findings",
            event_pattern=events.EventPattern(
                source=["aws.securityhub"],
                detail_type=["Security Hub Findings - Custom Action"],
                detail={
                    "actionName": ["Escalate to Security Team"]
                }
            ),
        )

        # Add notification target for manual escalation
        escalation_rule.add_target(targets.LambdaFunction(self.notification_function))

    def _create_security_hub_custom_actions(self, suffix: str) -> None:
        """
        Create Security Hub custom actions for manual escalation
        
        Args:
            suffix: Unique suffix for resource naming
        """
        escalation_action = securityhub.CfnActionTarget(
            self,
            f"EscalationAction-{suffix}",
            name="Escalate to Security Team",
            description="Manually escalate security finding to security team",
            id="escalate-to-security-team",
        )

        CfnOutput(
            self,
            f"CustomActionArn-{suffix}",
            value=escalation_action.ref,
            description="ARN of the Security Hub custom escalation action",
            export_name=f"SecurityHub-CustomAction-{suffix}",
        )

    def _create_security_hub_insights(self, suffix: str) -> None:
        """
        Create Security Hub insights for incident tracking
        
        Args:
            suffix: Unique suffix for resource naming
        """
        # Critical findings insight
        critical_insight = securityhub.CfnInsight(
            self,
            f"CriticalInsight-{suffix}",
            name="Critical Security Incidents",
            group_by_attribute="ProductName",
            filters=securityhub.CfnInsight.AwsSecurityFindingFiltersProperty(
                severity_label=[
                    securityhub.CfnInsight.StringFilterProperty(
                        value="CRITICAL",
                        comparison="EQUALS"
                    )
                ],
                record_state=[
                    securityhub.CfnInsight.StringFilterProperty(
                        value="ACTIVE",
                        comparison="EQUALS"
                    )
                ]
            ),
        )

        # Unresolved findings insight
        unresolved_insight = securityhub.CfnInsight(
            self,
            f"UnresolvedInsight-{suffix}",
            name="Unresolved Security Findings",
            group_by_attribute="SeverityLabel",
            filters=securityhub.CfnInsight.AwsSecurityFindingFiltersProperty(
                workflow_status=[
                    securityhub.CfnInsight.StringFilterProperty(
                        value="NEW",
                        comparison="EQUALS"
                    )
                ],
                record_state=[
                    securityhub.CfnInsight.StringFilterProperty(
                        value="ACTIVE",
                        comparison="EQUALS"
                    )
                ]
            ),
        )

        CfnOutput(
            self,
            f"CriticalInsightArn-{suffix}",
            value=critical_insight.ref,
            description="ARN of the critical findings insight",
            export_name=f"SecurityHub-CriticalInsight-{suffix}",
        )

        CfnOutput(
            self,
            f"UnresolvedInsightArn-{suffix}",
            value=unresolved_insight.ref,
            description="ARN of the unresolved findings insight",
            export_name=f"SecurityHub-UnresolvedInsight-{suffix}",
        )

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs for key resources"""
        CfnOutput(
            self,
            "SNSTopicArn",
            value=self.sns_topic.topic_arn,
            description="ARN of the SNS topic for security incident notifications",
            export_name=f"{self.stack_name}-SNSTopicArn",
        )

        CfnOutput(
            self,
            "ClassificationFunctionArn",
            value=self.classification_function.function_arn,
            description="ARN of the security finding classification Lambda function",
            export_name=f"{self.stack_name}-ClassificationFunctionArn",
        )

        CfnOutput(
            self,
            "RemediationFunctionArn",
            value=self.remediation_function.function_arn,
            description="ARN of the automated remediation Lambda function",
            export_name=f"{self.stack_name}-RemediationFunctionArn",
        )

        CfnOutput(
            self,
            "NotificationFunctionArn",
            value=self.notification_function.function_arn,
            description="ARN of the notification Lambda function",
            export_name=f"{self.stack_name}-NotificationFunctionArn",
        )

        CfnOutput(
            self,
            "LambdaRoleArn",
            value=self.lambda_role.role_arn,
            description="ARN of the IAM role used by Lambda functions",
            export_name=f"{self.stack_name}-LambdaRoleArn",
        )


def main() -> None:
    """
    Main function to create and deploy the CDK application
    """
    app = cdk.App()

    # Get notification email from context or environment
    notification_email = (
        app.node.try_get_context("notification_email") or
        os.environ.get("NOTIFICATION_EMAIL", "security-team@company.com")
    )

    # Create the stack
    SecurityIncidentResponseStack(
        app,
        "SecurityIncidentResponseStack",
        notification_email=notification_email,
        description="Automated Security Incident Response System with AWS Security Hub",
        env=cdk.Environment(
            account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
            region=os.environ.get("CDK_DEFAULT_REGION", "us-east-1"),
        ),
    )

    app.synth()


if __name__ == "__main__":
    main()