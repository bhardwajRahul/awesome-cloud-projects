#!/usr/bin/env python3
"""
AWS CDK Application for IoT Device Provisioning and Certificate Management

This CDK application deploys a complete IoT device provisioning solution with:
- DynamoDB table for device registry
- Lambda functions for pre-provisioning validation and shadow initialization
- IoT Core provisioning templates with claim certificates
- Thing groups for device organization
- IoT policies for device types
- CloudWatch monitoring and alerting

Author: Generated by AWS CDK
Version: 1.0.0
"""

import os
from typing import Dict, Any

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Duration,
    RemovalPolicy,
    aws_dynamodb as dynamodb,
    aws_lambda as lambda_,
    aws_iam as iam,
    aws_iot as iot,
    aws_logs as logs,
    aws_cloudwatch as cloudwatch,
    aws_sns as sns,
    aws_sns_subscriptions as sns_subscriptions,
)
from constructs import Construct


class IoTDeviceProvisioningStack(Stack):
    """
    CDK Stack for IoT Device Provisioning and Certificate Management
    
    This stack creates all necessary resources for automated IoT device provisioning
    including validation, certificate management, and monitoring capabilities.
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        random_suffix: str,
        notification_email: str = None,
        **kwargs
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        self.random_suffix = random_suffix
        self.notification_email = notification_email

        # Create core infrastructure
        self.device_registry_table = self._create_device_registry_table()
        self.provisioning_hook_function = self._create_provisioning_hook_function()
        self.shadow_initializer_function = self._create_shadow_initializer_function()
        
        # Create IoT resources
        self.thing_groups = self._create_thing_groups()
        self.iot_policies = self._create_iot_policies()
        self.provisioning_role = self._create_provisioning_role()
        self.claim_certificate = self._create_claim_certificate()
        self.provisioning_template = self._create_provisioning_template()
        
        # Create monitoring and alerting
        self._create_monitoring_resources()

        # Output important resource information
        self._create_outputs()

    def _create_device_registry_table(self) -> dynamodb.Table:
        """Create DynamoDB table for device registry with GSI for device type queries"""
        table = dynamodb.Table(
            self,
            "DeviceRegistry",
            table_name=f"device-registry-{self.random_suffix}",
            partition_key=dynamodb.Attribute(
                name="serialNumber",
                type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY,
            point_in_time_recovery=True,
            stream=dynamodb.StreamViewType.NEW_AND_OLD_IMAGES,
        )

        # Add Global Secondary Index for device type queries
        table.add_global_secondary_index(
            index_name="DeviceTypeIndex",
            partition_key=dynamodb.Attribute(
                name="deviceType",
                type=dynamodb.AttributeType.STRING
            ),
            projection_type=dynamodb.ProjectionType.ALL,
        )

        # Add tags for resource management
        cdk.Tags.of(table).add("Project", "IoTProvisioning")
        cdk.Tags.of(table).add("Component", "DeviceRegistry")

        return table

    def _create_provisioning_hook_function(self) -> lambda_.Function:
        """Create Lambda function for pre-provisioning device validation"""
        
        # Create execution role for Lambda function
        execution_role = iam.Role(
            self,
            "ProvisioningHookExecutionRole",
            role_name=f"provisioning-hook-execution-role-{self.random_suffix}",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ],
        )

        # Add DynamoDB permissions
        execution_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "dynamodb:GetItem",
                    "dynamodb:PutItem",
                    "dynamodb:UpdateItem",
                    "dynamodb:Query",
                ],
                resources=[
                    self.device_registry_table.table_arn,
                    f"{self.device_registry_table.table_arn}/*",
                ],
            )
        )

        # Add IoT permissions
        execution_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "iot:DescribeThing",
                    "iot:ListThingTypes",
                ],
                resources=["*"],
            )
        )

        # Create Lambda function
        function = lambda_.Function(
            self,
            "ProvisioningHookFunction",
            function_name=f"device-provisioning-hook-{self.random_suffix}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(self._get_provisioning_hook_code()),
            timeout=Duration.seconds(60),
            memory_size=256,
            role=execution_role,
            environment={
                "DEVICE_REGISTRY_TABLE": self.device_registry_table.table_name,
                "LOG_LEVEL": "INFO",
            },
            description="Pre-provisioning hook for IoT device validation",
        )

        # Add tags
        cdk.Tags.of(function).add("Project", "IoTProvisioning")
        cdk.Tags.of(function).add("Component", "PreProvisioningHook")

        return function

    def _create_shadow_initializer_function(self) -> lambda_.Function:
        """Create Lambda function for device shadow initialization"""
        
        # Create execution role
        execution_role = iam.Role(
            self,
            "ShadowInitializerExecutionRole",
            role_name=f"shadow-initializer-execution-role-{self.random_suffix}",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ],
        )

        # Add IoT Data permissions
        execution_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "iot:GetThingShadow",
                    "iot:UpdateThingShadow",
                ],
                resources=[f"arn:aws:iot:{self.region}:{self.account}:thing/*"],
            )
        )

        # Create Lambda function
        function = lambda_.Function(
            self,
            "ShadowInitializerFunction",
            function_name=f"device-shadow-initializer-{self.random_suffix}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(self._get_shadow_initializer_code()),
            timeout=Duration.seconds(30),
            memory_size=128,
            role=execution_role,
            environment={
                "LOG_LEVEL": "INFO",
            },
            description="Initialize device shadows after provisioning",
        )

        # Add tags
        cdk.Tags.of(function).add("Project", "IoTProvisioning")
        cdk.Tags.of(function).add("Component", "ShadowInitializer")

        return function

    def _create_thing_groups(self) -> Dict[str, iot.CfnThingGroup]:
        """Create IoT Thing Groups for device organization"""
        thing_groups = {}

        # Create parent thing group
        parent_group = iot.CfnThingGroup(
            self,
            "ParentThingGroup",
            thing_group_name=f"provisioned-devices-{self.random_suffix}",
            thing_group_properties=iot.CfnThingGroup.ThingGroupPropertiesProperty(
                thing_group_description="Parent group for all provisioned devices",
            ),
        )
        thing_groups["parent"] = parent_group

        # Create device-type specific thing groups
        device_types = ["temperature-sensor", "humidity-sensor", "pressure-sensor", "gateway"]
        
        for device_type in device_types:
            thing_group = iot.CfnThingGroup(
                self,
                f"{device_type.replace('-', '').title()}ThingGroup",
                thing_group_name=f"{device_type}-devices",
                thing_group_properties=iot.CfnThingGroup.ThingGroupPropertiesProperty(
                    thing_group_description=f"Thing group for {device_type} devices",
                    parent_group_name=parent_group.thing_group_name,
                ),
            )
            thing_groups[device_type] = thing_group

        return thing_groups

    def _create_iot_policies(self) -> Dict[str, iot.CfnPolicy]:
        """Create IoT policies for different device types"""
        policies = {}

        # Temperature sensor policy
        temperature_policy = iot.CfnPolicy(
            self,
            "TemperatureSensorPolicy",
            policy_name="TemperatureSensorPolicy",
            policy_document={
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Connect"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:client/temperature-sensor-*",
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Publish"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:topic/sensors/temperature/*",
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Subscribe", "iot:Receive"],
                        "Resource": [
                            f"arn:aws:iot:{self.region}:{self.account}:topicfilter/config/temperature-sensor/*",
                            f"arn:aws:iot:{self.region}:{self.account}:topic/config/temperature-sensor/*",
                        ],
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:GetThingShadow", "iot:UpdateThingShadow"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:thing/temperature-sensor-*",
                    },
                ],
            },
        )
        policies["temperature-sensor"] = temperature_policy

        # Gateway device policy
        gateway_policy = iot.CfnPolicy(
            self,
            "GatewayDevicePolicy",
            policy_name="GatewayDevicePolicy",
            policy_document={
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Connect"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:client/gateway-*",
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Publish"],
                        "Resource": [
                            f"arn:aws:iot:{self.region}:{self.account}:topic/gateway/*",
                            f"arn:aws:iot:{self.region}:{self.account}:topic/sensors/*",
                        ],
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Subscribe", "iot:Receive"],
                        "Resource": [
                            f"arn:aws:iot:{self.region}:{self.account}:topicfilter/config/gateway/*",
                            f"arn:aws:iot:{self.region}:{self.account}:topic/config/gateway/*",
                            f"arn:aws:iot:{self.region}:{self.account}:topicfilter/commands/*",
                            f"arn:aws:iot:{self.region}:{self.account}:topic/commands/*",
                        ],
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:GetThingShadow", "iot:UpdateThingShadow"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:thing/gateway-*",
                    },
                ],
            },
        )
        policies["gateway"] = gateway_policy

        return policies

    def _create_provisioning_role(self) -> iam.Role:
        """Create IAM role for IoT provisioning operations"""
        
        # Create role
        role = iam.Role(
            self,
            "IoTProvisioningRole",
            role_name=f"iot-provisioning-role-{self.random_suffix}",
            assumed_by=iam.ServicePrincipal("iot.amazonaws.com"),
            description="Role for IoT device provisioning operations",
        )

        # Add provisioning permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "iot:CreateThing",
                    "iot:DescribeThing",
                    "iot:CreateKeysAndCertificate",
                    "iot:AttachThingPrincipal",
                    "iot:AttachPolicy",
                    "iot:AddThingToThingGroup",
                    "iot:UpdateThingShadow",
                ],
                resources=["*"],
            )
        )

        # Add Lambda invoke permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=["lambda:InvokeFunction"],
                resources=[self.provisioning_hook_function.function_arn],
            )
        )

        # Add CloudWatch Logs permissions
        role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                ],
                resources=[f"arn:aws:logs:{self.region}:{self.account}:*"],
            )
        )

        # Add tags
        cdk.Tags.of(role).add("Project", "IoTProvisioning")
        cdk.Tags.of(role).add("Component", "ProvisioningRole")

        return role

    def _create_claim_certificate(self) -> iot.CfnPolicy:
        """Create claim certificate policy for device manufacturing"""
        
        # Create policy for claim certificate
        claim_policy = iot.CfnPolicy(
            self,
            "ClaimCertificatePolicy",
            policy_name="ClaimCertificatePolicy",
            policy_document={
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Connect"],
                        "Resource": "*",
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Publish"],
                        "Resource": f"arn:aws:iot:{self.region}:{self.account}:topic/$aws/provisioning-templates/*/provision/*",
                    },
                    {
                        "Effect": "Allow",
                        "Action": ["iot:Subscribe", "iot:Receive"],
                        "Resource": [
                            f"arn:aws:iot:{self.region}:{self.account}:topicfilter/$aws/provisioning-templates/*/provision/*"
                        ],
                    },
                ],
            },
        )

        return claim_policy

    def _create_provisioning_template(self) -> iot.CfnProvisioningTemplate:
        """Create IoT provisioning template with pre-provisioning hook"""
        
        template_body = {
            "Parameters": {
                "SerialNumber": {"Type": "String"},
                "DeviceType": {"Type": "String"},
                "FirmwareVersion": {"Type": "String"},
                "Manufacturer": {"Type": "String"},
                "Location": {"Type": "String"},
                "AWS::IoT::Certificate::Id": {"Type": "String"},
                "AWS::IoT::Certificate::Arn": {"Type": "String"},
            },
            "Resources": {
                "thing": {
                    "Type": "AWS::IoT::Thing",
                    "Properties": {
                        "ThingName": {"Ref": "ThingName"},
                        "AttributePayload": {
                            "serialNumber": {"Ref": "SerialNumber"},
                            "deviceType": {"Ref": "DeviceType"},
                            "firmwareVersion": {"Ref": "FirmwareVersion"},
                            "manufacturer": {"Ref": "Manufacturer"},
                            "location": {"Ref": "DeviceLocation"},
                            "provisioningTime": {"Ref": "ProvisioningTime"},
                        },
                        "ThingTypeName": "IoTDevice",
                    },
                },
                "certificate": {
                    "Type": "AWS::IoT::Certificate",
                    "Properties": {
                        "CertificateId": {"Ref": "AWS::IoT::Certificate::Id"},
                        "Status": "Active",
                    },
                },
                "policy": {
                    "Type": "AWS::IoT::Policy",
                    "Properties": {
                        "PolicyName": {"Fn::Sub": "${DeviceType}Policy"}
                    },
                },
                "thingGroup": {
                    "Type": "AWS::IoT::ThingGroup",
                    "Properties": {
                        "ThingGroupName": {"Ref": "ThingGroupName"}
                    },
                },
            },
        }

        template = iot.CfnProvisioningTemplate(
            self,
            "DeviceProvisioningTemplate",
            template_name=f"device-provisioning-template-{self.random_suffix}",
            description="Template for automated device provisioning with validation",
            template_body=cdk.Fn.to_json_string(template_body),
            enabled=True,
            provisioning_role_arn=self.provisioning_role.role_arn,
            pre_provisioning_hook=iot.CfnProvisioningTemplate.ProvisioningHookProperty(
                target_arn=self.provisioning_hook_function.function_arn,
                payload_version="2020-04-01",
            ),
        )

        # Add tags
        cdk.Tags.of(template).add("Project", "IoTProvisioning")
        cdk.Tags.of(template).add("Component", "ProvisioningTemplate")

        return template

    def _create_monitoring_resources(self) -> None:
        """Create CloudWatch monitoring and alerting resources"""
        
        # Create log group for provisioning monitoring
        log_group = logs.LogGroup(
            self,
            "ProvisioningLogGroup",
            log_group_name="/aws/iot/provisioning",
            retention=logs.RetentionDays.ONE_MONTH,
            removal_policy=RemovalPolicy.DESTROY,
        )

        # Create SNS topic for alerts (if email provided)
        if self.notification_email:
            alert_topic = sns.Topic(
                self,
                "ProvisioningAlertsTopic",
                topic_name=f"provisioning-alerts-{self.random_suffix}",
                description="Alerts for IoT device provisioning failures",
            )

            # Add email subscription
            alert_topic.add_subscription(
                sns_subscriptions.EmailSubscription(self.notification_email)
            )

            # Create CloudWatch alarm for provisioning failures
            alarm = cloudwatch.Alarm(
                self,
                "ProvisioningFailuresAlarm",
                alarm_name="IoTProvisioningFailures",
                alarm_description="Monitor failed device provisioning attempts",
                metric=self.provisioning_hook_function.metric_errors(
                    period=Duration.minutes(5)
                ),
                threshold=5,
                evaluation_periods=1,
                comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            )

            # Add SNS action to alarm
            alarm.add_alarm_action(
                cloudwatch.SnsAction(alert_topic)
            )

        # Create IoT rule for provisioning audit logging
        audit_rule = iot.CfnTopicRule(
            self,
            "ProvisioningAuditRule",
            rule_name="ProvisioningAuditRule",
            topic_rule_payload=iot.CfnTopicRule.TopicRulePayloadProperty(
                sql='SELECT * FROM "$aws/events/provisioning/template/+/+"',
                description="Log all provisioning events for audit",
                actions=[
                    iot.CfnTopicRule.ActionProperty(
                        cloudwatch_logs=iot.CfnTopicRule.CloudwatchLogsActionProperty(
                            log_group_name=log_group.log_group_name,
                            role_arn=self.provisioning_role.role_arn,
                        )
                    )
                ],
            ),
        )

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs for important resources"""
        
        cdk.CfnOutput(
            self,
            "DeviceRegistryTableName",
            value=self.device_registry_table.table_name,
            description="Name of the device registry DynamoDB table",
        )

        cdk.CfnOutput(
            self,
            "ProvisioningHookFunctionName",
            value=self.provisioning_hook_function.function_name,
            description="Name of the pre-provisioning hook Lambda function",
        )

        cdk.CfnOutput(
            self,
            "ProvisioningTemplateName",
            value=self.provisioning_template.template_name,
            description="Name of the IoT provisioning template",
        )

        cdk.CfnOutput(
            self,
            "ParentThingGroupName",
            value=self.thing_groups["parent"].thing_group_name,
            description="Name of the parent thing group for all devices",
        )

        cdk.CfnOutput(
            self,
            "ProvisioningRoleArn",
            value=self.provisioning_role.role_arn,
            description="ARN of the IoT provisioning role",
        )

    def _get_provisioning_hook_code(self) -> str:
        """Return the Lambda function code for pre-provisioning hook"""
        return '''
import json
import boto3
import logging
import os
from datetime import datetime, timezone

# Configure logging
logger = logging.getLogger()
logger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))

dynamodb = boto3.resource('dynamodb')
iot = boto3.client('iot')

def lambda_handler(event, context):
    """
    Pre-provisioning hook to validate and authorize device provisioning
    """
    try:
        # Extract device information from provisioning request
        certificate_pem = event.get('certificatePem', '')
        template_arn = event.get('templateArn', '')
        parameters = event.get('parameters', {})
        
        serial_number = parameters.get('SerialNumber', '')
        device_type = parameters.get('DeviceType', '')
        firmware_version = parameters.get('FirmwareVersion', '')
        manufacturer = parameters.get('Manufacturer', '')
        
        logger.info(f"Processing provisioning request for device: {serial_number}")
        
        # Validate required parameters
        if not all([serial_number, device_type, manufacturer]):
            return create_response(False, "Missing required device parameters")
        
        # Validate device type
        valid_device_types = ['temperature-sensor', 'humidity-sensor', 'pressure-sensor', 'gateway']
        if device_type not in valid_device_types:
            return create_response(False, f"Invalid device type: {device_type}")
        
        # Check if device is already registered
        table = dynamodb.Table(os.environ['DEVICE_REGISTRY_TABLE'])
        
        try:
            response = table.get_item(Key={'serialNumber': serial_number})
            if 'Item' in response:
                existing_status = response['Item'].get('status', '')
                if existing_status == 'provisioned':
                    return create_response(False, "Device already provisioned")
                elif existing_status == 'revoked':
                    return create_response(False, "Device has been revoked")
        except Exception as e:
            logger.error(f"Error checking device registry: {str(e)}")
        
        # Validate firmware version (basic check)
        if firmware_version and not firmware_version.startswith('v'):
            return create_response(False, "Invalid firmware version format")
        
        # Store device information in registry
        try:
            device_item = {
                'serialNumber': serial_number,
                'deviceType': device_type,
                'manufacturer': manufacturer,
                'firmwareVersion': firmware_version,
                'status': 'provisioning',
                'provisioningTimestamp': datetime.now(timezone.utc).isoformat(),
                'templateArn': template_arn
            }
            
            table.put_item(Item=device_item)
            logger.info(f"Device {serial_number} registered in device registry")
            
        except Exception as e:
            logger.error(f"Error storing device in registry: {str(e)}")
            return create_response(False, "Failed to register device")
        
        # Determine thing group based on device type
        thing_group = f"{device_type}-devices"
        
        # Create response with device-specific parameters
        response_parameters = {
            'ThingName': f"{device_type}-{serial_number}",
            'ThingGroupName': thing_group,
            'DeviceLocation': parameters.get('Location', 'unknown'),
            'ProvisioningTime': datetime.now(timezone.utc).isoformat()
        }
        
        return create_response(True, "Device validation successful", response_parameters)
        
    except Exception as e:
        logger.error(f"Unexpected error in provisioning hook: {str(e)}")
        return create_response(False, "Internal provisioning error")

def create_response(allow_provisioning, message, parameters=None):
    """Create standardized response for provisioning hook"""
    response = {
        'allowProvisioning': allow_provisioning,
        'message': message
    }
    
    if parameters:
        response['parameters'] = parameters
    
    logger.info(f"Provisioning response: {response}")
    return response
'''

    def _get_shadow_initializer_code(self) -> str:
        """Return the Lambda function code for shadow initialization"""
        return '''
import json
import boto3
import logging
import os

logger = logging.getLogger()
logger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))

iot_data = boto3.client('iot-data')

def lambda_handler(event, context):
    """Initialize device shadow after successful provisioning"""
    try:
        # Extract thing name from the event
        thing_name = event.get('thingName', '')
        device_type = event.get('deviceType', '')
        
        if not thing_name:
            logger.error("Thing name not provided in event")
            return {'statusCode': 400, 'body': 'Thing name required'}
        
        # Create initial shadow document based on device type
        if device_type == 'temperature-sensor':
            initial_shadow = {
                "state": {
                    "desired": {
                        "samplingRate": 30,
                        "temperatureUnit": "celsius",
                        "alertThreshold": 80,
                        "enabled": True
                    }
                }
            }
        elif device_type == 'gateway':
            initial_shadow = {
                "state": {
                    "desired": {
                        "connectionTimeout": 30,
                        "bufferSize": 100,
                        "compressionEnabled": True,
                        "logLevel": "INFO"
                    }
                }
            }
        else:
            initial_shadow = {
                "state": {
                    "desired": {
                        "enabled": True,
                        "reportingInterval": 60
                    }
                }
            }
        
        # Update device shadow
        iot_data.update_thing_shadow(
            thingName=thing_name,
            payload=json.dumps(initial_shadow)
        )
        
        logger.info(f"Initialized shadow for device: {thing_name}")
        return {
            'statusCode': 200,
            'body': json.dumps(f'Shadow initialized for {thing_name}')
        }
        
    except Exception as e:
        logger.error(f"Error initializing shadow: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps(f'Error: {str(e)}')
        }
'''


def main():
    """Main function to create and deploy the CDK application"""
    app = cdk.App()
    
    # Get configuration from context or environment variables
    random_suffix = app.node.try_get_context("randomSuffix") or os.environ.get("RANDOM_SUFFIX", "dev123")
    notification_email = app.node.try_get_context("notificationEmail") or os.environ.get("NOTIFICATION_EMAIL")
    
    # Create the stack
    IoTDeviceProvisioningStack(
        app,
        "IoTDeviceProvisioningStack",
        random_suffix=random_suffix,
        notification_email=notification_email,
        description="IoT Device Provisioning and Certificate Management Solution",
        env=cdk.Environment(
            account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
            region=os.environ.get("CDK_DEFAULT_REGION", "us-east-1")
        ),
    )
    
    app.synth()


if __name__ == "__main__":
    main()