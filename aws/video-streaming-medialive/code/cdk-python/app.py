#!/usr/bin/env python3
"""
AWS CDK Python Application for Enterprise Video Streaming Platform

This CDK application deploys a comprehensive video streaming platform using
AWS Elemental MediaLive, MediaPackage, and CloudFront for scalable,
enterprise-grade live video streaming with adaptive bitrate support.

Author: Generated by Claude Code
Version: 1.0
"""

import os
from aws_cdk import (
    App,
    Environment,
    Tags,
    CfnOutput,
    Duration,
    RemovalPolicy,
    Stack,
    aws_iam as iam,
    aws_s3 as s3,
    aws_cloudfront as cloudfront,
    aws_cloudfront_origins as origins,
    aws_medialive as medialive,
    aws_mediapackage as mediapackage,
    aws_secretsmanager as secretsmanager,
    aws_cloudwatch as cloudwatch,
    aws_cloudwatch_actions as cw_actions,
    aws_sns as sns,
    aws_logs as logs,
)
from constructs import Construct
from typing import Dict, List, Optional, Any


class VideoStreamingPlatformStack(Stack):
    """
    CDK Stack for Enterprise Video Streaming Platform
    
    Deploys a complete streaming infrastructure including:
    - MediaLive channels with multiple bitrate outputs
    - MediaPackage channels with multiple protocol endpoints
    - CloudFront distribution for global content delivery
    - S3 storage for content archiving
    - Comprehensive monitoring and alerting
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        platform_name: str,
        enable_drm: bool = True,
        enable_low_latency: bool = True,
        archive_content: bool = True,
        **kwargs
    ) -> None:
        """
        Initialize the Video Streaming Platform Stack
        
        Args:
            scope: CDK App or parent construct
            construct_id: Unique identifier for this stack
            platform_name: Name for the streaming platform (used in resource naming)
            enable_drm: Whether to enable DRM-ready endpoints
            enable_low_latency: Whether to enable low-latency CMAF endpoints
            archive_content: Whether to enable content archiving to S3
            **kwargs: Additional stack properties
        """
        super().__init__(scope, construct_id, **kwargs)

        self.platform_name = platform_name
        self.enable_drm = enable_drm
        self.enable_low_latency = enable_low_latency
        self.archive_content = archive_content

        # Create platform resources
        self._create_iam_roles()
        self._create_storage_resources()
        self._create_input_security_groups()
        self._create_medialive_inputs()
        self._create_mediapackage_channel()
        self._create_mediapackage_endpoints()
        self._create_medialive_channel()
        self._create_cloudfront_distribution()
        self._create_monitoring_and_alerts()
        self._create_outputs()

        # Tag all resources
        self._tag_resources()

    def _create_iam_roles(self) -> None:
        """Create IAM roles for MediaLive with comprehensive permissions"""
        
        # MediaLive service role with enhanced permissions
        self.medialive_role = iam.Role(
            self,
            "MediaLiveRole",
            role_name=f"MediaLivePlatformRole-{self.platform_name}",
            assumed_by=iam.ServicePrincipal("medialive.amazonaws.com"),
            description="Enhanced MediaLive service role for streaming platform",
            inline_policies={
                "MediaLivePlatformPolicy": iam.PolicyDocument(
                    statements=[
                        iam.PolicyStatement(
                            effect=iam.Effect.ALLOW,
                            actions=[
                                "mediapackage:*",
                                "s3:GetObject",
                                "s3:PutObject",
                                "s3:DeleteObject",
                                "s3:ListBucket",
                                "secretsmanager:GetSecretValue",
                                "secretsmanager:CreateSecret",
                                "cloudwatch:PutMetricData",
                                "logs:CreateLogGroup",
                                "logs:CreateLogStream",
                                "logs:PutLogEvents",
                                "logs:DescribeLogStreams",
                            ],
                            resources=["*"]
                        )
                    ]
                )
            }
        )

    def _create_storage_resources(self) -> None:
        """Create S3 bucket for content storage and archiving"""
        
        # S3 bucket for streaming platform content
        self.content_bucket = s3.Bucket(
            self,
            "ContentBucket",
            bucket_name=f"streaming-platform-{self.platform_name}",
            versioned=True,
            removal_policy=RemovalPolicy.DESTROY,
            auto_delete_objects=True,
            encryption=s3.BucketEncryption.S3_MANAGED,
            block_public_access=s3.BlockPublicAccess.BLOCK_ALL,
            lifecycle_rules=[
                s3.LifecycleRule(
                    id="streaming-content-lifecycle",
                    enabled=True,
                    prefix="archives/",
                    transitions=[
                        s3.Transition(
                            storage_class=s3.StorageClass.INFREQUENT_ACCESS,
                            transition_after=Duration.days(30)
                        ),
                        s3.Transition(
                            storage_class=s3.StorageClass.GLACIER,
                            transition_after=Duration.days(90)
                        ),
                        s3.Transition(
                            storage_class=s3.StorageClass.DEEP_ARCHIVE,
                            transition_after=Duration.days(365)
                        ),
                    ]
                )
            ]
        )

        # Grant MediaLive access to the bucket
        self.content_bucket.grant_read_write(self.medialive_role)

    def _create_input_security_groups(self) -> None:
        """Create MediaLive input security groups for different access patterns"""
        
        # Public input security group for general streaming
        self.public_security_group = medialive.CfnInputSecurityGroup(
            self,
            "PublicInputSecurityGroup",
            whitelist_rules=[
                medialive.CfnInputSecurityGroup.InputWhitelistRuleCidrProperty(
                    cidr="0.0.0.0/0"
                )
            ],
            tags={
                "Name": f"StreamingPlatformSG-{self.platform_name}",
                "Environment": "Production",
                "Type": "Public"
            }
        )

        # Internal input security group for corporate networks
        self.internal_security_group = medialive.CfnInputSecurityGroup(
            self,
            "InternalInputSecurityGroup",
            whitelist_rules=[
                medialive.CfnInputSecurityGroup.InputWhitelistRuleCidrProperty(
                    cidr="10.0.0.0/8"
                ),
                medialive.CfnInputSecurityGroup.InputWhitelistRuleCidrProperty(
                    cidr="172.16.0.0/12"
                ),
                medialive.CfnInputSecurityGroup.InputWhitelistRuleCidrProperty(
                    cidr="192.168.0.0/16"
                ),
            ],
            tags={
                "Name": f"InternalStreamingSG-{self.platform_name}",
                "Environment": "Production",
                "Type": "Internal"
            }
        )

    def _create_medialive_inputs(self) -> None:
        """Create multiple MediaLive inputs for different streaming sources"""
        
        # RTMP Push input for live streaming software
        self.rtmp_input = medialive.CfnInput(
            self,
            "RTMPInput",
            name=f"{self.platform_name}-rtmp-input",
            type="RTMP_PUSH",
            input_security_groups=[self.public_security_group.ref],
            tags={
                "Name": f"RTMPInput-{self.platform_name}",
                "Type": "Live",
                "Protocol": "RTMP"
            }
        )

        # HLS Pull input for remote streaming sources
        self.hls_input = medialive.CfnInput(
            self,
            "HLSInput",
            name=f"{self.platform_name}-hls-input",
            type="URL_PULL",
            sources=[
                medialive.CfnInput.InputSourceRequestProperty(
                    url="https://example.com/stream.m3u8"
                )
            ],
            tags={
                "Name": f"HLSInput-{self.platform_name}",
                "Type": "Remote",
                "Protocol": "HLS"
            }
        )

        # RTP Push input for professional broadcast equipment
        self.rtp_input = medialive.CfnInput(
            self,
            "RTPInput",
            name=f"{self.platform_name}-rtp-input",
            type="RTP_PUSH",
            input_security_groups=[self.internal_security_group.ref],
            tags={
                "Name": f"RTPInput-{self.platform_name}",
                "Type": "Professional",
                "Protocol": "RTP"
            }
        )

    def _create_mediapackage_channel(self) -> None:
        """Create MediaPackage channel for content packaging and origin services"""
        
        self.package_channel_id = f"package-channel-{self.platform_name}"
        
        # MediaPackage channel
        self.mediapackage_channel = mediapackage.CfnChannel(
            self,
            "MediaPackageChannel",
            id=self.package_channel_id,
            description=f"Enterprise streaming platform channel for {self.platform_name}",
            tags=[
                {
                    "key": "Name",
                    "value": f"StreamingChannel-{self.platform_name}"
                },
                {
                    "key": "Environment",
                    "value": "Production"
                },
                {
                    "key": "Service",
                    "value": "MediaPackage"
                }
            ]
        )

        # DRM key for content protection (if enabled)
        if self.enable_drm:
            self.drm_key = secretsmanager.Secret(
                self,
                "DRMKey",
                secret_name=f"medialive-drm-key-{self.platform_name}",
                description="DRM encryption key for streaming platform",
                generate_secret_string=secretsmanager.SecretStringGenerator(
                    secret_string_template='{}',
                    generate_string_key="key",
                    exclude_characters=" %+~`#$&*()|[]{}:;<>?!'/\"\\",
                    password_length=32
                )
            )

    def _create_mediapackage_endpoints(self) -> None:
        """Create MediaPackage origin endpoints for different streaming protocols"""
        
        # HLS endpoint with advanced features
        self.hls_endpoint = mediapackage.CfnOriginEndpoint(
            self,
            "HLSEndpoint",
            channel_id=self.mediapackage_channel.id,
            id=f"{self.package_channel_id}-hls-advanced",
            manifest_name="master.m3u8",
            startover_window_seconds=3600,
            time_delay_seconds=10,
            hls_package=mediapackage.CfnOriginEndpoint.HlsPackageProperty(
                segment_duration_seconds=4,
                playlist_type="EVENT",
                playlist_window_seconds=300,
                program_date_time_interval_seconds=60,
                ad_markers="SCTE35_ENHANCED",
                include_iframe_only_stream=True,
                use_audio_rendition_group=True
            ),
            tags=[
                {
                    "key": "Type",
                    "value": "HLS"
                },
                {
                    "key": "Quality",
                    "value": "Advanced"
                },
                {
                    "key": "Environment",
                    "value": "Production"
                }
            ]
        )

        # DASH endpoint with DRM support
        if self.enable_drm:
            self.dash_endpoint = mediapackage.CfnOriginEndpoint(
                self,
                "DASHEndpoint",
                channel_id=self.mediapackage_channel.id,
                id=f"{self.package_channel_id}-dash-drm",
                manifest_name="manifest.mpd",
                startover_window_seconds=3600,
                time_delay_seconds=10,
                dash_package=mediapackage.CfnOriginEndpoint.DashPackageProperty(
                    segment_duration_seconds=4,
                    min_buffer_time_seconds=20,
                    min_update_period_seconds=10,
                    suggested_presentation_delay_seconds=30,
                    profile="NONE",
                    period_triggers=["ADS"]
                ),
                tags=[
                    {
                        "key": "Type",
                        "value": "DASH"
                    },
                    {
                        "key": "DRM",
                        "value": "Enabled"
                    },
                    {
                        "key": "Environment",
                        "value": "Production"
                    }
                ]
            )

        # CMAF endpoint for low-latency streaming
        if self.enable_low_latency:
            self.cmaf_endpoint = mediapackage.CfnOriginEndpoint(
                self,
                "CMAFEndpoint",
                channel_id=self.mediapackage_channel.id,
                id=f"{self.package_channel_id}-cmaf-ll",
                manifest_name="index.m3u8",
                startover_window_seconds=1800,
                time_delay_seconds=2,
                cmaf_package=mediapackage.CfnOriginEndpoint.CmafPackageProperty(
                    segment_duration_seconds=2,
                    segment_prefix="segment",
                    hls_manifests=[
                        mediapackage.CfnOriginEndpoint.HlsManifestProperty(
                            id="low-latency",
                            manifest_name="ll.m3u8",
                            playlist_type="EVENT",
                            playlist_window_seconds=60,
                            program_date_time_interval_seconds=60,
                            ad_markers="SCTE35_ENHANCED"
                        )
                    ]
                ),
                tags=[
                    {
                        "key": "Type",
                        "value": "CMAF"
                    },
                    {
                        "key": "Latency",
                        "value": "Low"
                    },
                    {
                        "key": "Environment",
                        "value": "Production"
                    }
                ]
            )

    def _create_medialive_channel(self) -> None:
        """Create MediaLive channel with comprehensive encoding configuration"""
        
        # Define video encoding configurations for multiple bitrates
        video_descriptions = [
            # 4K UHD configuration
            medialive.CfnChannel.VideoDescriptionProperty(
                name="video_2160p",
                width=3840,
                height=2160,
                codec_settings=medialive.CfnChannel.VideoCodecSettingsProperty(
                    h264_settings=medialive.CfnChannel.H264SettingsProperty(
                        bitrate=15000000,
                        framerate_control="SPECIFIED",
                        framerate_numerator=30,
                        framerate_denominator=1,
                        gop_b_reference="ENABLED",
                        gop_closed_cadence=1,
                        gop_num_b_frames=3,
                        gop_size=90,
                        gop_size_units="FRAMES",
                        profile="HIGH",
                        level="H264_LEVEL_5_1",
                        rate_control_mode="CBR",
                        syntax="DEFAULT",
                        adaptive_quantization="HIGH",
                        afd_signaling="NONE",
                        color_metadata="INSERT",
                        entropy_encoding="CABAC",
                        flicker_aq="ENABLED",
                        force_field_pictures="DISABLED",
                        temporal_aq="ENABLED",
                        spatial_aq="ENABLED"
                    )
                ),
                respond_to_afd="RESPOND",
                scaling_behavior="DEFAULT",
                sharpness=50
            ),
            # 1080p HD configuration
            medialive.CfnChannel.VideoDescriptionProperty(
                name="video_1080p",
                width=1920,
                height=1080,
                codec_settings=medialive.CfnChannel.VideoCodecSettingsProperty(
                    h264_settings=medialive.CfnChannel.H264SettingsProperty(
                        bitrate=6000000,
                        framerate_control="SPECIFIED",
                        framerate_numerator=30,
                        framerate_denominator=1,
                        gop_b_reference="ENABLED",
                        gop_closed_cadence=1,
                        gop_num_b_frames=3,
                        gop_size=90,
                        gop_size_units="FRAMES",
                        profile="HIGH",
                        level="H264_LEVEL_4_1",
                        rate_control_mode="CBR",
                        syntax="DEFAULT",
                        adaptive_quantization="HIGH",
                        temporal_aq="ENABLED",
                        spatial_aq="ENABLED"
                    )
                ),
                respond_to_afd="RESPOND",
                scaling_behavior="DEFAULT",
                sharpness=50
            ),
            # 720p HD configuration
            medialive.CfnChannel.VideoDescriptionProperty(
                name="video_720p",
                width=1280,
                height=720,
                codec_settings=medialive.CfnChannel.VideoCodecSettingsProperty(
                    h264_settings=medialive.CfnChannel.H264SettingsProperty(
                        bitrate=3000000,
                        framerate_control="SPECIFIED",
                        framerate_numerator=30,
                        framerate_denominator=1,
                        gop_b_reference="ENABLED",
                        gop_closed_cadence=1,
                        gop_num_b_frames=2,
                        gop_size=90,
                        gop_size_units="FRAMES",
                        profile="HIGH",
                        level="H264_LEVEL_3_1",
                        rate_control_mode="CBR",
                        syntax="DEFAULT",
                        adaptive_quantization="MEDIUM",
                        temporal_aq="ENABLED",
                        spatial_aq="ENABLED"
                    )
                ),
                respond_to_afd="RESPOND",
                scaling_behavior="DEFAULT",
                sharpness=50
            ),
            # 480p SD configuration
            medialive.CfnChannel.VideoDescriptionProperty(
                name="video_480p",
                width=854,
                height=480,
                codec_settings=medialive.CfnChannel.VideoCodecSettingsProperty(
                    h264_settings=medialive.CfnChannel.H264SettingsProperty(
                        bitrate=1500000,
                        framerate_control="SPECIFIED",
                        framerate_numerator=30,
                        framerate_denominator=1,
                        gop_b_reference="DISABLED",
                        gop_closed_cadence=1,
                        gop_num_b_frames=2,
                        gop_size=90,
                        gop_size_units="FRAMES",
                        profile="MAIN",
                        level="H264_LEVEL_3_0",
                        rate_control_mode="CBR",
                        syntax="DEFAULT",
                        adaptive_quantization="MEDIUM"
                    )
                ),
                respond_to_afd="RESPOND",
                scaling_behavior="DEFAULT",
                sharpness=50
            ),
            # 240p Mobile configuration
            medialive.CfnChannel.VideoDescriptionProperty(
                name="video_240p",
                width=426,
                height=240,
                codec_settings=medialive.CfnChannel.VideoCodecSettingsProperty(
                    h264_settings=medialive.CfnChannel.H264SettingsProperty(
                        bitrate=500000,
                        framerate_control="SPECIFIED",
                        framerate_numerator=30,
                        framerate_denominator=1,
                        gop_b_reference="DISABLED",
                        gop_closed_cadence=1,
                        gop_num_b_frames=1,
                        gop_size=90,
                        gop_size_units="FRAMES",
                        profile="BASELINE",
                        level="H264_LEVEL_2_0",
                        rate_control_mode="CBR",
                        syntax="DEFAULT"
                    )
                ),
                respond_to_afd="RESPOND",
                scaling_behavior="DEFAULT",
                sharpness=50
            )
        ]

        # Audio descriptions for stereo and surround sound
        audio_descriptions = [
            medialive.CfnChannel.AudioDescriptionProperty(
                name="audio_stereo",
                audio_selector_name="default",
                audio_type_control="FOLLOW_INPUT",
                language_code_control="FOLLOW_INPUT",
                codec_settings=medialive.CfnChannel.AudioCodecSettingsProperty(
                    aac_settings=medialive.CfnChannel.AacSettingsProperty(
                        bitrate=128000,
                        coding_mode="CODING_MODE_2_0",
                        sample_rate=48000,
                        spec="MPEG4"
                    )
                )
            ),
            medialive.CfnChannel.AudioDescriptionProperty(
                name="audio_surround",
                audio_selector_name="default",
                audio_type_control="FOLLOW_INPUT",
                language_code_control="FOLLOW_INPUT",
                codec_settings=medialive.CfnChannel.AudioCodecSettingsProperty(
                    aac_settings=medialive.CfnChannel.AacSettingsProperty(
                        bitrate=256000,
                        coding_mode="CODING_MODE_5_1",
                        sample_rate=48000,
                        spec="MPEG4"
                    )
                )
            )
        ]

        # Create destinations for MediaPackage and S3 archive
        destinations = [
            medialive.CfnChannel.OutputDestinationProperty(
                id="mediapackage-destination",
                media_package_settings=[
                    medialive.CfnChannel.MediaPackageOutputDestinationSettingsProperty(
                        channel_id=self.mediapackage_channel.id
                    )
                ]
            )
        ]

        # Add S3 archive destination if enabled
        if self.archive_content:
            destinations.append(
                medialive.CfnChannel.OutputDestinationProperty(
                    id="s3-archive-destination",
                    s3_settings=[
                        medialive.CfnChannel.S3OutputSettingsProperty(
                            bucket_name=self.content_bucket.bucket_name,
                            file_name_prefix="archives/",
                            role_arn=self.medialive_role.role_arn
                        )
                    ]
                )
            )

        # Create output groups for MediaPackage adaptive bitrate streaming
        output_groups = [
            medialive.CfnChannel.OutputGroupProperty(
                name="MediaPackage-ABR",
                output_group_settings=medialive.CfnChannel.OutputGroupSettingsProperty(
                    media_package_group_settings=medialive.CfnChannel.MediaPackageGroupSettingsProperty(
                        destination=medialive.CfnChannel.OutputLocationRefProperty(
                            destination_ref_id="mediapackage-destination"
                        )
                    )
                ),
                outputs=[
                    medialive.CfnChannel.OutputProperty(
                        output_name="4K-UHD",
                        video_description_name="video_2160p",
                        audio_description_names=["audio_surround"],
                        output_settings=medialive.CfnChannel.OutputSettingsProperty(
                            media_package_output_settings=medialive.CfnChannel.MediaPackageOutputSettingsProperty()
                        )
                    ),
                    medialive.CfnChannel.OutputProperty(
                        output_name="1080p-HD",
                        video_description_name="video_1080p",
                        audio_description_names=["audio_stereo"],
                        output_settings=medialive.CfnChannel.OutputSettingsProperty(
                            media_package_output_settings=medialive.CfnChannel.MediaPackageOutputSettingsProperty()
                        )
                    ),
                    medialive.CfnChannel.OutputProperty(
                        output_name="720p-HD",
                        video_description_name="video_720p",
                        audio_description_names=["audio_stereo"],
                        output_settings=medialive.CfnChannel.OutputSettingsProperty(
                            media_package_output_settings=medialive.CfnChannel.MediaPackageOutputSettingsProperty()
                        )
                    ),
                    medialive.CfnChannel.OutputProperty(
                        output_name="480p-SD",
                        video_description_name="video_480p",
                        audio_description_names=["audio_stereo"],
                        output_settings=medialive.CfnChannel.OutputSettingsProperty(
                            media_package_output_settings=medialive.CfnChannel.MediaPackageOutputSettingsProperty()
                        )
                    ),
                    medialive.CfnChannel.OutputProperty(
                        output_name="240p-Mobile",
                        video_description_name="video_240p",
                        audio_description_names=["audio_stereo"],
                        output_settings=medialive.CfnChannel.OutputSettingsProperty(
                            media_package_output_settings=medialive.CfnChannel.MediaPackageOutputSettingsProperty()
                        )
                    )
                ]
            )
        ]

        # Add S3 archive output group if enabled
        if self.archive_content:
            output_groups.append(
                medialive.CfnChannel.OutputGroupProperty(
                    name="S3-Archive",
                    output_group_settings=medialive.CfnChannel.OutputGroupSettingsProperty(
                        archive_group_settings=medialive.CfnChannel.ArchiveGroupSettingsProperty(
                            destination=medialive.CfnChannel.OutputLocationRefProperty(
                                destination_ref_id="s3-archive-destination"
                            ),
                            rollover_interval=3600
                        )
                    ),
                    outputs=[
                        medialive.CfnChannel.OutputProperty(
                            output_name="archive-source",
                            video_description_name="video_1080p",
                            audio_description_names=["audio_stereo"],
                            output_settings=medialive.CfnChannel.OutputSettingsProperty(
                                archive_output_settings=medialive.CfnChannel.ArchiveOutputSettingsProperty(
                                    name_modifier="-archive",
                                    extension="m2ts"
                                )
                            )
                        )
                    ]
                )
            )

        # Create the MediaLive channel
        self.medialive_channel = medialive.CfnChannel(
            self,
            "MediaLiveChannel",
            name=f"{self.platform_name}-live-channel",
            role_arn=self.medialive_role.role_arn,
            input_specification=medialive.CfnChannel.InputSpecificationProperty(
                codec="AVC",
                resolution="HD",
                maximum_bitrate="MAX_50_MBPS"
            ),
            input_attachments=[
                medialive.CfnChannel.InputAttachmentProperty(
                    input_id=self.rtmp_input.ref,
                    input_attachment_name="primary-rtmp",
                    input_settings=medialive.CfnChannel.InputSettingsProperty(
                        source_end_behavior="CONTINUE",
                        input_filter="AUTO",
                        filter_strength=1,
                        deblock_filter="ENABLED",
                        denoise_filter="ENABLED"
                    )
                ),
                medialive.CfnChannel.InputAttachmentProperty(
                    input_id=self.hls_input.ref,
                    input_attachment_name="backup-hls",
                    input_settings=medialive.CfnChannel.InputSettingsProperty(
                        source_end_behavior="CONTINUE",
                        input_filter="AUTO",
                        filter_strength=1
                    )
                )
            ],
            destinations=destinations,
            encoder_settings=medialive.CfnChannel.EncoderSettingsProperty(
                audio_descriptions=audio_descriptions,
                video_descriptions=video_descriptions,
                output_groups=output_groups,
                timecode_config=medialive.CfnChannel.TimecodeConfigProperty(
                    source="EMBEDDED"
                ),
                caption_descriptions=[
                    medialive.CfnChannel.CaptionDescriptionProperty(
                        caption_selector_name="default",
                        name="captions",
                        language_code="en",
                        language_description="English"
                    )
                ]
            ),
            tags={
                "Environment": "Production",
                "Service": "StreamingPlatform",
                "Component": "MediaLive",
                "Platform": self.platform_name
            }
        )

    def _create_cloudfront_distribution(self) -> None:
        """Create CloudFront distribution with optimized caching for streaming"""
        
        # Create CloudFront distribution for global content delivery
        self.cloudfront_distribution = cloudfront.Distribution(
            self,
            "StreamingDistribution",
            comment=f"Enterprise Video Streaming Platform Distribution - {self.platform_name}",
            default_behavior=cloudfront.BehaviorOptions(
                origin=origins.HttpOrigin(
                    self.hls_endpoint.attr_url.split('/')[2],
                    origin_path=f"/{'/'.join(self.hls_endpoint.attr_url.split('/')[3:-1])}",
                    protocol_policy=cloudfront.OriginProtocolPolicy.HTTPS_ONLY,
                    custom_headers={
                        "X-MediaPackage-CDNIdentifier": f"streaming-platform-{self.platform_name}"
                    }
                ),
                viewer_protocol_policy=cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                compress=True,
                allowed_methods=cloudfront.AllowedMethods.ALLOW_GET_HEAD,
                cached_methods=cloudfront.CachedMethods.CACHE_GET_HEAD,
                cache_policy=cloudfront.CachePolicy.CACHING_OPTIMIZED,
                origin_request_policy=cloudfront.OriginRequestPolicy.CORS_S3_ORIGIN
            ),
            additional_behaviors={
                # Optimized caching for video segments
                "*.ts": cloudfront.BehaviorOptions(
                    origin=origins.HttpOrigin(
                        self.hls_endpoint.attr_url.split('/')[2],
                        origin_path=f"/{'/'.join(self.hls_endpoint.attr_url.split('/')[3:-1])}",
                        protocol_policy=cloudfront.OriginProtocolPolicy.HTTPS_ONLY,
                        custom_headers={
                            "X-MediaPackage-CDNIdentifier": f"streaming-platform-{self.platform_name}"
                        }
                    ),
                    viewer_protocol_policy=cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    compress=False,
                    allowed_methods=cloudfront.AllowedMethods.ALLOW_GET_HEAD,
                    cached_methods=cloudfront.CachedMethods.CACHE_GET_HEAD,
                    cache_policy=cloudfront.CachePolicy.from_cache_policy_id(
                        self, "VideoSegmentCachePolicy", "4135ea2d-6df8-44a3-9df3-4b5a84be39ad"
                    )
                ),
                # Low TTL for manifests
                "*.m3u8": cloudfront.BehaviorOptions(
                    origin=origins.HttpOrigin(
                        self.hls_endpoint.attr_url.split('/')[2],
                        origin_path=f"/{'/'.join(self.hls_endpoint.attr_url.split('/')[3:-1])}",
                        protocol_policy=cloudfront.OriginProtocolPolicy.HTTPS_ONLY,
                        custom_headers={
                            "X-MediaPackage-CDNIdentifier": f"streaming-platform-{self.platform_name}"
                        }
                    ),
                    viewer_protocol_policy=cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    compress=True,
                    allowed_methods=cloudfront.AllowedMethods.ALLOW_GET_HEAD,
                    cached_methods=cloudfront.CachedMethods.CACHE_GET_HEAD,
                    cache_policy=cloudfront.CachePolicy.from_cache_policy_id(
                        self, "ManifestCachePolicy", "4135ea2d-6df8-44a3-9df3-4b5a84be39ad"
                    )
                )
            },
            price_class=cloudfront.PriceClass.PRICE_CLASS_ALL,
            enable_ipv6=True,
            http_version=cloudfront.HttpVersion.HTTP2,
            minimum_protocol_version=cloudfront.SecurityPolicyProtocol.TLS_V1_2_2021
        )

        # Add DASH endpoint behavior if DRM is enabled
        if self.enable_drm and hasattr(self, 'dash_endpoint'):
            # Note: Additional behaviors would need to be added through CloudFormation
            # overrides or custom resources for complex routing
            pass

    def _create_monitoring_and_alerts(self) -> None:
        """Create comprehensive monitoring and alerting for the platform"""
        
        # SNS topic for alerts
        self.alert_topic = sns.Topic(
            self,
            "StreamingAlerts",
            topic_name=f"streaming-platform-alerts-{self.platform_name}",
            display_name=f"Streaming Platform Alerts - {self.platform_name}"
        )

        # MediaLive input loss alarm
        medialive_input_alarm = cloudwatch.Alarm(
            self,
            "MediaLiveInputLossAlarm",
            alarm_name=f"MediaLive-{self.platform_name}-InputLoss",
            alarm_description="MediaLive channel input loss detection",
            metric=cloudwatch.Metric(
                namespace="AWS/MediaLive",
                metric_name="InputVideoFreeze",
                dimensions_map={
                    "ChannelId": self.medialive_channel.ref
                },
                statistic="Maximum",
                period=Duration.minutes(1)
            ),
            threshold=0.5,
            comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            evaluation_periods=2,
            treat_missing_data=cloudwatch.TreatMissingData.BREACHING
        )

        medialive_input_alarm.add_alarm_action(
            cw_actions.SnsAction(self.alert_topic)
        )

        # MediaPackage egress error alarm
        mediapackage_egress_alarm = cloudwatch.Alarm(
            self,
            "MediaPackageEgressAlarm",
            alarm_name=f"MediaPackage-{self.platform_name}-EgressErrors",
            alarm_description="MediaPackage egress error detection",
            metric=cloudwatch.Metric(
                namespace="AWS/MediaPackage",
                metric_name="EgressRequestCount",
                dimensions_map={
                    "Channel": self.mediapackage_channel.id
                },
                statistic="Sum",
                period=Duration.minutes(5)
            ),
            threshold=100,
            comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            evaluation_periods=2
        )

        mediapackage_egress_alarm.add_alarm_action(
            cw_actions.SnsAction(self.alert_topic)
        )

        # CloudFront error rate alarm
        cloudfront_error_alarm = cloudwatch.Alarm(
            self,
            "CloudFrontErrorAlarm",
            alarm_name=f"CloudFront-{self.platform_name}-ErrorRate",
            alarm_description="CloudFront 4xx/5xx error rate monitoring",
            metric=cloudwatch.Metric(
                namespace="AWS/CloudFront",
                metric_name="4xxErrorRate",
                dimensions_map={
                    "DistributionId": self.cloudfront_distribution.distribution_id
                },
                statistic="Average",
                period=Duration.minutes(5)
            ),
            threshold=5,
            comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            evaluation_periods=2
        )

        cloudfront_error_alarm.add_alarm_action(
            cw_actions.SnsAction(self.alert_topic)
        )

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs for important resource information"""
        
        # RTMP input URLs
        CfnOutput(
            self,
            "RTMPPrimaryURL",
            value=self.rtmp_input.attr_destinations[0]['url'],
            description="Primary RTMP input URL for live streaming"
        )

        CfnOutput(
            self,
            "RTMPBackupURL",
            value=self.rtmp_input.attr_destinations[1]['url'],
            description="Backup RTMP input URL for live streaming"
        )

        # MediaPackage endpoints
        CfnOutput(
            self,
            "HLSEndpointURL",
            value=self.hls_endpoint.attr_url,
            description="HLS adaptive bitrate streaming endpoint"
        )

        if self.enable_drm and hasattr(self, 'dash_endpoint'):
            CfnOutput(
                self,
                "DASHEndpointURL",
                value=self.dash_endpoint.attr_url,
                description="DASH streaming endpoint with DRM support"
            )

        if self.enable_low_latency and hasattr(self, 'cmaf_endpoint'):
            CfnOutput(
                self,
                "CMAFEndpointURL",
                value=self.cmaf_endpoint.attr_url,
                description="CMAF low-latency streaming endpoint"
            )

        # CloudFront distribution
        CfnOutput(
            self,
            "CloudFrontDomainName",
            value=self.cloudfront_distribution.distribution_domain_name,
            description="CloudFront distribution domain name"
        )

        CfnOutput(
            self,
            "HLSPlaybackURL",
            value=f"https://{self.cloudfront_distribution.distribution_domain_name}/out/v1/master.m3u8",
            description="HLS playback URL via CloudFront"
        )

        # Platform information
        CfnOutput(
            self,
            "MediaLiveChannelId",
            value=self.medialive_channel.ref,
            description="MediaLive channel ID"
        )

        CfnOutput(
            self,
            "MediaPackageChannelId",
            value=self.mediapackage_channel.id,
            description="MediaPackage channel ID"
        )

        CfnOutput(
            self,
            "ContentBucketName",
            value=self.content_bucket.bucket_name,
            description="S3 bucket for content storage and archiving"
        )

        CfnOutput(
            self,
            "AlertTopicArn",
            value=self.alert_topic.topic_arn,
            description="SNS topic ARN for platform alerts"
        )

    def _tag_resources(self) -> None:
        """Apply consistent tags to all resources in the stack"""
        
        tags_to_apply = {
            "Project": "VideoStreamingPlatform",
            "Platform": self.platform_name,
            "Environment": "Production",
            "Owner": "MediaTeam",
            "CostCenter": "Media",
            "Backup": "Required" if self.archive_content else "NotRequired",
            "Monitoring": "Enabled",
            "DRM": "Enabled" if self.enable_drm else "Disabled",
            "LowLatency": "Enabled" if self.enable_low_latency else "Disabled"
        }

        for tag_key, tag_value in tags_to_apply.items():
            Tags.of(self).add(tag_key, tag_value)


def main():
    """Main function to create and deploy the CDK application"""
    
    app = App()

    # Get configuration from CDK context or environment variables
    platform_name = app.node.try_get_context("platform_name") or os.getenv("PLATFORM_NAME", "enterprise-streaming")
    enable_drm = app.node.try_get_context("enable_drm") or os.getenv("ENABLE_DRM", "true").lower() == "true"
    enable_low_latency = app.node.try_get_context("enable_low_latency") or os.getenv("ENABLE_LOW_LATENCY", "true").lower() == "true"
    archive_content = app.node.try_get_context("archive_content") or os.getenv("ARCHIVE_CONTENT", "true").lower() == "true"

    # Create the stack
    VideoStreamingPlatformStack(
        app,
        "VideoStreamingPlatformStack",
        platform_name=platform_name,
        enable_drm=enable_drm,
        enable_low_latency=enable_low_latency,
        archive_content=archive_content,
        env=Environment(
            account=os.getenv("CDK_DEFAULT_ACCOUNT"),
            region=os.getenv("CDK_DEFAULT_REGION", "us-east-1")
        ),
        description=f"Enterprise Video Streaming Platform - {platform_name}",
    )

    app.synth()


if __name__ == "__main__":
    main()