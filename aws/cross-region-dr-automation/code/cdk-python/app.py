#!/usr/bin/env python3
"""
AWS CDK Python Application for Cross-Region Disaster Recovery Automation
with AWS Elastic Disaster Recovery (DRS)

This CDK application deploys a comprehensive disaster recovery solution using
AWS Elastic Disaster Recovery with automated failover, monitoring, and testing
capabilities across multiple regions.

Author: Generated by AWS Recipe CDK Generator
"""

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Duration,
    RemovalPolicy,
    aws_iam as iam,
    aws_lambda as lambda_,
    aws_stepfunctions as sfn,
    aws_stepfunctions_tasks as sfn_tasks,
    aws_sns as sns,
    aws_sns_subscriptions as sns_subscriptions,
    aws_cloudwatch as cloudwatch,
    aws_cloudwatch_actions as cw_actions,
    aws_events as events,
    aws_events_targets as events_targets,
    aws_ec2 as ec2,
    aws_route53 as route53,
    aws_logs as logs,
    aws_ssm as ssm,
)
from constructs import Construct
from typing import Dict, List, Optional
import json


class DisasterRecoveryVPCStack(Stack):
    """
    Stack for creating the Disaster Recovery VPC infrastructure
    in the DR region with proper networking and security configurations.
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        dr_region: str,
        project_id: str,
        **kwargs
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        self.dr_region = dr_region
        self.project_id = project_id

        # Create VPC for Disaster Recovery
        self.dr_vpc = ec2.Vpc(
            self,
            "DisasterRecoveryVPC",
            vpc_name=f"disaster-recovery-vpc-{project_id}",
            ip_addresses=ec2.IpAddresses.cidr("10.100.0.0/16"),
            max_azs=2,
            nat_gateways=1,
            subnet_configuration=[
                ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.PUBLIC,
                    name="DR-Public",
                    cidr_mask=24,
                ),
                ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS,
                    name="DR-Private",
                    cidr_mask=24,
                ),
            ],
            enable_dns_hostnames=True,
            enable_dns_support=True,
        )

        # Security Group for DRS Replication Servers
        self.drs_security_group = ec2.SecurityGroup(
            self,
            "DRSSecurityGroup",
            vpc=self.dr_vpc,
            description="Security group for DRS replication servers",
            security_group_name=f"drs-replication-sg-{project_id}",
        )

        # Allow inbound traffic for DRS replication
        self.drs_security_group.add_ingress_rule(
            peer=ec2.Peer.any_ipv4(),
            connection=ec2.Port.tcp(443),
            description="HTTPS for DRS replication",
        )

        self.drs_security_group.add_ingress_rule(
            peer=ec2.Peer.any_ipv4(),
            connection=ec2.Port.tcp_range(1500, 1504),
            description="DRS replication data transfer",
        )

        # Tags for all resources
        cdk.Tags.of(self).add("Project", f"enterprise-dr-{project_id}")
        cdk.Tags.of(self).add("Purpose", "DisasterRecovery")
        cdk.Tags.of(self).add("Environment", "DR")


class DisasterRecoveryAutomationStack(Stack):
    """
    Main stack for disaster recovery automation including Lambda functions,
    Step Functions workflows, CloudWatch monitoring, and SNS notifications.
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        primary_region: str,
        dr_region: str,
        project_id: str,
        admin_email: str,
        dr_vpc_stack: Optional[DisasterRecoveryVPCStack] = None,
        **kwargs
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        self.primary_region = primary_region
        self.dr_region = dr_region
        self.project_id = project_id
        self.admin_email = admin_email
        self.dr_vpc_stack = dr_vpc_stack

        # Create IAM role for disaster recovery automation
        self._create_automation_role()

        # Create SNS topic for alerts
        self._create_sns_notifications()

        # Create Lambda functions
        self._create_failover_lambda()
        self._create_testing_lambda()
        self._create_failback_lambda()

        # Create Step Functions state machine
        self._create_step_functions_workflow()

        # Create CloudWatch monitoring
        self._create_cloudwatch_monitoring()

        # Create scheduled testing
        self._create_scheduled_testing()

        # Create Systems Manager documents
        self._create_ssm_documents()

        # Tags for all resources
        cdk.Tags.of(self).add("Project", f"enterprise-dr-{project_id}")
        cdk.Tags.of(self).add("Purpose", "DisasterRecoveryAutomation")

    def _create_automation_role(self) -> None:
        """Create IAM role for disaster recovery automation with necessary permissions."""
        self.automation_role = iam.Role(
            self,
            "DRAutomationRole",
            role_name=f"DRAutomationRole-{self.project_id}",
            assumed_by=iam.CompositePrincipal(
                iam.ServicePrincipal("lambda.amazonaws.com"),
                iam.ServicePrincipal("states.amazonaws.com"),
                iam.ServicePrincipal("ssm.amazonaws.com"),
            ),
            description="Role for disaster recovery automation operations",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                ),
            ],
        )

        # Custom policy for DRS and related services
        dr_automation_policy = iam.PolicyDocument(
            statements=[
                iam.PolicyStatement(
                    effect=iam.Effect.ALLOW,
                    actions=[
                        "drs:*",
                        "ec2:Describe*",
                        "ec2:CreateTags",
                        "ec2:StartInstances",
                        "ec2:StopInstances",
                        "ec2:TerminateInstances",
                        "iam:PassRole",
                        "route53:*",
                        "sns:Publish",
                        "ssm:*",
                        "lambda:InvokeFunction",
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents",
                        "cloudwatch:PutMetricData",
                        "cloudwatch:GetMetricStatistics",
                        "events:PutEvents",
                    ],
                    resources=["*"],
                ),
            ]
        )

        iam.Policy(
            self,
            "DRAutomationPolicy",
            policy_name="DRAutomationPolicy",
            policy_document=dr_automation_policy,
            roles=[self.automation_role],
        )

    def _create_sns_notifications(self) -> None:
        """Create SNS topic and subscription for disaster recovery alerts."""
        self.dr_sns_topic = sns.Topic(
            self,
            "DRAlertsTopic",
            topic_name=f"dr-alerts-{self.project_id}",
            display_name="Disaster Recovery Alerts",
            description="SNS topic for disaster recovery notifications",
        )

        # Add email subscription
        self.dr_sns_topic.add_subscription(
            sns_subscriptions.EmailSubscription(self.admin_email)
        )

    def _create_failover_lambda(self) -> None:
        """Create Lambda function for automated failover operations."""
        failover_code = f"""
import json
import boto3
import os
from datetime import datetime
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    \"\"\"
    Automated failover function for AWS Elastic Disaster Recovery.
    Initiates recovery jobs and updates DNS records for failover.
    \"\"\"
    try:
        drs_client = boto3.client('drs', region_name=os.environ['DR_REGION'])
        route53_client = boto3.client('route53')
        sns_client = boto3.client('sns')
        
        logger.info("Starting automated failover process")
        
        # Get source servers for recovery
        response = drs_client.describe_source_servers()
        source_servers = response.get('sourceServers', [])
        
        if not source_servers:
            logger.warning("No source servers found for recovery")
            return {{
                'statusCode': 200,
                'body': json.dumps({{'message': 'No source servers available for recovery'}})
            }}
        
        recovery_jobs = []
        
        # Start recovery jobs for each source server
        for server in source_servers:
            if server.get('sourceServerID'):
                try:
                    job_response = drs_client.start_recovery(
                        sourceServers=[{{
                            'sourceServerID': server['sourceServerID'],
                            'recoverySnapshotID': 'LATEST'
                        }}],
                        tags={{
                            'Purpose': 'AutomatedDR',
                            'Timestamp': datetime.utcnow().isoformat(),
                            'Project': 'enterprise-dr-{self.project_id}'
                        }}
                    )
                    recovery_jobs.append(job_response['job']['jobID'])
                    logger.info(f"Started recovery job for server {{server['sourceServerID']}}")
                except Exception as e:
                    logger.error(f"Failed to start recovery for server {{server['sourceServerID']}}: {{str(e)}}")
        
        # Update Route 53 records for failover (example implementation)
        try:
            hosted_zones = route53_client.list_hosted_zones()
            for zone in hosted_zones['HostedZones']:
                if 'example.com' in zone['Name']:  # Replace with your domain
                    route53_client.change_resource_record_sets(
                        HostedZoneId=zone['Id'],
                        ChangeBatch={{
                            'Changes': [{{
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {{
                                    'Name': f"app.{{zone['Name']}}",
                                    'Type': 'A',
                                    'SetIdentifier': 'DR-Failover',
                                    'Failover': 'SECONDARY',
                                    'TTL': 60,
                                    'ResourceRecords': [{{'Value': '10.100.1.100'}}]  # DR IP
                                }}
                            }}]
                        }}
                    )
                    logger.info(f"Updated DNS records for zone {{zone['Name']}}")
        except Exception as e:
            logger.error(f"Failed to update DNS records: {{str(e)}}")
        
        # Send notification
        message = f'Automated DR failover initiated successfully. Recovery jobs: {{recovery_jobs}}'
        sns_client.publish(
            TopicArn=os.environ['SNS_TOPIC_ARN'],
            Message=message,
            Subject='DR Failover Activated'
        )
        
        logger.info("Automated failover process completed successfully")
        
        return {{
            'statusCode': 200,
            'body': json.dumps({{
                'message': 'Failover initiated successfully',
                'recoveryJobs': recovery_jobs,
                'timestamp': datetime.utcnow().isoformat()
            }})
        }}
        
    except Exception as e:
        error_message = f'DR failover failed: {{str(e)}}'
        logger.error(error_message)
        
        # Send failure notification
        try:
            sns_client = boto3.client('sns')
            sns_client.publish(
                TopicArn=os.environ['SNS_TOPIC_ARN'],
                Message=error_message,
                Subject='DR Failover Failed'
            )
        except:
            pass
        
        return {{
            'statusCode': 500,
            'body': json.dumps({{'error': str(e)}})
        }}
        """

        self.failover_lambda = lambda_.Function(
            self,
            "AutomatedFailoverFunction",
            function_name=f"dr-automated-failover-{self.project_id}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(failover_code),
            timeout=Duration.minutes(5),
            role=self.automation_role,
            environment={
                "DR_REGION": self.dr_region,
                "SNS_TOPIC_ARN": self.dr_sns_topic.topic_arn,
                "PROJECT_ID": self.project_id,
            },
            description="Automated disaster recovery failover function",
            log_retention=logs.RetentionDays.ONE_MONTH,
        )

    def _create_testing_lambda(self) -> None:
        """Create Lambda function for automated DR testing and drills."""
        testing_code = f"""
import json
import boto3
import os
from datetime import datetime, timedelta
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    \"\"\"
    Automated DR testing function that initiates drill recoveries
    to validate disaster recovery procedures without affecting production.
    \"\"\"
    try:
        drs_client = boto3.client('drs', region_name=os.environ['DR_REGION'])
        ssm_client = boto3.client('ssm', region_name=os.environ['DR_REGION'])
        sns_client = boto3.client('sns')
        
        logger.info("Starting automated DR drill")
        
        # Get source servers for drill
        response = drs_client.describe_source_servers()
        source_servers = response.get('sourceServers', [])
        
        if not source_servers:
            logger.warning("No source servers found for drill")
            return {{
                'statusCode': 200,
                'body': json.dumps({{'message': 'No source servers available for drill'}})
            }}
        
        drill_jobs = []
        
        # Start drill jobs for each source server
        for server in source_servers:
            if server.get('sourceServerID'):
                try:
                    job_response = drs_client.start_recovery(
                        sourceServers=[{{
                            'sourceServerID': server['sourceServerID'],
                            'recoverySnapshotID': 'LATEST'
                        }}],
                        isDrill=True,
                        tags={{
                            'Purpose': 'DR-Drill',
                            'Timestamp': datetime.utcnow().isoformat(),
                            'Project': 'enterprise-dr-{self.project_id}'
                        }}
                    )
                    drill_jobs.append(job_response['job']['jobID'])
                    logger.info(f"Started drill job for server {{server['sourceServerID']}}")
                except Exception as e:
                    logger.error(f"Failed to start drill for server {{server['sourceServerID']}}: {{str(e)}}")
        
        # Schedule automatic cleanup (2 hours from now)
        cleanup_time = datetime.utcnow() + timedelta(hours=2)
        
        # Send notification about drill initiation
        message = f'Automated DR drill initiated successfully. Drill jobs: {{drill_jobs}}. Cleanup scheduled for {{cleanup_time.isoformat()}} UTC.'
        sns_client.publish(
            TopicArn=os.environ['SNS_TOPIC_ARN'],
            Message=message,
            Subject='DR Drill Initiated'
        )
        
        logger.info("Automated DR drill process completed successfully")
        
        return {{
            'statusCode': 200,
            'body': json.dumps({{
                'message': 'DR drill initiated successfully',
                'drillJobs': drill_jobs,
                'cleanupScheduled': cleanup_time.isoformat(),
                'timestamp': datetime.utcnow().isoformat()
            }})
        }}
        
    except Exception as e:
        error_message = f'DR drill failed: {{str(e)}}'
        logger.error(error_message)
        
        # Send failure notification
        try:
            sns_client = boto3.client('sns')
            sns_client.publish(
                TopicArn=os.environ['SNS_TOPIC_ARN'],
                Message=error_message,
                Subject='DR Drill Failed'
            )
        except:
            pass
        
        return {{
            'statusCode': 500,
            'body': json.dumps({{'error': str(e)}})
        }}
        """

        self.testing_lambda = lambda_.Function(
            self,
            "DRTestingFunction",
            function_name=f"dr-testing-{self.project_id}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(testing_code),
            timeout=Duration.minutes(5),
            role=self.automation_role,
            environment={
                "DR_REGION": self.dr_region,
                "SNS_TOPIC_ARN": self.dr_sns_topic.topic_arn,
                "PROJECT_ID": self.project_id,
            },
            description="Automated disaster recovery testing function",
            log_retention=logs.RetentionDays.ONE_MONTH,
        )

    def _create_failback_lambda(self) -> None:
        """Create Lambda function for automated failback operations."""
        failback_code = f"""
import json
import boto3
import os
from datetime import datetime
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    \"\"\"
    Automated failback function for returning operations to the primary region
    after disaster recovery events have been resolved.
    \"\"\"
    try:
        drs_client = boto3.client('drs', region_name=os.environ['PRIMARY_REGION'])
        route53_client = boto3.client('route53')
        sns_client = boto3.client('sns')
        
        logger.info("Starting automated failback process")
        
        # Get recovery instances for failback
        response = drs_client.describe_recovery_instances()
        recovery_instances = response.get('recoveryInstances', [])
        
        if not recovery_instances:
            logger.warning("No recovery instances found for failback")
            return {{
                'statusCode': 200,
                'body': json.dumps({{'message': 'No recovery instances available for failback'}})
            }}
        
        failback_jobs = []
        
        # Start failback jobs for each recovery instance
        for instance in recovery_instances:
            if instance.get('recoveryInstanceID'):
                try:
                    job_response = drs_client.start_failback_launch(
                        recoveryInstanceIDs=[instance['recoveryInstanceID']],
                        tags={{
                            'Purpose': 'AutomatedFailback',
                            'Timestamp': datetime.utcnow().isoformat(),
                            'Project': 'enterprise-dr-{self.project_id}'
                        }}
                    )
                    failback_jobs.append(job_response['job']['jobID'])
                    logger.info(f"Started failback job for instance {{instance['recoveryInstanceID']}}")
                except Exception as e:
                    logger.error(f"Failed to start failback for instance {{instance['recoveryInstanceID']}}: {{str(e)}}")
        
        # Update Route 53 records back to primary
        try:
            hosted_zones = route53_client.list_hosted_zones()
            for zone in hosted_zones['HostedZones']:
                if 'example.com' in zone['Name']:  # Replace with your domain
                    route53_client.change_resource_record_sets(
                        HostedZoneId=zone['Id'],
                        ChangeBatch={{
                            'Changes': [{{
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {{
                                    'Name': f"app.{{zone['Name']}}",
                                    'Type': 'A',
                                    'SetIdentifier': 'Primary',
                                    'Failover': 'PRIMARY',
                                    'TTL': 60,
                                    'ResourceRecords': [{{'Value': '10.0.1.100'}}]  # Primary IP
                                }}
                            }}]
                        }}
                    )
                    logger.info(f"Updated DNS records back to primary for zone {{zone['Name']}}")
        except Exception as e:
            logger.error(f"Failed to update DNS records: {{str(e)}}")
        
        # Send notification
        message = f'Automated failback initiated successfully. Failback jobs: {{failback_jobs}}'
        sns_client.publish(
            TopicArn=os.environ['SNS_TOPIC_ARN'],
            Message=message,
            Subject='DR Failback Initiated'
        )
        
        logger.info("Automated failback process completed successfully")
        
        return {{
            'statusCode': 200,
            'body': json.dumps({{
                'message': 'Failback initiated successfully',
                'failbackJobs': failback_jobs,
                'timestamp': datetime.utcnow().isoformat()
            }})
        }}
        
    except Exception as e:
        error_message = f'DR failback failed: {{str(e)}}'
        logger.error(error_message)
        
        # Send failure notification
        try:
            sns_client = boto3.client('sns')
            sns_client.publish(
                TopicArn=os.environ['SNS_TOPIC_ARN'],
                Message=error_message,
                Subject='DR Failback Failed'
            )
        except:
            pass
        
        return {{
            'statusCode': 500,
            'body': json.dumps({{'error': str(e)}})
        }}
        """

        self.failback_lambda = lambda_.Function(
            self,
            "AutomatedFailbackFunction",
            function_name=f"dr-automated-failback-{self.project_id}",
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(failback_code),
            timeout=Duration.minutes(5),
            role=self.automation_role,
            environment={
                "PRIMARY_REGION": self.primary_region,
                "SNS_TOPIC_ARN": self.dr_sns_topic.topic_arn,
                "PROJECT_ID": self.project_id,
            },
            description="Automated disaster recovery failback function",
            log_retention=logs.RetentionDays.ONE_MONTH,
        )

    def _create_step_functions_workflow(self) -> None:
        """Create Step Functions state machine for DR orchestration."""
        # Define the Step Functions workflow
        validate_source_servers = sfn_tasks.CallAwsService(
            self,
            "ValidateSourceServers",
            service="drs",
            action="describeSourceServers",
            iam_resources=["*"],
            result_path="$.sourceServers",
        )

        check_replication_status = sfn_tasks.CallAwsService(
            self,
            "CheckReplicationStatus",
            service="drs",
            action="describeSourceServers",
            iam_resources=["*"],
            result_path="$.replicationStatus",
        )

        initiate_recovery = sfn_tasks.LambdaInvoke(
            self,
            "InitiateRecovery",
            lambda_function=self.failover_lambda,
            result_path="$.recoveryResult",
        )

        monitor_recovery_jobs = sfn_tasks.CallAwsService(
            self,
            "MonitorRecoveryJobs",
            service="drs",
            action="describeJobs",
            iam_resources=["*"],
            result_path="$.jobStatus",
        )

        wait_for_completion = sfn.Wait(
            self,
            "WaitForCompletion",
            time=sfn.WaitTime.duration(Duration.seconds(30)),
        )

        notify_success = sfn_tasks.SnsPublish(
            self,
            "NotifySuccess",
            topic=self.dr_sns_topic,
            message=sfn.TaskInput.from_text("Disaster recovery completed successfully"),
            subject="DR Operation Successful",
        )

        notify_failure = sfn_tasks.SnsPublish(
            self,
            "NotifyFailure",
            topic=self.dr_sns_topic,
            message=sfn.TaskInput.from_text("Disaster recovery failed"),
            subject="DR Operation Failed",
        )

        # Define the workflow
        check_job_status = sfn.Choice(self, "CheckJobStatus")
        check_job_status.when(
            sfn.Condition.string_equals("$.jobStatus.jobs[0].status", "COMPLETED"),
            notify_success,
        ).when(
            sfn.Condition.string_equals("$.jobStatus.jobs[0].status", "FAILED"),
            notify_failure,
        ).otherwise(wait_for_completion.next(monitor_recovery_jobs))

        definition = (
            validate_source_servers
            .next(check_replication_status)
            .next(initiate_recovery)
            .next(monitor_recovery_jobs)
            .next(check_job_status)
        )

        self.dr_state_machine = sfn.StateMachine(
            self,
            "DROrchestrationStateMachine",
            state_machine_name=f"dr-orchestration-{self.project_id}",
            definition=definition,
            role=self.automation_role,
            timeout=Duration.hours(2),
        )

    def _create_cloudwatch_monitoring(self) -> None:
        """Create CloudWatch alarms and dashboard for DR monitoring."""
        # Application health alarm
        application_health_alarm = cloudwatch.Alarm(
            self,
            "ApplicationHealthAlarm",
            alarm_name=f"Application-Health-{self.project_id}",
            alarm_description="Monitor application health for DR trigger",
            metric=cloudwatch.Metric(
                namespace="AWS/Route53",
                metric_name="HealthCheckStatus",
                statistic="Minimum",
            ),
            threshold=1,
            comparison_operator=cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,
            evaluation_periods=3,
            datapoints_to_alarm=3,
            treat_missing_data=cloudwatch.TreatMissingData.BREACHING,
        )

        application_health_alarm.add_alarm_action(
            cw_actions.SnsAction(self.dr_sns_topic)
        )

        # DRS replication lag alarm
        replication_lag_alarm = cloudwatch.Alarm(
            self,
            "DRSReplicationLagAlarm",
            alarm_name=f"DRS-Replication-Lag-{self.project_id}",
            alarm_description="Monitor DRS replication lag",
            metric=cloudwatch.Metric(
                namespace="Custom/DRS",
                metric_name="ReplicationLag",
                statistic="Average",
            ),
            threshold=300,
            comparison_operator=cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
            evaluation_periods=2,
            datapoints_to_alarm=2,
        )

        replication_lag_alarm.add_alarm_action(
            cw_actions.SnsAction(self.dr_sns_topic)
        )

        # CloudWatch Dashboard
        dashboard = cloudwatch.Dashboard(
            self,
            "DRMonitoringDashboard",
            dashboard_name=f"DR-Monitoring-{self.project_id}",
        )

        # Add widgets to dashboard
        dashboard.add_widgets(
            cloudwatch.GraphWidget(
                title="DRS Replication Metrics",
                left=[
                    cloudwatch.Metric(
                        namespace="AWS/DRS",
                        metric_name="ReplicationLag",
                        statistic="Average",
                    ),
                    cloudwatch.Metric(
                        namespace="AWS/DRS",
                        metric_name="ReplicationStatus",
                        statistic="Average",
                    ),
                ],
                width=12,
                height=6,
            ),
            cloudwatch.LogQueryWidget(
                title="DR Automation Logs",
                log_groups=[self.failover_lambda.log_group],
                query_lines=[
                    "fields @timestamp, @message",
                    "sort @timestamp desc",
                    "limit 20",
                ],
                width=12,
                height=6,
            ),
        )

    def _create_scheduled_testing(self) -> None:
        """Create EventBridge rule for scheduled DR testing."""
        # Monthly DR drill schedule
        monthly_drill_rule = events.Rule(
            self,
            "MonthlyDRDrillRule",
            rule_name=f"monthly-dr-drill-{self.project_id}",
            description="Monthly automated DR drill",
            schedule=events.Schedule.rate(Duration.days(30)),
        )

        monthly_drill_rule.add_target(
            events_targets.LambdaFunction(self.testing_lambda)
        )

        # Grant permission for EventBridge to invoke Lambda
        self.testing_lambda.add_permission(
            "AllowEventBridgeInvoke",
            principal=iam.ServicePrincipal("events.amazonaws.com"),
            source_arn=monthly_drill_rule.rule_arn,
        )

    def _create_ssm_documents(self) -> None:
        """Create Systems Manager documents for DRS agent installation."""
        # Linux agent installation document
        linux_agent_document = ssm.CfnDocument(
            self,
            "LinuxDRSAgentDocument",
            document_type="Command",
            name=f"InstallDRSAgent-Linux-{self.project_id}",
            content={
                "schemaVersion": "2.2",
                "description": "Install AWS DRS Agent on Linux servers",
                "parameters": {
                    "region": {
                        "type": "String",
                        "description": "AWS Region for DRS",
                        "default": self.primary_region,
                    }
                },
                "mainSteps": [
                    {
                        "action": "aws:runShellScript",
                        "name": "installDRSAgent",
                        "inputs": {
                            "runCommand": [
                                "#!/bin/bash",
                                "set -e",
                                f"AWS_REGION={{{{region}}}}",
                                "echo 'Installing AWS DRS Agent...'",
                                "# Download DRS agent",
                                "if [ -f /etc/redhat-release ]; then",
                                "    sudo yum update -y",
                                "    wget https://aws-elastic-disaster-recovery-${AWS_REGION}.s3.amazonaws.com/latest/linux/aws-replication-installer-init.py",
                                "elif [ -f /etc/debian_version ]; then",
                                "    sudo apt-get update -y",
                                "    wget https://aws-elastic-disaster-recovery-${AWS_REGION}.s3.amazonaws.com/latest/linux/aws-replication-installer-init.py",
                                "fi",
                                "# Install agent",
                                "sudo python3 aws-replication-installer-init.py \\",
                                "    --region ${AWS_REGION} \\",
                                "    --aws-access-key-id ${AWS_ACCESS_KEY_ID} \\",
                                "    --aws-secret-access-key ${AWS_SECRET_ACCESS_KEY} \\",
                                "    --no-prompt",
                                "echo 'DRS Agent installation completed'",
                            ]
                        },
                    }
                ],
            },
        )

        # Windows agent installation document
        windows_agent_document = ssm.CfnDocument(
            self,
            "WindowsDRSAgentDocument",
            document_type="Command",
            name=f"InstallDRSAgent-Windows-{self.project_id}",
            content={
                "schemaVersion": "2.2",
                "description": "Install AWS DRS Agent on Windows servers",
                "parameters": {
                    "region": {
                        "type": "String",
                        "description": "AWS Region for DRS",
                        "default": self.primary_region,
                    }
                },
                "mainSteps": [
                    {
                        "action": "aws:runPowerShellScript",
                        "name": "installDRSAgent",
                        "inputs": {
                            "runCommand": [
                                "Write-Host 'Installing AWS DRS Agent for Windows...'",
                                f"$region = '{{{{region}}}}'",
                                "$installerUrl = \"https://aws-elastic-disaster-recovery-$region.s3.amazonaws.com/latest/windows/AwsReplicationWindowsInstaller.exe\"",
                                "$installerPath = \"$env:TEMP\\AwsReplicationWindowsInstaller.exe\"",
                                "Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath",
                                "Start-Process -FilePath $installerPath -ArgumentList '/S', '/v/qn' -Wait",
                                "& \"C:\\Program Files (x86)\\AWS Replication Agent\\aws-replication-installer-init.exe\" `",
                                "    --region $region `",
                                "    --aws-access-key-id $env:AWS_ACCESS_KEY_ID `",
                                "    --aws-secret-access-key $env:AWS_SECRET_ACCESS_KEY `",
                                "    --no-prompt",
                                "Write-Host 'DRS Agent installation completed'",
                            ]
                        },
                    }
                ],
            },
        )


class DisasterRecoveryApp(cdk.App):
    """
    Main CDK application for cross-region disaster recovery automation.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Configuration parameters
        primary_region = self.node.try_get_context("primaryRegion") or "us-east-1"
        dr_region = self.node.try_get_context("drRegion") or "us-west-2"
        project_id = self.node.try_get_context("projectId") or "dr-demo"
        admin_email = self.node.try_get_context("adminEmail") or "admin@example.com"
        account_id = self.node.try_get_context("account") or self.account

        # Create DR VPC stack in DR region
        dr_vpc_stack = DisasterRecoveryVPCStack(
            self,
            "DisasterRecoveryVPCStack",
            dr_region=dr_region,
            project_id=project_id,
            env=cdk.Environment(account=account_id, region=dr_region),
        )

        # Create main automation stack in primary region
        automation_stack = DisasterRecoveryAutomationStack(
            self,
            "DisasterRecoveryAutomationStack",
            primary_region=primary_region,
            dr_region=dr_region,
            project_id=project_id,
            admin_email=admin_email,
            dr_vpc_stack=dr_vpc_stack,
            env=cdk.Environment(account=account_id, region=primary_region),
        )

        # Add dependency
        automation_stack.add_dependency(dr_vpc_stack)

        # Stack outputs
        cdk.CfnOutput(
            automation_stack,
            "DRSNSTopicArn",
            description="SNS Topic ARN for DR alerts",
            value=automation_stack.dr_sns_topic.topic_arn,
        )

        cdk.CfnOutput(
            automation_stack,
            "FailoverLambdaArn",
            description="Failover Lambda Function ARN",
            value=automation_stack.failover_lambda.function_arn,
        )

        cdk.CfnOutput(
            automation_stack,
            "StateMachineArn",
            description="Step Functions State Machine ARN",
            value=automation_stack.dr_state_machine.state_machine_arn,
        )

        cdk.CfnOutput(
            dr_vpc_stack,
            "DRVPCId",
            description="Disaster Recovery VPC ID",
            value=dr_vpc_stack.dr_vpc.vpc_id,
        )

        cdk.CfnOutput(
            dr_vpc_stack,
            "DRSSecurityGroupId",
            description="DRS Security Group ID",
            value=dr_vpc_stack.drs_security_group.security_group_id,
        )


# Create the application
app = DisasterRecoveryApp()
app.synth()