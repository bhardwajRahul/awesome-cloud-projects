#!/usr/bin/env python3
"""
AWS CDK Python application for Real-Time Chat Applications with AppSync and GraphQL.

This CDK application deploys a complete real-time chat solution using:
- AWS AppSync for GraphQL API and real-time subscriptions
- Amazon DynamoDB for message and conversation storage
- Amazon Cognito for user authentication
- AWS Lambda for message processing (optional)

Author: Generated by CDK for AWS Recipe
Version: 1.0
"""

import os
from typing import Dict, Any

import aws_cdk as cdk
from aws_cdk import (
    Stack,
    Environment,
    Duration,
    RemovalPolicy,
    CfnOutput,
    aws_appsync as appsync,
    aws_dynamodb as dynamodb,
    aws_cognito as cognito,
    aws_iam as iam,
    aws_logs as logs,
)
from constructs import Construct


class RealtimeChatStack(Stack):
    """
    CDK Stack for Real-Time Chat Application infrastructure.
    
    This stack creates:
    - Cognito User Pool for authentication
    - DynamoDB tables for data storage
    - AppSync GraphQL API with real-time subscriptions
    - IAM roles and policies for secure access
    """

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Configuration parameters
        self.app_name = "realtime-chat"
        self.stage = self.node.try_get_context("stage") or "dev"
        
        # Create Cognito User Pool for authentication
        self.user_pool = self._create_user_pool()
        
        # Create DynamoDB tables for data storage
        self.tables = self._create_dynamodb_tables()
        
        # Create AppSync GraphQL API
        self.api = self._create_appsync_api()
        
        # Create IAM roles and policies
        self.service_role = self._create_service_role()
        
        # Configure data sources and resolvers
        self._configure_data_sources()
        self._configure_resolvers()
        
        # Output important values
        self._create_outputs()

    def _create_user_pool(self) -> cognito.UserPool:
        """
        Create and configure Cognito User Pool for user authentication.
        
        Returns:
            cognito.UserPool: Configured user pool with security settings
        """
        # Create user pool with secure password policy
        user_pool = cognito.UserPool(
            self,
            "ChatUserPool",
            user_pool_name=f"{self.app_name}-{self.stage}-users",
            self_sign_up_enabled=True,
            sign_in_aliases=cognito.SignInAliases(
                email=True,
                username=True
            ),
            auto_verify=cognito.AutoVerifiedAttrs(email=True),
            password_policy=cognito.PasswordPolicy(
                min_length=8,
                require_lowercase=True,
                require_uppercase=True,
                require_digits=True,
                require_symbols=False
            ),
            account_recovery=cognito.AccountRecovery.EMAIL_ONLY,
            removal_policy=RemovalPolicy.DESTROY  # For development only
        )
        
        # Add standard attributes
        user_pool.add_client(
            "ChatUserPoolClient",
            user_pool_client_name=f"{self.app_name}-{self.stage}-client",
            auth_flows=cognito.AuthFlow(
                user_password=True,
                user_srp=True,
                custom=False,
                admin_user_password=True
            ),
            generate_secret=True,
            prevent_user_existence_errors=True,
            supported_identity_providers=[
                cognito.UserPoolClientIdentityProvider.COGNITO
            ]
        )
        
        return user_pool

    def _create_dynamodb_tables(self) -> Dict[str, dynamodb.Table]:
        """
        Create DynamoDB tables for chat data storage.
        
        Returns:
            Dict[str, dynamodb.Table]: Dictionary of created tables
        """
        tables = {}
        
        # Messages table with conversation partitioning
        tables["messages"] = dynamodb.Table(
            self,
            "MessagesTable",
            table_name=f"{self.app_name}-{self.stage}-messages",
            partition_key=dynamodb.Attribute(
                name="conversationId",
                type=dynamodb.AttributeType.STRING
            ),
            sort_key=dynamodb.Attribute(
                name="messageId",
                type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY,
            point_in_time_recovery=True,
            stream=dynamodb.StreamViewType.NEW_AND_OLD_IMAGES
        )
        
        # Add GSI for time-based message queries
        tables["messages"].add_global_secondary_index(
            index_name="MessagesByTime",
            partition_key=dynamodb.Attribute(
                name="conversationId",
                type=dynamodb.AttributeType.STRING
            ),
            sort_key=dynamodb.Attribute(
                name="createdAt",
                type=dynamodb.AttributeType.STRING
            ),
            projection_type=dynamodb.ProjectionType.ALL
        )
        
        # Conversations table
        tables["conversations"] = dynamodb.Table(
            self,
            "ConversationsTable",
            table_name=f"{self.app_name}-{self.stage}-conversations",
            partition_key=dynamodb.Attribute(
                name="conversationId",
                type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY,
            point_in_time_recovery=True
        )
        
        # Add GSI for user conversation queries
        tables["conversations"].add_global_secondary_index(
            index_name="UserConversations",
            partition_key=dynamodb.Attribute(
                name="userId",
                type=dynamodb.AttributeType.STRING
            ),
            sort_key=dynamodb.Attribute(
                name="conversationId",
                type=dynamodb.AttributeType.STRING
            ),
            projection_type=dynamodb.ProjectionType.ALL
        )
        
        # Users table for profile and presence data
        tables["users"] = dynamodb.Table(
            self,
            "UsersTable",
            table_name=f"{self.app_name}-{self.stage}-users",
            partition_key=dynamodb.Attribute(
                name="userId",
                type=dynamodb.AttributeType.STRING
            ),
            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,
            removal_policy=RemovalPolicy.DESTROY,
            point_in_time_recovery=True
        )
        
        return tables

    def _create_appsync_api(self) -> appsync.GraphqlApi:
        """
        Create AppSync GraphQL API with authentication and schema.
        
        Returns:
            appsync.GraphqlApi: Configured GraphQL API
        """
        # Define GraphQL schema
        schema_definition = '''
        type Message {
            messageId: ID!
            conversationId: ID!
            userId: ID!
            content: String!
            messageType: MessageType!
            createdAt: AWSDateTime!
            updatedAt: AWSDateTime
            author: User
        }
        
        type Conversation {
            conversationId: ID!
            name: String
            participants: [ID!]!
            lastMessageAt: AWSDateTime
            lastMessage: String
            createdAt: AWSDateTime!
            updatedAt: AWSDateTime
            createdBy: ID!
            messageCount: Int
        }
        
        type User {
            userId: ID!
            username: String!
            email: AWSEmail!
            displayName: String
            avatarUrl: String
            lastSeen: AWSDateTime
            isOnline: Boolean
            createdAt: AWSDateTime!
            updatedAt: AWSDateTime
        }
        
        enum MessageType {
            TEXT
            IMAGE
            FILE
            SYSTEM
        }
        
        type Query {
            getMessage(conversationId: ID!, messageId: ID!): Message
            getConversation(conversationId: ID!): Conversation
            getUser(userId: ID!): User
            listMessages(conversationId: ID!, limit: Int, nextToken: String): MessageConnection
            listConversations(userId: ID!, limit: Int, nextToken: String): ConversationConnection
            searchMessages(conversationId: ID!, searchTerm: String!, limit: Int): [Message]
        }
        
        type Mutation {
            sendMessage(input: SendMessageInput!): Message
            createConversation(input: CreateConversationInput!): Conversation
            updateConversation(input: UpdateConversationInput!): Conversation
            deleteMessage(conversationId: ID!, messageId: ID!): Message
            updateUserPresence(userId: ID!, isOnline: Boolean!): User
            updateUserProfile(input: UpdateUserProfileInput!): User
        }
        
        type Subscription {
            onMessageSent(conversationId: ID!): Message
                @aws_subscribe(mutations: ["sendMessage"])
            onConversationUpdated(userId: ID!): Conversation
                @aws_subscribe(mutations: ["createConversation", "updateConversation"])
            onUserPresenceUpdated(conversationId: ID!): User
                @aws_subscribe(mutations: ["updateUserPresence"])
        }
        
        input SendMessageInput {
            conversationId: ID!
            content: String!
            messageType: MessageType = TEXT
        }
        
        input CreateConversationInput {
            name: String
            participants: [ID!]!
        }
        
        input UpdateConversationInput {
            conversationId: ID!
            name: String
        }
        
        input UpdateUserProfileInput {
            userId: ID!
            displayName: String
            avatarUrl: String
        }
        
        type MessageConnection {
            items: [Message]
            nextToken: String
        }
        
        type ConversationConnection {
            items: [Conversation]
            nextToken: String
        }
        
        schema {
            query: Query
            mutation: Mutation
            subscription: Subscription
        }
        '''
        
        # Create AppSync API
        api = appsync.GraphqlApi(
            self,
            "ChatGraphQLApi",
            name=f"{self.app_name}-{self.stage}-api",
            schema=appsync.SchemaFile.from_asset("schema.graphql") if os.path.exists("schema.graphql") 
                   else appsync.SchemaFile.inline(schema_definition),
            authorization_config=appsync.AuthorizationConfig(
                default_authorization=appsync.AuthorizationMode(
                    authorization_type=appsync.AuthorizationType.USER_POOL,
                    user_pool_config=appsync.UserPoolConfig(
                        user_pool=self.user_pool,
                        default_action=appsync.UserPoolDefaultAction.ALLOW
                    )
                )
            ),
            log_config=appsync.LogConfig(
                exclude_verbose_content=True,
                field_log_level=appsync.FieldLogLevel.ERROR,
                retention=logs.RetentionDays.ONE_WEEK
            ),
            x_ray_enabled=True
        )
        
        return api

    def _create_service_role(self) -> iam.Role:
        """
        Create IAM service role for AppSync to access DynamoDB.
        
        Returns:
            iam.Role: Service role with appropriate permissions
        """
        # Create service role for AppSync
        service_role = iam.Role(
            self,
            "AppSyncServiceRole",
            role_name=f"{self.app_name}-{self.stage}-appsync-role",
            assumed_by=iam.ServicePrincipal("appsync.amazonaws.com"),
            description="Service role for AppSync to access DynamoDB tables"
        )
        
        # Add DynamoDB permissions
        for table_name, table in self.tables.items():
            service_role.add_to_policy(
                iam.PolicyStatement(
                    effect=iam.Effect.ALLOW,
                    actions=[
                        "dynamodb:Query",
                        "dynamodb:PutItem",
                        "dynamodb:GetItem",
                        "dynamodb:UpdateItem",
                        "dynamodb:DeleteItem",
                        "dynamodb:BatchGetItem",
                        "dynamodb:Scan"
                    ],
                    resources=[
                        table.table_arn,
                        f"{table.table_arn}/*"  # Include GSI access
                    ]
                )
            )
        
        return service_role

    def _configure_data_sources(self) -> None:
        """Configure AppSync data sources for DynamoDB tables."""
        self.data_sources = {}
        
        # Create data source for each table
        for table_name, table in self.tables.items():
            data_source_name = f"{table_name.title()}DataSource"
            self.data_sources[table_name] = self.api.add_dynamo_db_data_source(
                data_source_name,
                table,
                service_role=self.service_role,
                description=f"Data source for {table_name} table"
            )

    def _configure_resolvers(self) -> None:
        """Configure GraphQL resolvers for core operations."""
        # Send message mutation resolver
        send_message_request_vtl = """
        {
            "version": "2017-02-28",
            "operation": "PutItem",
            "key": {
                "conversationId": $util.dynamodb.toDynamoDBJson($ctx.args.input.conversationId),
                "messageId": $util.dynamodb.toDynamoDBJson($util.autoId())
            },
            "attributeValues": {
                "userId": $util.dynamodb.toDynamoDBJson($ctx.identity.sub),
                "content": $util.dynamodb.toDynamoDBJson($ctx.args.input.content),
                "messageType": $util.dynamodb.toDynamoDBJson($ctx.args.input.messageType),
                "createdAt": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601()),
                "updatedAt": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601())
            }
        }
        """
        
        send_message_response_vtl = "$util.toJson($ctx.result)"
        
        self.data_sources["messages"].create_resolver(
            "SendMessageResolver",
            type_name="Mutation",
            field_name="sendMessage",
            request_mapping_template=appsync.MappingTemplate.inline(send_message_request_vtl),
            response_mapping_template=appsync.MappingTemplate.inline(send_message_response_vtl)
        )
        
        # List messages query resolver
        list_messages_request_vtl = """
        {
            "version": "2017-02-28",
            "operation": "Query",
            "index": "MessagesByTime",
            "query": {
                "expression": "conversationId = :conversationId",
                "expressionValues": {
                    ":conversationId": $util.dynamodb.toDynamoDBJson($ctx.args.conversationId)
                }
            },
            "scanIndexForward": false,
            "limit": #if($ctx.args.limit) $ctx.args.limit #else 50 #end
            #if($ctx.args.nextToken)
            ,"nextToken": "$ctx.args.nextToken"
            #end
        }
        """
        
        list_messages_response_vtl = """
        {
            "items": $util.toJson($ctx.result.items),
            "nextToken": #if($ctx.result.nextToken) "$ctx.result.nextToken" #else null #end
        }
        """
        
        self.data_sources["messages"].create_resolver(
            "ListMessagesResolver",
            type_name="Query",
            field_name="listMessages",
            request_mapping_template=appsync.MappingTemplate.inline(list_messages_request_vtl),
            response_mapping_template=appsync.MappingTemplate.inline(list_messages_response_vtl)
        )
        
        # Create conversation mutation resolver
        create_conversation_request_vtl = """
        {
            "version": "2017-02-28",
            "operation": "PutItem",
            "key": {
                "conversationId": $util.dynamodb.toDynamoDBJson($util.autoId())
            },
            "attributeValues": {
                "name": $util.dynamodb.toDynamoDBJson($ctx.args.input.name),
                "participants": $util.dynamodb.toDynamoDBJson($ctx.args.input.participants),
                "createdBy": $util.dynamodb.toDynamoDBJson($ctx.identity.sub),
                "createdAt": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601()),
                "updatedAt": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601()),
                "messageCount": $util.dynamodb.toDynamoDBJson(0)
            }
        }
        """
        
        create_conversation_response_vtl = "$util.toJson($ctx.result)"
        
        self.data_sources["conversations"].create_resolver(
            "CreateConversationResolver",
            type_name="Mutation",
            field_name="createConversation",
            request_mapping_template=appsync.MappingTemplate.inline(create_conversation_request_vtl),
            response_mapping_template=appsync.MappingTemplate.inline(create_conversation_response_vtl)
        )
        
        # Update user presence mutation resolver
        update_presence_request_vtl = """
        {
            "version": "2017-02-28",
            "operation": "UpdateItem",
            "key": {
                "userId": $util.dynamodb.toDynamoDBJson($ctx.args.userId)
            },
            "update": {
                "expression": "SET isOnline = :isOnline, lastSeen = :lastSeen, updatedAt = :updatedAt",
                "expressionValues": {
                    ":isOnline": $util.dynamodb.toDynamoDBJson($ctx.args.isOnline),
                    ":lastSeen": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601()),
                    ":updatedAt": $util.dynamodb.toDynamoDBJson($util.time.nowISO8601())
                }
            }
        }
        """
        
        update_presence_response_vtl = "$util.toJson($ctx.result)"
        
        self.data_sources["users"].create_resolver(
            "UpdateUserPresenceResolver",
            type_name="Mutation",
            field_name="updateUserPresence",
            request_mapping_template=appsync.MappingTemplate.inline(update_presence_request_vtl),
            response_mapping_template=appsync.MappingTemplate.inline(update_presence_response_vtl)
        )

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs for important values."""
        CfnOutput(
            self,
            "GraphQLApiUrl",
            value=self.api.graphql_url,
            description="GraphQL API URL for queries and mutations",
            export_name=f"{self.stack_name}-GraphQLApiUrl"
        )
        
        CfnOutput(
            self,
            "GraphQLApiId",
            value=self.api.api_id,
            description="GraphQL API ID",
            export_name=f"{self.stack_name}-GraphQLApiId"
        )
        
        CfnOutput(
            self,
            "RealtimeUrl",
            value=f"wss://{self.api.api_id}.appsync-realtime-api.{self.region}.amazonaws.com/graphql",
            description="WebSocket URL for real-time subscriptions",
            export_name=f"{self.stack_name}-RealtimeUrl"
        )
        
        CfnOutput(
            self,
            "UserPoolId",
            value=self.user_pool.user_pool_id,
            description="Cognito User Pool ID",
            export_name=f"{self.stack_name}-UserPoolId"
        )
        
        CfnOutput(
            self,
            "UserPoolClientId",
            value=self.user_pool.user_pool_client_id,
            description="Cognito User Pool Client ID",
            export_name=f"{self.stack_name}-UserPoolClientId"
        )
        
        # Output DynamoDB table names
        for table_name, table in self.tables.items():
            CfnOutput(
                self,
                f"{table_name.title()}TableName",
                value=table.table_name,
                description=f"{table_name.title()} table name",
                export_name=f"{self.stack_name}-{table_name.title()}TableName"
            )


def main() -> None:
    """Main application entry point."""
    app = cdk.App()
    
    # Get deployment environment
    env = Environment(
        account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
        region=os.environ.get("CDK_DEFAULT_REGION", "us-east-1")
    )
    
    # Create the stack
    RealtimeChatStack(
        app,
        "RealtimeChatStack",
        env=env,
        description="Real-time chat application with AppSync and GraphQL",
        tags={
            "Project": "RealtimeChat",
            "Environment": app.node.try_get_context("stage") or "dev",
            "ManagedBy": "CDK"
        }
    )
    
    app.synth()


if __name__ == "__main__":
    main()