# Multi-Tenant SaaS GraphQL Schema with Fine-Grained Authorization
# This schema implements comprehensive multi-tenancy with tenant isolation,
# role-based access control, and fine-grained authorization rules.

# Tenant Management
type Tenant @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read, update] }
]) {
  id: ID!
  name: String!
  domain: String!
  subdomain: String!
  status: TenantStatus!
  plan: SubscriptionPlan!
  settings: TenantSettings
  features: [FeatureFlag] @hasMany(indexName: "byTenant", fields: ["id"])
  users: [User] @hasMany(indexName: "byTenant", fields: ["id"])
  projects: [Project] @hasMany(indexName: "byTenant", fields: ["id"])
  billingInfo: BillingInfo @hasOne(fields: ["id"])
  usage: TenantUsage @hasOne(fields: ["id"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  
  # Tenant-specific configuration
  customCSS: String
  logo: String
  primaryColor: String
  secondaryColor: String
  timezone: String!
  locale: String!
}

type User @model @auth(rules: [
  { allow: owner, ownerField: "userId" }
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read, update] }
  { allow: private, operations: [read], provider: iam }
]) {
  id: ID!
  userId: String! @auth(rules: [{ allow: owner, operations: [read] }])
  tenantId: ID! @index(name: "byTenant", sortKeyFields: ["createdAt"])
  tenant: Tenant @belongsTo(fields: ["tenantId"])
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  permissions: [String]!
  isActive: Boolean!
  lastLoginAt: AWSDateTime
  profile: UserProfile @hasOne(fields: ["id"])
  projects: [ProjectMember] @hasMany(indexName: "byUser", fields: ["id"])
  activities: [ActivityLog] @hasMany(indexName: "byUser", fields: ["id"])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Project @model @auth(rules: [
  { allow: owner, ownerField: "createdBy", operations: [read, update, delete] }
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"] }
  { allow: private, operations: [read], provider: iam }
]) {
  id: ID!
  tenantId: ID! @index(name: "byTenant", sortKeyFields: ["createdAt"])
  tenant: Tenant @belongsTo(fields: ["tenantId"])
  name: String!
  description: String
  status: ProjectStatus!
  createdBy: String! @auth(rules: [{ allow: owner, operations: [read] }])
  members: [ProjectMember] @hasMany(indexName: "byProject", fields: ["id"])
  tasks: [Task] @hasMany(indexName: "byProject", fields: ["id"])
  settings: ProjectSettings
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Task @model @auth(rules: [
  { allow: owner, ownerField: "assignedTo", operations: [read, update] }
  { allow: owner, ownerField: "createdBy", operations: [read, update, delete] }
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"] }
]) {
  id: ID!
  tenantId: ID! @index(name: "byTenantAndStatus", sortKeyFields: ["status", "createdAt"])
  projectId: ID! @index(name: "byProject", sortKeyFields: ["status", "createdAt"])
  project: Project @belongsTo(fields: ["projectId"])
  title: String!
  description: String
  status: TaskStatus!
  priority: TaskPriority!
  assignedTo: String
  createdBy: String! @auth(rules: [{ allow: owner, operations: [read] }])
  dueDate: AWSDateTime
  completedAt: AWSDateTime
  comments: [TaskComment] @hasMany(indexName: "byTask", fields: ["id"])
  attachments: [String]
  tags: [String]
  estimatedHours: Float
  actualHours: Float
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TaskComment @model @auth(rules: [
  { allow: owner, ownerField: "createdBy", operations: [read, update, delete] }
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"] }
]) {
  id: ID!
  taskId: ID! @index(name: "byTask", sortKeyFields: ["createdAt"])
  task: Task @belongsTo(fields: ["taskId"])
  content: String!
  createdBy: String! @auth(rules: [{ allow: owner, operations: [read] }])
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ProjectMember @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"] }
  { allow: owner, ownerField: "userId", operations: [read] }
]) {
  id: ID!
  tenantId: ID!
  projectId: ID! @index(name: "byProject", sortKeyFields: ["createdAt"])
  project: Project @belongsTo(fields: ["projectId"])
  userId: ID! @index(name: "byUser", sortKeyFields: ["createdAt"])
  user: User @belongsTo(fields: ["userId"])
  role: ProjectRole!
  permissions: [String]!
  joinedAt: AWSDateTime!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type FeatureFlag @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read] }
]) {
  id: ID!
  tenantId: ID! @index(name: "byTenant", sortKeyFields: ["createdAt"])
  tenant: Tenant @belongsTo(fields: ["tenantId"])
  featureName: String!
  isEnabled: Boolean!
  configuration: AWSJSON
  description: String
  rolloutPercentage: Float
  targetUserGroups: [String]
  validFrom: AWSDateTime
  validUntil: AWSDateTime
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type BillingInfo @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read, update] }
]) {
  id: ID!
  tenantId: ID!
  plan: SubscriptionPlan!
  status: BillingStatus!
  currentPeriodStart: AWSDateTime!
  currentPeriodEnd: AWSDateTime!
  monthlyUsage: AWSJSON
  billingHistory: [BillingRecord] @hasMany(indexName: "byBilling", fields: ["id"])
  paymentMethod: PaymentMethod
  invoiceEmail: String
  billingAddress: Address
  taxId: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type BillingRecord @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read] }
]) {
  id: ID!
  billingInfoId: ID! @index(name: "byBilling", sortKeyFields: ["createdAt"])
  billingInfo: BillingInfo @belongsTo(fields: ["billingInfoId"])
  amount: Float!
  currency: String!
  description: String!
  invoiceNumber: String
  paidAt: AWSDateTime
  dueDate: AWSDateTime!
  status: InvoiceStatus!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type TenantUsage @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"], operations: [read] }
]) {
  id: ID!
  tenantId: ID!
  month: String! @index(name: "byMonth", sortKeyFields: ["tenantId"])
  apiCalls: Int!
  storageUsed: Float!
  usersActive: Int!
  projectsCreated: Int!
  tasksCreated: Int!
  dataTransfer: Float!
  computeHours: Float!
  lastUpdated: AWSDateTime!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ActivityLog @model @auth(rules: [
  { allow: groups, groups: ["SuperAdmins"] }
  { allow: groups, groups: ["TenantAdmins"] }
  { allow: owner, ownerField: "userId", operations: [read] }
]) {
  id: ID!
  tenantId: ID! @index(name: "byTenantAndAction", sortKeyFields: ["action", "createdAt"])
  userId: ID! @index(name: "byUser", sortKeyFields: ["createdAt"])
  user: User @belongsTo(fields: ["userId"])
  action: String!
  resource: String!
  resourceId: String
  metadata: AWSJSON
  ipAddress: String
  userAgent: String
  createdAt: AWSDateTime!
}

# Supporting Types
type TenantSettings {
  maxUsers: Int!
  maxProjects: Int!
  maxStorageGB: Float!
  allowedFeatures: [String]!
  ssoEnabled: Boolean!
  auditingEnabled: Boolean!
  dataRetentionDays: Int!
  customDomain: String
  apiRateLimit: Int!
  autoConfirmUsers: Boolean
}

type UserProfile {
  avatar: String
  bio: String
  phoneNumber: String
  department: String
  jobTitle: String
  timezone: String
  preferences: AWSJSON
}

type ProjectSettings {
  isPublic: Boolean!
  allowGuestAccess: Boolean!
  defaultTaskPriority: TaskPriority!
  notificationSettings: AWSJSON
  customFields: AWSJSON
}

type PaymentMethod {
  type: PaymentType!
  last4: String
  expiryMonth: Int
  expiryYear: Int
  brand: String
}

type Address {
  line1: String!
  line2: String
  city: String!
  state: String!
  postalCode: String!
  country: String!
}

# Enums
enum TenantStatus {
  ACTIVE
  SUSPENDED
  TRIAL
  EXPIRED
  CANCELLED
}

enum SubscriptionPlan {
  TRIAL
  BASIC
  PROFESSIONAL
  ENTERPRISE
  CUSTOM
}

enum UserRole {
  TENANT_ADMIN
  PROJECT_MANAGER
  TEAM_LEAD
  DEVELOPER
  VIEWER
  GUEST
}

enum ProjectRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  REVIEW
  DONE
  CANCELLED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum BillingStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  TRIALING
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

enum PaymentType {
  CREDIT_CARD
  BANK_TRANSFER
  INVOICE
}

# Custom Mutations for Tenant Management
type Mutation {
  createTenant(input: CreateTenantInput!): Tenant
    @auth(rules: [{ allow: groups, groups: ["SuperAdmins"] }])
    @function(name: "tenantResolver")
  
  updateTenantSettings(tenantId: ID!, settings: TenantSettingsInput!): Tenant
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
    @function(name: "tenantResolver")
  
  provisionTenantUser(input: ProvisionUserInput!): User
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
    @function(name: "tenantResolver")
  
  updateUserRole(userId: ID!, role: UserRole!, permissions: [String]!): User
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
    @function(name: "tenantResolver")
  
  updateBillingInfo(tenantId: ID!, billingInfo: BillingInfoInput!): BillingInfo
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
    @function(name: "tenantResolver")
  
  # Multi-tenant aware mutations with automatic tenant filtering
  createProjectForTenant(input: CreateProjectInput!): Project
    @auth(rules: [
      { allow: groups, groups: ["TenantAdmins"] }
      { allow: private, provider: userPools }
    ])
  
  createTaskForProject(input: CreateTaskInput!): Task
    @auth(rules: [
      { allow: groups, groups: ["TenantAdmins"] }
      { allow: private, provider: userPools }
    ])
  
  addProjectMember(projectId: ID!, userId: ID!, role: ProjectRole!): ProjectMember
    @auth(rules: [
      { allow: groups, groups: ["TenantAdmins"] }
      { allow: private, provider: userPools }
    ])
}

# Custom Queries for Multi-Tenant Operations
type Query {
  # Tenant-specific queries with automatic filtering
  getMyTenant: Tenant
    @auth(rules: [{ allow: private, provider: userPools }])
  
  listTenantsForAdmin: [Tenant]
    @auth(rules: [{ allow: groups, groups: ["SuperAdmins"] }])
  
  getTenantUsage(tenantId: ID!, month: String): TenantUsage
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
  
  listTenantUsers(tenantId: ID!): [User]
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
  
  getTenantBilling(tenantId: ID!): BillingInfo
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
  
  # User context queries
  getMyProjects: [Project]
    @auth(rules: [{ allow: private, provider: userPools }])
  
  getMyTasks: [Task]
    @auth(rules: [{ allow: private, provider: userPools }])
  
  getMyProfile: User
    @auth(rules: [{ allow: private, provider: userPools }])
}

# Custom Subscriptions for Real-time Updates
type Subscription {
  onTenantUpdated(tenantId: ID!): Tenant
    @aws_subscribe(mutations: ["updateTenantSettings"])
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
  
  onUserAddedToTenant(tenantId: ID!): User
    @aws_subscribe(mutations: ["provisionTenantUser"])
    @auth(rules: [
      { allow: groups, groups: ["SuperAdmins"] }
      { allow: groups, groups: ["TenantAdmins"] }
    ])
  
  onTaskUpdated(projectId: ID!): Task
    @aws_subscribe(mutations: ["updateTask"])
    @auth(rules: [{ allow: private, provider: userPools }])
  
  onProjectMemberAdded(projectId: ID!): ProjectMember
    @aws_subscribe(mutations: ["addProjectMember"])
    @auth(rules: [{ allow: private, provider: userPools }])
}

# Custom Inputs
input CreateTenantInput {
  name: String!
  domain: String!
  subdomain: String!
  plan: SubscriptionPlan!
  adminEmail: String!
  adminName: String!
}

input TenantSettingsInput {
  maxUsers: Int
  maxProjects: Int
  maxStorageGB: Float
  allowedFeatures: [String]
  ssoEnabled: Boolean
  auditingEnabled: Boolean
  dataRetentionDays: Int
  customDomain: String
  apiRateLimit: Int
  autoConfirmUsers: Boolean
}

input ProvisionUserInput {
  tenantId: ID!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  tempPassword: String!
}

input BillingInfoInput {
  plan: SubscriptionPlan
  paymentMethod: PaymentMethodInput
  billingAddress: AddressInput
  invoiceEmail: String
}

input PaymentMethodInput {
  type: PaymentType!
  token: String!
}

input AddressInput {
  line1: String!
  line2: String
  city: String!
  state: String!
  postalCode: String!
  country: String!
}

input CreateProjectInput {
  name: String!
  description: String
  status: ProjectStatus!
  settings: ProjectSettingsInput
}

input ProjectSettingsInput {
  isPublic: Boolean
  allowGuestAccess: Boolean
  defaultTaskPriority: TaskPriority
  notificationSettings: AWSJSON
  customFields: AWSJSON
}

input CreateTaskInput {
  projectId: ID!
  title: String!
  description: String
  priority: TaskPriority!
  assignedTo: String
  dueDate: AWSDateTime
  tags: [String]
  estimatedHours: Float
}