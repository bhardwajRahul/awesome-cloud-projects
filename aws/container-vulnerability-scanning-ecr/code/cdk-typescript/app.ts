#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as ecr from 'aws-cdk-lib/aws-ecr';
import * as inspector from 'aws-cdk-lib/aws-inspector2';
import * as sns from 'aws-cdk-lib/aws-sns';
import * as subscriptions from 'aws-cdk-lib/aws-sns-subscriptions';
import * as events from 'aws-cdk-lib/aws-events';
import * as targets from 'aws-cdk-lib/aws-events-targets';
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as iam from 'aws-cdk-lib/aws-iam';

/**
 * Properties for the VulnerabilityScanning stack
 */
export interface VulnerabilityScanningStackProps extends cdk.StackProps {
  /**
   * Email address to receive vulnerability notifications
   */
  readonly notificationEmail: string;
  
  /**
   * ECR repository name prefix
   * @default 'vulnerable-app'
   */
  readonly repositoryNamePrefix?: string;
  
  /**
   * Inspector rescan duration in days
   * @default 30
   */
  readonly rescanDurationDays?: number;
  
  /**
   * CloudWatch log retention period
   * @default 30 days
   */
  readonly logRetentionDays?: number;
}

/**
 * CDK Stack for Container Image Vulnerability Scanning with ECR and Inspector
 * 
 * This stack creates:
 * - ECR repository with enhanced scanning enabled
 * - Amazon Inspector configuration for continuous vulnerability scanning
 * - CloudWatch alarms for critical vulnerabilities
 * - EventBridge rules to capture vulnerability findings
 * - SNS topic and email subscription for notifications
 */
export class VulnerabilityScanningStack extends cdk.Stack {
  /**
   * The ECR repository for container images
   */
  public readonly repository: ecr.Repository;
  
  /**
   * SNS topic for vulnerability notifications
   */
  public readonly notificationTopic: sns.Topic;
  
  /**
   * CloudWatch alarm for critical vulnerabilities
   */
  public readonly criticalVulnerabilityAlarm: cloudwatch.Alarm;

  constructor(scope: Construct, id: string, props: VulnerabilityScanningStackProps) {
    super(scope, id, props);

    // Generate unique suffix for resource names
    const uniqueSuffix = cdk.Names.uniqueId(this).slice(-6).toLowerCase();
    const repositoryName = `${props.repositoryNamePrefix || 'vulnerable-app'}-${uniqueSuffix}`;
    
    // Create ECR repository with enhanced scanning enabled
    this.repository = new ecr.Repository(this, 'VulnerableAppRepository', {
      repositoryName: repositoryName,
      imageScanOnPush: true,
      imageTagMutability: ecr.TagMutability.MUTABLE,
      lifecyclePolicy: ecr.LifecyclePolicy.fromLifecyclePolicyText(JSON.stringify({
        rules: [
          {
            rulePriority: 1,
            selection: {
              tagStatus: 'untagged',
              countType: 'sinceImagePushed',
              countUnit: 'days',
              countNumber: 7
            },
            action: {
              type: 'expire'
            }
          },
          {
            rulePriority: 2,
            selection: {
              tagStatus: 'tagged',
              countType: 'imageCountMoreThan',
              countNumber: 10
            },
            action: {
              type: 'expire'
            }
          }
        ]
      })),
      removalPolicy: cdk.RemovalPolicy.DESTROY
    });

    // Add tags to the repository
    cdk.Tags.of(this.repository).add('Purpose', 'VulnerabilityScanning');
    cdk.Tags.of(this.repository).add('Environment', 'Demo');

    // Create SNS topic for vulnerability alerts
    this.notificationTopic = new sns.Topic(this, 'VulnerabilityAlertsTopic', {
      topicName: `ecr-vulnerability-alerts-${uniqueSuffix}`,
      displayName: 'ECR Vulnerability Alerts',
      description: 'Notifications for container image vulnerability findings'
    });

    // Subscribe email to SNS topic
    this.notificationTopic.addSubscription(
      new subscriptions.EmailSubscription(props.notificationEmail)
    );

    // Create CloudWatch log group for Inspector findings
    const inspectorLogGroup = new logs.LogGroup(this, 'InspectorFindingsLogGroup', {
      logGroupName: '/aws/inspector/ecr-findings',
      retention: props.logRetentionDays ? 
        this.getLogRetentionFromDays(props.logRetentionDays) : 
        logs.RetentionDays.ONE_MONTH,
      removalPolicy: cdk.RemovalPolicy.DESTROY
    });

    // Create CloudWatch alarm for critical vulnerabilities
    this.criticalVulnerabilityAlarm = new cloudwatch.Alarm(this, 'CriticalVulnerabilitiesAlarm', {
      alarmName: `ECR-Critical-Vulnerabilities-${uniqueSuffix}`,
      alarmDescription: 'Alert on critical vulnerabilities in ECR images',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/Inspector',
        metricName: 'CriticalVulnerabilities',
        statistic: 'Average',
        period: cdk.Duration.minutes(5)
      }),
      threshold: 1,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO_THRESHOLD,
      evaluationPeriods: 1,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING
    });

    // Add SNS action to the alarm
    this.criticalVulnerabilityAlarm.addAlarmAction(
      new cloudwatch.SnsAction(this.notificationTopic)
    );

    // Create EventBridge rule for Inspector findings
    const vulnerabilityFindingsRule = new events.Rule(this, 'VulnerabilityFindingsRule', {
      ruleName: `ECR-Vulnerability-Findings-${uniqueSuffix}`,
      description: 'Capture Inspector ECR vulnerability findings',
      eventPattern: {
        source: ['aws.inspector2'],
        detailType: ['Inspector2 Finding'],
        detail: {
          service: ['ECR']
        }
      }
    });

    // Add SNS target to EventBridge rule
    vulnerabilityFindingsRule.addTarget(
      new targets.SnsTopic(this.notificationTopic)
    );

    // Create IAM role for Inspector service
    const inspectorServiceRole = new iam.Role(this, 'InspectorServiceRole', {
      assumedBy: new iam.ServicePrincipal('inspector2.amazonaws.com'),
      description: 'Service role for Amazon Inspector ECR scanning',
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonInspector2ServiceRolePolicy')
      ]
    });

    // Custom resource to enable Inspector ECR scanning
    const enableInspectorCustomResource = new cdk.CustomResource(this, 'EnableInspectorResource', {
      serviceToken: this.createInspectorEnableFunction().functionArn,
      properties: {
        AccountId: this.account,
        RescanDurationDays: props.rescanDurationDays || 30
      }
    });

    // Ensure Inspector is enabled before creating other resources
    this.repository.node.addDependency(enableInspectorCustomResource);

    // Output important values
    new cdk.CfnOutput(this, 'RepositoryUri', {
      value: this.repository.repositoryUri,
      description: 'ECR Repository URI for pushing container images',
      exportName: `${this.stackName}-RepositoryUri`
    });

    new cdk.CfnOutput(this, 'RepositoryName', {
      value: this.repository.repositoryName,
      description: 'ECR Repository Name',
      exportName: `${this.stackName}-RepositoryName`
    });

    new cdk.CfnOutput(this, 'SNSTopicArn', {
      value: this.notificationTopic.topicArn,
      description: 'SNS Topic ARN for vulnerability notifications',
      exportName: `${this.stackName}-SNSTopicArn`
    });

    new cdk.CfnOutput(this, 'AlarmName', {
      value: this.criticalVulnerabilityAlarm.alarmName,
      description: 'CloudWatch Alarm for Critical Vulnerabilities',
      exportName: `${this.stackName}-AlarmName`
    });

    new cdk.CfnOutput(this, 'LogGroupName', {
      value: inspectorLogGroup.logGroupName,
      description: 'CloudWatch Log Group for Inspector findings',
      exportName: `${this.stackName}-LogGroupName`
    });
  }

  /**
   * Convert days to CloudWatch log retention enum
   */
  private getLogRetentionFromDays(days: number): logs.RetentionDays {
    const retentionMap: Record<number, logs.RetentionDays> = {
      1: logs.RetentionDays.ONE_DAY,
      3: logs.RetentionDays.THREE_DAYS,
      5: logs.RetentionDays.FIVE_DAYS,
      7: logs.RetentionDays.ONE_WEEK,
      14: logs.RetentionDays.TWO_WEEKS,
      30: logs.RetentionDays.ONE_MONTH,
      60: logs.RetentionDays.TWO_MONTHS,
      90: logs.RetentionDays.THREE_MONTHS,
      120: logs.RetentionDays.FOUR_MONTHS,
      150: logs.RetentionDays.FIVE_MONTHS,
      180: logs.RetentionDays.SIX_MONTHS,
      365: logs.RetentionDays.ONE_YEAR,
      400: logs.RetentionDays.THIRTEEN_MONTHS,
      545: logs.RetentionDays.EIGHTEEN_MONTHS,
      731: logs.RetentionDays.TWO_YEARS,
      1827: logs.RetentionDays.FIVE_YEARS,
      3653: logs.RetentionDays.TEN_YEARS
    };

    // Find the closest match
    const sortedDays = Object.keys(retentionMap).map(Number).sort((a, b) => a - b);
    for (const dayOption of sortedDays) {
      if (days <= dayOption) {
        return retentionMap[dayOption];
      }
    }
    
    // Default to indefinite if no match found
    return logs.RetentionDays.INFINITE;
  }

  /**
   * Create Lambda function to enable Inspector ECR scanning
   */
  private createInspectorEnableFunction(): cdk.aws_lambda.Function {
    const lambdaFunction = new cdk.aws_lambda.Function(this, 'EnableInspectorFunction', {
      runtime: cdk.aws_lambda.Runtime.PYTHON_3_11,
      handler: 'index.handler',
      timeout: cdk.Duration.minutes(5),
      code: cdk.aws_lambda.Code.fromInline(`
import json
import boto3
import cfnresponse
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def handler(event, context):
    """
    Custom resource handler to enable Inspector ECR scanning
    """
    try:
        inspector_client = boto3.client('inspector2')
        ecr_client = boto3.client('ecr')
        
        account_id = event['ResourceProperties']['AccountId']
        rescan_duration_days = int(event['ResourceProperties']['RescanDurationDays'])
        
        if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
            logger.info("Enabling Inspector ECR scanning")
            
            # Enable Inspector for ECR
            try:
                inspector_client.enable(
                    resourceTypes=['ECR'],
                    accountIds=[account_id]
                )
                logger.info("Inspector ECR scanning enabled successfully")
            except Exception as e:
                if 'already enabled' in str(e).lower():
                    logger.info("Inspector ECR scanning already enabled")
                else:
                    raise e
            
            # Configure enhanced scanning
            try:
                ecr_client.put_registry_scanning_configuration(
                    scanType='ENHANCED',
                    rules=[
                        {
                            'scanFrequency': 'CONTINUOUS_SCAN',
                            'repositoryFilters': [
                                {
                                    'filter': '*',
                                    'filterType': 'WILDCARD'
                                }
                            ]
                        }
                    ]
                )
                logger.info("ECR enhanced scanning configuration updated")
            except Exception as e:
                logger.warning(f"Failed to configure ECR scanning: {e}")
            
            # Update Inspector configuration
            try:
                inspector_client.update_configuration(
                    ecrConfiguration={
                        'rescanDuration': f'DAYS_{rescan_duration_days}'
                    }
                )
                logger.info(f"Inspector rescan duration set to {rescan_duration_days} days")
            except Exception as e:
                logger.warning(f"Failed to update Inspector configuration: {e}")
                
        elif event['RequestType'] == 'Delete':
            logger.info("Disabling Inspector ECR scanning")
            try:
                inspector_client.disable(
                    resourceTypes=['ECR'],
                    accountIds=[account_id]
                )
                logger.info("Inspector ECR scanning disabled successfully")
            except Exception as e:
                logger.warning(f"Failed to disable Inspector: {e}")
        
        cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
        
    except Exception as e:
        logger.error(f"Error in custom resource: {e}")
        cfnresponse.send(event, context, cfnresponse.FAILED, {})
`),
      role: this.createInspectorLambdaRole()
    });

    return lambdaFunction;
  }

  /**
   * Create IAM role for the Inspector Lambda function
   */
  private createInspectorLambdaRole(): iam.Role {
    const role = new iam.Role(this, 'InspectorLambdaRole', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
      description: 'Role for Lambda function to manage Inspector configuration',
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
      ]
    });

    // Add permissions for Inspector and ECR operations
    role.addToPolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        'inspector2:Enable',
        'inspector2:Disable',
        'inspector2:GetConfiguration',
        'inspector2:UpdateConfiguration',
        'ecr:PutRegistryScanningConfiguration',
        'ecr:GetRegistryScanningConfiguration'
      ],
      resources: ['*']
    }));

    return role;
  }
}

/**
 * CDK Application
 */
const app = new cdk.App();

// Get configuration from CDK context or environment variables
const notificationEmail = app.node.tryGetContext('notificationEmail') || 
                         process.env.NOTIFICATION_EMAIL || 
                         'your-email@example.com';

const repositoryNamePrefix = app.node.tryGetContext('repositoryNamePrefix') || 
                            process.env.REPOSITORY_NAME_PREFIX || 
                            'vulnerable-app';

const rescanDurationDays = Number(app.node.tryGetContext('rescanDurationDays')) || 
                          Number(process.env.RESCAN_DURATION_DAYS) || 
                          30;

const logRetentionDays = Number(app.node.tryGetContext('logRetentionDays')) || 
                        Number(process.env.LOG_RETENTION_DAYS) || 
                        30;

// Create the stack
new VulnerabilityScanningStack(app, 'VulnerabilityScanningStack', {
  notificationEmail,
  repositoryNamePrefix,
  rescanDurationDays,
  logRetentionDays,
  description: 'Container Image Vulnerability Scanning with ECR and Inspector',
  
  // Enable termination protection for production
  terminationProtection: false,
  
  // Add stack tags
  tags: {
    Project: 'VulnerabilityScanning',
    Owner: 'SecurityTeam',
    Environment: 'Demo',
    Purpose: 'ContainerSecurity'
  }
});

// Synthesize the app
app.synth();