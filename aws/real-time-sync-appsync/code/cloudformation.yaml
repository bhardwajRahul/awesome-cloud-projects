AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Real-time Data Synchronization with AWS AppSync - Creates a collaborative task management 
  system with GraphQL API, DynamoDB storage, and real-time subscriptions for multi-user 
  synchronization. Includes conflict resolution, monitoring, and security best practices.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Application Configuration"
        Parameters:
          - ApplicationName
          - Environment
      - Label:
          default: "API Configuration"
        Parameters:
          - AuthenticationType
          - ApiKeyDescription
          - ApiKeyExpirationDays
      - Label:
          default: "Database Configuration"
        Parameters:
          - DynamoDBReadCapacity
          - DynamoDBWriteCapacity
          - EnablePointInTimeRecovery
      - Label:
          default: "Monitoring Configuration"
        Parameters:
          - EnableDetailedLogging
          - LogRetentionDays
    ParameterLabels:
      ApplicationName:
        default: "Application Name"
      Environment:
        default: "Environment"
      AuthenticationType:
        default: "Authentication Type"
      ApiKeyDescription:
        default: "API Key Description"
      ApiKeyExpirationDays:
        default: "API Key Expiration (Days)"
      DynamoDBReadCapacity:
        default: "DynamoDB Read Capacity Units"
      DynamoDBWriteCapacity:
        default: "DynamoDB Write Capacity Units"
      EnablePointInTimeRecovery:
        default: "Enable Point-in-Time Recovery"
      EnableDetailedLogging:
        default: "Enable Detailed Logging"
      LogRetentionDays:
        default: "CloudWatch Log Retention (Days)"

Parameters:
  ApplicationName:
    Type: String
    Default: realtime-tasks
    Description: Name of the application (used for resource naming)
    AllowedPattern: ^[a-z][a-z0-9-]*[a-z0-9]$
    ConstraintDescription: Must start with lowercase letter, contain only lowercase letters, numbers, and hyphens, and end with alphanumeric character
    MinLength: 3
    MaxLength: 30

  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - test
      - staging
      - prod
    Description: Environment name for resource tagging and configuration

  AuthenticationType:
    Type: String
    Default: API_KEY
    AllowedValues:
      - API_KEY
      - AWS_IAM
      - AMAZON_COGNITO_USER_POOLS
      - OPENID_CONNECT
    Description: Authentication type for the GraphQL API

  ApiKeyDescription:
    Type: String
    Default: API Key for real-time tasks application
    Description: Description for the AppSync API key (only used if AuthenticationType is API_KEY)
    MaxLength: 128

  ApiKeyExpirationDays:
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 365
    Description: Number of days until API key expires (only used if AuthenticationType is API_KEY)

  DynamoDBReadCapacity:
    Type: Number
    Default: 5
    MinValue: 1
    MaxValue: 40000
    Description: Read capacity units for DynamoDB table

  DynamoDBWriteCapacity:
    Type: Number
    Default: 5
    MinValue: 1
    MaxValue: 40000
    Description: Write capacity units for DynamoDB table

  EnablePointInTimeRecovery:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Enable Point-in-Time Recovery for DynamoDB table

  EnableDetailedLogging:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Enable detailed CloudWatch logging for AppSync

  LogRetentionDays:
    Type: Number
    Default: 14
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
    Description: CloudWatch log retention period in days

Conditions:
  CreateApiKey: !Equals [!Ref AuthenticationType, API_KEY]
  EnablePITR: !Equals [!Ref EnablePointInTimeRecovery, 'true']
  EnableLogging: !Equals [!Ref EnableDetailedLogging, 'true']
  IsProduction: !Equals [!Ref Environment, prod]

Resources:
  # DynamoDB Table for Task Storage
  TasksTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${ApplicationName}-tasks-${Environment}"
      BillingMode: PROVISIONED
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: status
          AttributeType: S
        - AttributeName: createdAt
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: status-createdAt-index
          KeySchema:
            - AttributeName: status
              KeyType: HASH
            - AttributeName: createdAt
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
          ProvisionedThroughput:
            ReadCapacityUnits: !Ref DynamoDBReadCapacity
            WriteCapacityUnits: !Ref DynamoDBWriteCapacity
      ProvisionedThroughput:
        ReadCapacityUnits: !Ref DynamoDBReadCapacity
        WriteCapacityUnits: !Ref DynamoDBWriteCapacity
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: !If [EnablePITR, true, false]
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: Real-time task storage
        - Key: ManagedBy
          Value: CloudFormation

  # IAM Role for AppSync to access DynamoDB
  AppSyncServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ApplicationName}-appsync-role-${Environment}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt TasksTable.Arn
                  - !Sub "${TasksTable.Arn}/*"
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: AppSync service role
        - Key: ManagedBy
          Value: CloudFormation

  # CloudWatch Log Group for AppSync (conditional)
  AppSyncLogGroup:
    Type: AWS::Logs::LogGroup
    Condition: EnableLogging
    Properties:
      LogGroupName: !Sub "/aws/appsync/apis/${ApplicationName}-${Environment}"
      RetentionInDays: !Ref LogRetentionDays
      Tags:
        - Key: Application
          Value: !Ref ApplicationName
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: AppSync API logging
        - Key: ManagedBy
          Value: CloudFormation

  # AppSync GraphQL API
  GraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub "${ApplicationName}-api-${Environment}"
      AuthenticationType: !Ref AuthenticationType
      LogConfig: !If
        - EnableLogging
        - CloudWatchLogsRoleArn: !GetAtt AppSyncServiceRole.Arn
          FieldLogLevel: ALL
          ExcludeVerboseContent: false
        - !Ref AWS::NoValue
      Tags:
        Application: !Ref ApplicationName
        Environment: !Ref Environment
        Purpose: Real-time GraphQL API
        ManagedBy: CloudFormation

  # AppSync API Key (conditional)
  GraphQLApiKey:
    Type: AWS::AppSync::ApiKey
    Condition: CreateApiKey
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Description: !Ref ApiKeyDescription
      # Calculate expiration timestamp based on current time + ApiKeyExpirationDays
      # Note: CloudFormation doesn't support dynamic timestamp calculation
      # This will default to 7 days from creation time if not specified

  # GraphQL Schema
  GraphQLSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Definition: |
        type Task {
            id: ID!
            title: String!
            description: String
            status: TaskStatus!
            priority: Priority!
            assignedTo: String
            createdAt: AWSDateTime!
            updatedAt: AWSDateTime!
            version: Int!
        }

        enum TaskStatus {
            TODO
            IN_PROGRESS
            COMPLETED
            ARCHIVED
        }

        enum Priority {
            LOW
            MEDIUM
            HIGH
            URGENT
        }

        input CreateTaskInput {
            title: String!
            description: String
            priority: Priority!
            assignedTo: String
        }

        input UpdateTaskInput {
            id: ID!
            title: String
            description: String
            status: TaskStatus
            priority: Priority
            assignedTo: String
            version: Int!
        }

        type Query {
            getTask(id: ID!): Task
            listTasks(status: TaskStatus, limit: Int, nextToken: String): TaskConnection
            listTasksByStatus(status: TaskStatus!, limit: Int, nextToken: String): TaskConnection
        }

        type Mutation {
            createTask(input: CreateTaskInput!): Task
            updateTask(input: UpdateTaskInput!): Task
            deleteTask(id: ID!, version: Int!): Task
        }

        type Subscription {
            onTaskCreated: Task
                @aws_subscribe(mutations: ["createTask"])
            onTaskUpdated: Task
                @aws_subscribe(mutations: ["updateTask"])
            onTaskDeleted: Task
                @aws_subscribe(mutations: ["deleteTask"])
        }

        type TaskConnection {
            items: [Task]
            nextToken: String
        }

        schema {
            query: Query
            mutation: Mutation
            subscription: Subscription
        }

  # DynamoDB Data Source
  TasksDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: TasksDataSource
      Description: DynamoDB data source for tasks
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Ref TasksTable
        AwsRegion: !Ref AWS::Region

  # Query Resolvers
  GetTaskResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getTask
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2018-05-29",
            "operation": "GetItem",
            "key": {
                "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
            }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  ListTasksResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: listTasks
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2018-05-29",
            "operation": "Scan",
            "limit": #if($ctx.args.limit) $ctx.args.limit #else 20 #end,
            "nextToken": #if($ctx.args.nextToken) "$ctx.args.nextToken" #else null #end
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        {
            "items": $util.toJson($ctx.result.items),
            "nextToken": #if($ctx.result.nextToken) "$ctx.result.nextToken" #else null #end
        }

  ListTasksByStatusResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: listTasksByStatus
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2018-05-29",
            "operation": "Query",
            "index": "status-createdAt-index",
            "query": {
                "expression": "#status = :status",
                "expressionNames": {
                    "#status": "status"
                },
                "expressionValues": {
                    ":status": $util.dynamodb.toDynamoDBJson($ctx.args.status)
                }
            },
            "limit": #if($ctx.args.limit) $ctx.args.limit #else 20 #end,
            "nextToken": #if($ctx.args.nextToken) "$ctx.args.nextToken" #else null #end,
            "scanIndexForward": false
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        {
            "items": $util.toJson($ctx.result.items),
            "nextToken": #if($ctx.result.nextToken) "$ctx.result.nextToken" #else null #end
        }

  # Mutation Resolvers
  CreateTaskResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: createTask
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        #set($id = $util.autoId())
        #set($createdAt = $util.time.nowISO8601())
        {
            "version": "2018-05-29",
            "operation": "PutItem",
            "key": {
                "id": $util.dynamodb.toDynamoDBJson($id)
            },
            "attributeValues": {
                "title": $util.dynamodb.toDynamoDBJson($ctx.args.input.title),
                "description": $util.dynamodb.toDynamoDBJson($ctx.args.input.description),
                "status": $util.dynamodb.toDynamoDBJson("TODO"),
                "priority": $util.dynamodb.toDynamoDBJson($ctx.args.input.priority),
                "assignedTo": $util.dynamodb.toDynamoDBJson($ctx.args.input.assignedTo),
                "createdAt": $util.dynamodb.toDynamoDBJson($createdAt),
                "updatedAt": $util.dynamodb.toDynamoDBJson($createdAt),
                "version": $util.dynamodb.toDynamoDBJson(1)
            }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  UpdateTaskResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateTask
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        #set($updatedAt = $util.time.nowISO8601())
        #set($updateExpression = "SET #updatedAt = :updatedAt, #version = #version + :incr")
        #set($expressionNames = {})
        #set($expressionValues = {})
        $util.qr($expressionNames.put("#updatedAt", "updatedAt"))
        $util.qr($expressionNames.put("#version", "version"))
        $util.qr($expressionValues.put(":updatedAt", $util.dynamodb.toDynamoDBJson($updatedAt)))
        $util.qr($expressionValues.put(":incr", $util.dynamodb.toDynamoDBJson(1)))
        $util.qr($expressionValues.put(":expectedVersion", $util.dynamodb.toDynamoDBJson($ctx.args.input.version)))

        #if($ctx.args.input.title)
            #set($updateExpression = "$updateExpression, #title = :title")
            $util.qr($expressionNames.put("#title", "title"))
            $util.qr($expressionValues.put(":title", $util.dynamodb.toDynamoDBJson($ctx.args.input.title)))
        #end
        #if($ctx.args.input.description)
            #set($updateExpression = "$updateExpression, #description = :description")
            $util.qr($expressionNames.put("#description", "description"))
            $util.qr($expressionValues.put(":description", $util.dynamodb.toDynamoDBJson($ctx.args.input.description)))
        #end
        #if($ctx.args.input.status)
            #set($updateExpression = "$updateExpression, #status = :status")
            $util.qr($expressionNames.put("#status", "status"))
            $util.qr($expressionValues.put(":status", $util.dynamodb.toDynamoDBJson($ctx.args.input.status)))
        #end
        #if($ctx.args.input.priority)
            #set($updateExpression = "$updateExpression, #priority = :priority")
            $util.qr($expressionNames.put("#priority", "priority"))
            $util.qr($expressionValues.put(":priority", $util.dynamodb.toDynamoDBJson($ctx.args.input.priority)))
        #end
        #if($ctx.args.input.assignedTo)
            #set($updateExpression = "$updateExpression, #assignedTo = :assignedTo")
            $util.qr($expressionNames.put("#assignedTo", "assignedTo"))
            $util.qr($expressionValues.put(":assignedTo", $util.dynamodb.toDynamoDBJson($ctx.args.input.assignedTo)))
        #end

        {
            "version": "2018-05-29",
            "operation": "UpdateItem",
            "key": {
                "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)
            },
            "update": {
                "expression": "$updateExpression",
                "expressionNames": $util.toJson($expressionNames),
                "expressionValues": $util.toJson($expressionValues)
            },
            "condition": {
                "expression": "#version = :expectedVersion",
                "expressionNames": {
                    "#version": "version"
                },
                "expressionValues": {
                    ":expectedVersion": $util.dynamodb.toDynamoDBJson($ctx.args.input.version)
                }
            }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

  DeleteTaskResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: deleteTask
      DataSourceName: !GetAtt TasksDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2018-05-29",
            "operation": "DeleteItem",
            "key": {
                "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
            },
            "condition": {
                "expression": "#version = :expectedVersion",
                "expressionNames": {
                    "#version": "version"
                },
                "expressionValues": {
                    ":expectedVersion": $util.dynamodb.toDynamoDBJson($ctx.args.version)
                }
            }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
            $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.result)

Outputs:
  # Application Information
  ApplicationName:
    Description: Name of the application
    Value: !Ref ApplicationName
    Export:
      Name: !Sub "${AWS::StackName}-ApplicationName"

  Environment:
    Description: Environment name
    Value: !Ref Environment
    Export:
      Name: !Sub "${AWS::StackName}-Environment"

  # GraphQL API Information
  GraphQLApiId:
    Description: AppSync GraphQL API ID
    Value: !GetAtt GraphQLApi.ApiId
    Export:
      Name: !Sub "${AWS::StackName}-GraphQLApiId"

  GraphQLApiUrl:
    Description: AppSync GraphQL API URL
    Value: !GetAtt GraphQLApi.GraphQLUrl
    Export:
      Name: !Sub "${AWS::StackName}-GraphQLApiUrl"

  GraphQLApiArn:
    Description: AppSync GraphQL API ARN
    Value: !GetAtt GraphQLApi.Arn
    Export:
      Name: !Sub "${AWS::StackName}-GraphQLApiArn"

  # Real-time WebSocket endpoint for subscriptions
  RealtimeUrl:
    Description: AppSync Real-time WebSocket URL for subscriptions
    Value: !GetAtt GraphQLApi.RealtimeUrl
    Export:
      Name: !Sub "${AWS::StackName}-RealtimeUrl"

  # API Key (conditional output)
  ApiKey:
    Condition: CreateApiKey
    Description: AppSync API Key (only if API_KEY authentication is used)
    Value: !GetAtt GraphQLApiKey.ApiKey
    Export:
      Name: !Sub "${AWS::StackName}-ApiKey"

  # DynamoDB Information
  TasksTableName:
    Description: DynamoDB table name for tasks
    Value: !Ref TasksTable
    Export:
      Name: !Sub "${AWS::StackName}-TasksTableName"

  TasksTableArn:
    Description: DynamoDB table ARN for tasks
    Value: !GetAtt TasksTable.Arn
    Export:
      Name: !Sub "${AWS::StackName}-TasksTableArn"

  TasksTableStreamArn:
    Description: DynamoDB table stream ARN for real-time triggers
    Value: !GetAtt TasksTable.StreamArn
    Export:
      Name: !Sub "${AWS::StackName}-TasksTableStreamArn"

  # Security Information
  AppSyncServiceRoleArn:
    Description: IAM role ARN used by AppSync to access DynamoDB
    Value: !GetAtt AppSyncServiceRole.Arn
    Export:
      Name: !Sub "${AWS::StackName}-AppSyncServiceRoleArn"

  # Monitoring Information
  LogGroupName:
    Condition: EnableLogging
    Description: CloudWatch Log Group name for AppSync API logs
    Value: !Ref AppSyncLogGroup
    Export:
      Name: !Sub "${AWS::StackName}-LogGroupName"

  # Connection Instructions
  SampleQueries:
    Description: Basic GraphQL operations for testing the API
    Value: !Sub |
      # Create a new task
      mutation CreateTask {
        createTask(input: {
          title: "Sample Task"
          description: "This is a test task"
          priority: HIGH
          assignedTo: "user@example.com"
        }) {
          id
          title
          status
          priority
          version
          createdAt
        }
      }

      # List all tasks
      query ListTasks {
        listTasks(limit: 10) {
          items {
            id
            title
            status
            priority
            createdAt
          }
          nextToken
        }
      }

      # Subscribe to real-time task updates
      subscription OnTaskCreated {
        onTaskCreated {
          id
          title
          status
          priority
          assignedTo
          createdAt
        }
      }

  # Estimated Monthly Cost
  EstimatedMonthlyCost:
    Description: Estimated monthly cost breakdown (USD) - actual costs may vary
    Value: !Sub |
      AppSync: $${!If [IsProduction, '25-50', '5-15']} (based on requests and data transfer)
      DynamoDB: $${!If [IsProduction, '15-30', '3-8']} (based on ${DynamoDBReadCapacity}/${DynamoDBWriteCapacity} capacity units)
      CloudWatch Logs: $${!If [EnableLogging, '2-5', '0']} (based on log volume)
      Total Estimated: $${!If [IsProduction, '42-85', '8-23']} per month
      Note: Costs vary based on usage patterns, data volume, and region

  # Next Steps
  DeploymentInstructions:
    Description: Instructions for using the deployed infrastructure
    Value: !Sub |
      1. Use GraphQL API URL: ${GraphQLApi.GraphQLUrl}
      2. ${!If [CreateApiKey, !Sub 'Authenticate with API Key: ${GraphQLApiKey.ApiKey}', 'Configure your chosen authentication method']}
      3. Use Real-time URL for subscriptions: ${GraphQLApi.RealtimeUrl}
      4. ${!If [EnableLogging, !Sub 'Monitor logs in CloudWatch: ${AppSyncLogGroup}', 'Enable logging for debugging if needed']}
      5. Test with sample queries provided in SampleQueries output
      6. Build your client application using AWS AppSync SDKs