AWSTemplateFormatVersion: '2010-09-09'
Description: 'Customer Service Chatbot infrastructure using Amazon Lex V2, Lambda, and DynamoDB'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Bot Configuration"
        Parameters:
          - BotName
          - IdleSessionTTL
          - ConfidenceThreshold
      - Label:
          default: "Lambda Configuration"
        Parameters:
          - LambdaTimeout
          - LambdaMemorySize
      - Label:
          default: "DynamoDB Configuration"
        Parameters:
          - DynamoDBTableName
          - BillingMode
      - Label:
          default: "Tagging"
        Parameters:
          - ProjectTag
          - EnvironmentTag
    ParameterLabels:
      BotName:
        default: "Chatbot Name"
      IdleSessionTTL:
        default: "Session Timeout (seconds)"
      ConfidenceThreshold:
        default: "NLU Confidence Threshold"
      LambdaTimeout:
        default: "Lambda Timeout (seconds)"
      LambdaMemorySize:
        default: "Lambda Memory (MB)"
      DynamoDBTableName:
        default: "Customer Data Table Name"
      BillingMode:
        default: "DynamoDB Billing Mode"
      ProjectTag:
        default: "Project Name"
      EnvironmentTag:
        default: "Environment"

Parameters:
  BotName:
    Type: String
    Default: CustomerServiceBot
    Description: Name for the Amazon Lex chatbot
    MinLength: 1
    MaxLength: 100
    AllowedPattern: '^[a-zA-Z0-9_-]+$'
    ConstraintDescription: Bot name must contain only alphanumeric characters, hyphens, and underscores

  IdleSessionTTL:
    Type: Number
    Default: 600
    Description: Time in seconds before idle sessions expire
    MinValue: 60
    MaxValue: 86400
    ConstraintDescription: Must be between 60 seconds (1 minute) and 86400 seconds (24 hours)

  ConfidenceThreshold:
    Type: Number
    Default: 0.40
    Description: Minimum confidence threshold for intent recognition
    MinValue: 0.1
    MaxValue: 1.0
    ConstraintDescription: Must be between 0.1 and 1.0

  LambdaTimeout:
    Type: Number
    Default: 30
    Description: Lambda function timeout in seconds
    MinValue: 3
    MaxValue: 900
    ConstraintDescription: Must be between 3 and 900 seconds

  LambdaMemorySize:
    Type: Number
    Default: 128
    Description: Lambda function memory allocation in MB
    AllowedValues: [128, 256, 512, 1024, 2048, 3008]
    ConstraintDescription: Must be a valid Lambda memory size

  DynamoDBTableName:
    Type: String
    Default: customer-data
    Description: Name for the DynamoDB table storing customer information
    MinLength: 3
    MaxLength: 255
    AllowedPattern: '^[a-zA-Z0-9_.-]+$'
    ConstraintDescription: Table name must contain only alphanumeric characters, hyphens, underscores, and periods

  BillingMode:
    Type: String
    Default: PAY_PER_REQUEST
    AllowedValues:
      - PAY_PER_REQUEST
      - PROVISIONED
    Description: DynamoDB billing mode (PAY_PER_REQUEST recommended for variable workloads)

  ProjectTag:
    Type: String
    Default: LexCustomerService
    Description: Project tag for resource organization
    MinLength: 1
    MaxLength: 50

  EnvironmentTag:
    Type: String
    Default: Development
    AllowedValues:
      - Development
      - Staging
      - Production
    Description: Environment tag for resource categorization

Conditions:
  IsProvisionedBilling: !Equals [!Ref BillingMode, PROVISIONED]

Resources:
  # DynamoDB Table for Customer Data
  CustomerDataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${DynamoDBTableName}-${AWS::StackName}"
      BillingMode: !Ref BillingMode
      AttributeDefinitions:
        - AttributeName: CustomerId
          AttributeType: S
      KeySchema:
        - AttributeName: CustomerId
          KeyType: HASH
      ProvisionedThroughput: !If
        - IsProvisionedBilling
        - ReadCapacityUnits: 5
          WriteCapacityUnits: 5
        - !Ref AWS::NoValue
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag
        - Key: ManagedBy
          Value: CloudFormation

  # IAM Role for Lambda Function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "LexLambdaRole-${AWS::StackName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource: !GetAtt CustomerDataTable.Arn
      Tags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag

  # Lambda Function for Lex Intent Fulfillment
  LexFulfillmentFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "lex-fulfillment-${AWS::StackName}"
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: !Ref LambdaTimeout
      MemorySize: !Ref LambdaMemorySize
      Environment:
        Variables:
          DYNAMODB_TABLE_NAME: !Ref CustomerDataTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          table_name = os.environ['DYNAMODB_TABLE_NAME']
          table = dynamodb.Table(table_name)

          def lambda_handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              intent_name = event['sessionState']['intent']['name']
              slots = event['sessionState']['intent']['slots']
              
              if intent_name == 'OrderStatus':
                  return handle_order_status(event, slots)
              elif intent_name == 'BillingInquiry':
                  return handle_billing_inquiry(event, slots)
              elif intent_name == 'ProductInfo':
                  return handle_product_info(event, slots)
              else:
                  return close_intent(event, 'Fulfilled', 
                                     'I can help you with order status, billing questions, or product information.')

          def handle_order_status(event, slots):
              customer_id = slots.get('CustomerId', {}).get('value', {}).get('interpretedValue')
              
              if not customer_id:
                  return elicit_slot(event, 'CustomerId', 
                                    'Could you please provide your customer ID to check your order status?')
              
              try:
                  response = table.get_item(Key={'CustomerId': customer_id})
                  if 'Item' in response:
                      item = response['Item']
                      message = f"Hi {item['Name']}! Your last order {item['LastOrderId']} is currently {item['LastOrderStatus']}."
                  else:
                      message = f"I couldn't find a customer with ID {customer_id}. Please check your customer ID."
                  
                  return close_intent(event, 'Fulfilled', message)
              except Exception as e:
                  logger.error(f"Error retrieving order status: {str(e)}")
                  return close_intent(event, 'Failed', 
                                     'Sorry, I encountered an error checking your order status. Please try again later.')

          def handle_billing_inquiry(event, slots):
              customer_id = slots.get('CustomerId', {}).get('value', {}).get('interpretedValue')
              
              if not customer_id:
                  return elicit_slot(event, 'CustomerId', 
                                    'Could you please provide your customer ID to check your account balance?')
              
              try:
                  response = table.get_item(Key={'CustomerId': customer_id})
                  if 'Item' in response:
                      item = response['Item']
                      balance = float(item['AccountBalance'])
                      message = f"Hi {item['Name']}! Your current account balance is ${balance:.2f}."
                  else:
                      message = f"I couldn't find a customer with ID {customer_id}. Please check your customer ID."
                  
                  return close_intent(event, 'Fulfilled', message)
              except Exception as e:
                  logger.error(f"Error retrieving billing info: {str(e)}")
                  return close_intent(event, 'Failed', 
                                     'Sorry, I encountered an error checking your account. Please try again later.')

          def handle_product_info(event, slots):
              product_name = slots.get('ProductName', {}).get('value', {}).get('interpretedValue')
              
              if not product_name:
                  return elicit_slot(event, 'ProductName', 
                                    'What product would you like information about?')
              
              # Simple product info responses (in real implementation, query product database)
              product_info = {
                  'laptop': 'Our laptops feature high-performance processors and long battery life, starting at $899.',
                  'smartphone': 'Our smartphones offer premium cameras and 5G connectivity, starting at $699.',
                  'tablet': 'Our tablets are perfect for productivity and entertainment, starting at $399.'
              }
              
              product_lower = product_name.lower()
              if product_lower in product_info:
                  message = product_info[product_lower]
              else:
                  message = f"I don't have specific information about {product_name}. Please contact our sales team for detailed product information."
              
              return close_intent(event, 'Fulfilled', message)

          def elicit_slot(event, slot_to_elicit, message):
              return {
                  'sessionState': {
                      'sessionAttributes': event['sessionState'].get('sessionAttributes', {}),
                      'dialogAction': {
                          'type': 'ElicitSlot',
                          'slotToElicit': slot_to_elicit
                      },
                      'intent': event['sessionState']['intent']
                  },
                  'messages': [
                      {
                          'contentType': 'PlainText',
                          'content': message
                      }
                  ]
              }

          def close_intent(event, fulfillment_state, message):
              return {
                  'sessionState': {
                      'sessionAttributes': event['sessionState'].get('sessionAttributes', {}),
                      'dialogAction': {
                          'type': 'Close'
                      },
                      'intent': {
                          'name': event['sessionState']['intent']['name'],
                          'state': fulfillment_state
                      }
                  },
                  'messages': [
                      {
                          'contentType': 'PlainText',
                          'content': message
                      }
                  ]
              }
      Tags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag

  # Lambda Permission for Lex to Invoke Function
  LexInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LexFulfillmentFunction
      Action: lambda:InvokeFunction
      Principal: lexv2.amazonaws.com
      SourceArn: !Sub "arn:aws:lex:${AWS::Region}:${AWS::AccountId}:bot/*"

  # IAM Role for Amazon Lex Bot
  LexServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "LexServiceRole-${AWS::StackName}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lexv2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonLexV2BotPolicy
      Tags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag

  # Amazon Lex V2 Bot
  CustomerServiceBot:
    Type: AWS::Lex::Bot
    Properties:
      Name: !Sub "${BotName}-${AWS::StackName}"
      Description: Customer service chatbot for handling common inquiries
      RoleArn: !GetAtt LexServiceRole.Arn
      DataPrivacy:
        ChildDirected: false
      IdleSessionTTLInSeconds: !Ref IdleSessionTTL
      BotLocales:
        - LocaleId: en_US
          Description: English US locale for customer service bot
          NluConfidenceThreshold: !Ref ConfidenceThreshold
          VoiceSettings:
            VoiceId: Joanna
          SlotTypes:
            - SlotTypeName: CustomerId
              Description: Customer identification numbers
              ValueSelectionStrategy: ORIGINAL_VALUE
              SlotTypeValues:
                - SampleValue:
                    Value: "12345"
                - SampleValue:
                    Value: "67890"
            - SlotTypeName: ProductName
              Description: Product names for inquiries
              ValueSelectionStrategy: TOP_RESOLUTION
              SlotTypeValues:
                - SampleValue:
                    Value: laptop
                  Synonyms:
                    - Value: computer
                    - Value: notebook
                - SampleValue:
                    Value: smartphone
                  Synonyms:
                    - Value: phone
                    - Value: mobile
                - SampleValue:
                    Value: tablet
                  Synonyms:
                    - Value: ipad
          Intents:
            - IntentName: OrderStatus
              Description: Handle order status inquiries
              SampleUtterances:
                - Utterance: "What is my order status"
                - Utterance: "Check my order"
                - Utterance: "Where is my order"
                - Utterance: "Track my order {CustomerId}"
                - Utterance: "Order status for {CustomerId}"
                - Utterance: "My customer ID is {CustomerId}"
              Slots:
                - SlotName: CustomerId
                  Description: Customer identification number
                  SlotTypeName: CustomerId
                  ValueElicitationSetting:
                    SlotConstraint: Required
                    PromptSpecification:
                      MessageGroupsList:
                        - Message:
                            PlainTextMessage:
                              Value: "Could you please provide your customer ID?"
                      MaxRetries: 2
              FulfillmentCodeHook:
                Enabled: true
            - IntentName: BillingInquiry
              Description: Handle billing and account balance inquiries
              SampleUtterances:
                - Utterance: "What is my account balance"
                - Utterance: "Check my balance"
                - Utterance: "How much do I owe"
                - Utterance: "Billing information for {CustomerId}"
                - Utterance: "Account balance for customer {CustomerId}"
                - Utterance: "My balance please"
              Slots:
                - SlotName: CustomerId
                  Description: Customer identification number for billing
                  SlotTypeName: CustomerId
                  ValueElicitationSetting:
                    SlotConstraint: Required
                    PromptSpecification:
                      MessageGroupsList:
                        - Message:
                            PlainTextMessage:
                              Value: "Please provide your customer ID to check your account balance."
                      MaxRetries: 2
              FulfillmentCodeHook:
                Enabled: true
            - IntentName: ProductInfo
              Description: Handle product information requests
              SampleUtterances:
                - Utterance: "Tell me about {ProductName}"
                - Utterance: "Product information for {ProductName}"
                - Utterance: "What can you tell me about {ProductName}"
                - Utterance: "I want to know about {ProductName}"
                - Utterance: "Details about your {ProductName}"
              Slots:
                - SlotName: ProductName
                  Description: Product name for information request
                  SlotTypeName: ProductName
                  ValueElicitationSetting:
                    SlotConstraint: Required
                    PromptSpecification:
                      MessageGroupsList:
                        - Message:
                            PlainTextMessage:
                              Value: "What product would you like information about?"
                      MaxRetries: 2
              FulfillmentCodeHook:
                Enabled: true
            - IntentName: FallbackIntent
              Description: Fallback intent for unrecognized utterances
              ParentIntentSignature: AMAZON.FallbackIntent
      BotTags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag

  # Bot Version for Production Deployment
  BotVersion:
    Type: AWS::Lex::BotVersion
    Properties:
      BotId: !Ref CustomerServiceBot
      BotVersionLocaleSpecification:
        - LocaleId: en_US
          BotVersionLocaleDetails:
            SourceBotVersion: DRAFT

  # Bot Alias for Client Integration
  BotAlias:
    Type: AWS::Lex::BotAlias
    Properties:
      BotAliasName: Production
      BotId: !Ref CustomerServiceBot
      BotVersion: !GetAtt BotVersion.BotVersion
      Description: Production alias for customer service bot
      BotAliasLocaleSettings:
        - LocaleId: en_US
          BotAliasLocaleSetting:
            Enabled: true
            CodeHookSpecification:
              LambdaCodeHook:
                LambdaArn: !GetAtt LexFulfillmentFunction.Arn
                CodeHookInterfaceVersion: "1.0"
      BotAliasTags:
        - Key: Project
          Value: !Ref ProjectTag
        - Key: Environment
          Value: !Ref EnvironmentTag

  # CloudWatch Log Group for Lambda Function
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${LexFulfillmentFunction}"
      RetentionInDays: 14

Outputs:
  BotId:
    Description: ID of the created Amazon Lex bot
    Value: !Ref CustomerServiceBot
    Export:
      Name: !Sub "${AWS::StackName}-BotId"

  BotAliasId:
    Description: ID of the bot alias for client integration
    Value: !Ref BotAlias
    Export:
      Name: !Sub "${AWS::StackName}-BotAliasId"

  BotName:
    Description: Name of the created Amazon Lex bot
    Value: !Sub "${BotName}-${AWS::StackName}"
    Export:
      Name: !Sub "${AWS::StackName}-BotName"

  LambdaFunctionName:
    Description: Name of the Lambda fulfillment function
    Value: !Ref LexFulfillmentFunction
    Export:
      Name: !Sub "${AWS::StackName}-LambdaFunction"

  LambdaFunctionArn:
    Description: ARN of the Lambda fulfillment function
    Value: !GetAtt LexFulfillmentFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-LambdaFunctionArn"

  DynamoDBTableName:
    Description: Name of the DynamoDB table for customer data
    Value: !Ref CustomerDataTable
    Export:
      Name: !Sub "${AWS::StackName}-DynamoDBTable"

  DynamoDBTableArn:
    Description: ARN of the DynamoDB table for customer data
    Value: !GetAtt CustomerDataTable.Arn
    Export:
      Name: !Sub "${AWS::StackName}-DynamoDBTableArn"

  BotEndpoint:
    Description: Integration endpoint for web/mobile applications
    Value: !Sub "https://runtime-v2-lex.${AWS::Region}.amazonaws.com/bot/${CustomerServiceBot}/botAlias/${BotAlias}/user/{userId}/session/{sessionId}/text"
    Export:
      Name: !Sub "${AWS::StackName}-BotEndpoint"

  TestCommand:
    Description: AWS CLI command to test the bot
    Value: !Sub |
      aws lexv2-runtime recognize-text \
        --bot-id ${CustomerServiceBot} \
        --bot-alias-id ${BotAlias} \
        --locale-id en_US \
        --session-id test-session \
        --text "What is my order status for customer 12345?"

  SampleCustomerData:
    Description: Commands to populate sample customer data
    Value: !Sub |
      aws dynamodb put-item --table-name ${CustomerDataTable} --item '{"CustomerId":{"S":"12345"},"Name":{"S":"John Smith"},"Email":{"S":"john.smith@example.com"},"LastOrderId":{"S":"ORD-789"},"LastOrderStatus":{"S":"Shipped"},"AccountBalance":{"N":"156.78"}}'
      aws dynamodb put-item --table-name ${CustomerDataTable} --item '{"CustomerId":{"S":"67890"},"Name":{"S":"Jane Doe"},"Email":{"S":"jane.doe@example.com"},"LastOrderId":{"S":"ORD-456"},"LastOrderStatus":{"S":"Processing"},"AccountBalance":{"N":"89.23"}}'