#!/usr/bin/env python3
"""
CDK Python application for Multi-Region Event Replication with EventBridge

This application creates a multi-region event replication architecture using:
- Amazon EventBridge custom event buses across multiple regions
- Lambda functions for event processing
- Global endpoints for automatic failover
- CloudWatch monitoring and alarms
- Cross-region IAM roles and permissions

Author: Generated by AWS CDK Python
Version: 1.0.0
"""

import os
from typing import Dict, List, Optional

import aws_cdk as cdk
from aws_cdk import (
    Duration,
    Stack,
    StackProps,
    aws_events as events,
    aws_events_targets as targets,
    aws_lambda as lambda_,
    aws_iam as iam,
    aws_logs as logs,
    aws_cloudwatch as cloudwatch,
    aws_cloudwatch_actions as cw_actions,
    aws_sns as sns,
    aws_route53 as route53,
)
from constructs import Construct


class MultiRegionEventReplicationStack(Stack):
    """
    Main stack for multi-region event replication using EventBridge
    
    This stack creates:
    - Custom event buses across multiple regions
    - Lambda functions for event processing
    - Cross-region event rules and targets
    - CloudWatch monitoring and alarms
    - IAM roles for cross-region access
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        *,
        primary_region: str = "us-east-1",
        secondary_region: str = "us-west-2",
        tertiary_region: str = "eu-west-1",
        event_bus_name: str = "global-events-bus",
        lambda_function_name: str = "event-processor",
        **kwargs
    ) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # Store configuration
        self.primary_region = primary_region
        self.secondary_region = secondary_region
        self.tertiary_region = tertiary_region
        self.event_bus_name = event_bus_name
        self.lambda_function_name = lambda_function_name

        # Create SNS topic for alerts
        self.sns_topic = self._create_sns_topic()

        # Create IAM roles
        self.cross_region_role = self._create_cross_region_role()
        self.lambda_execution_role = self._create_lambda_execution_role()

        # Create custom event bus
        self.event_bus = self._create_event_bus()

        # Create Lambda function
        self.lambda_function = self._create_lambda_function()

        # Create event rules
        self.event_rules = self._create_event_rules()

        # Create CloudWatch monitoring
        self._create_cloudwatch_monitoring()

        # Create outputs
        self._create_outputs()

    def _create_sns_topic(self) -> sns.Topic:
        """Create SNS topic for EventBridge alerts"""
        return sns.Topic(
            self,
            "EventBridgeAlerts",
            display_name="EventBridge Multi-Region Alerts",
            topic_name="eventbridge-alerts",
        )

    def _create_cross_region_role(self) -> iam.Role:
        """Create IAM role for cross-region EventBridge access"""
        cross_region_role = iam.Role(
            self,
            "EventBridgeCrossRegionRole",
            role_name="eventbridge-cross-region-role",
            assumed_by=iam.ServicePrincipal("events.amazonaws.com"),
            description="Role for EventBridge cross-region event delivery",
        )

        # Add policy for cross-region event delivery
        cross_region_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=["events:PutEvents"],
                resources=[
                    f"arn:aws:events:*:{self.account}:event-bus/*"
                ],
            )
        )

        return cross_region_role

    def _create_lambda_execution_role(self) -> iam.Role:
        """Create IAM role for Lambda execution"""
        lambda_role = iam.Role(
            self,
            "LambdaExecutionRole",
            role_name="lambda-execution-role",
            assumed_by=iam.ServicePrincipal("lambda.amazonaws.com"),
            description="Role for Lambda event processing functions",
            managed_policies=[
                iam.ManagedPolicy.from_aws_managed_policy_name(
                    "service-role/AWSLambdaBasicExecutionRole"
                )
            ],
        )

        # Add additional permissions for event processing
        lambda_role.add_to_policy(
            iam.PolicyStatement(
                effect=iam.Effect.ALLOW,
                actions=[
                    "events:PutEvents",
                    "logs:CreateLogGroup",
                    "logs:CreateLogStream",
                    "logs:PutLogEvents",
                ],
                resources=["*"],
            )
        )

        return lambda_role

    def _create_event_bus(self) -> events.EventBus:
        """Create custom event bus with KMS encryption"""
        return events.EventBus(
            self,
            "GlobalEventBus",
            event_bus_name=self.event_bus_name,
            description="Custom event bus for multi-region event replication",
            kms_key=None,  # Uses default AWS managed key
        )

    def _create_lambda_function(self) -> lambda_.Function:
        """Create Lambda function for event processing"""
        
        # Lambda function code
        lambda_code = '''
import json
import boto3
import os
from datetime import datetime

def lambda_handler(event, context):
    region = os.environ.get('AWS_REGION', 'unknown')
    
    # Log the received event
    print(f"Processing event in region {region}")
    print(f"Event: {json.dumps(event, indent=2)}")
    
    # Extract event details
    for record in event.get('Records', []):
        event_source = record.get('source', 'unknown')
        event_detail_type = record.get('detail-type', 'unknown')
        event_detail = record.get('detail', {})
        
        # Process the event (implement your business logic here)
        process_business_event(event_source, event_detail_type, event_detail, region)
    
    return {
        'statusCode': 200,
        'body': json.dumps({
            'message': f'Events processed successfully in {region}',
            'timestamp': datetime.utcnow().isoformat(),
            'region': region
        })
    }

def process_business_event(source, detail_type, detail, region):
    """Process business events with region-specific logic"""
    
    # Example: Handle financial transaction events
    if source == 'finance.transactions' and detail_type == 'Transaction Created':
        transaction_id = detail.get('transactionId')
        amount = detail.get('amount')
        
        print(f"Processing transaction {transaction_id} "
              f"for amount {amount} in region {region}")
        
        # Implement your business logic here
        # Examples: update databases, send notifications, etc.
        
    # Example: Handle user events
    elif source == 'user.management' and detail_type == 'User Action':
        user_id = detail.get('userId')
        action = detail.get('action')
        
        print(f"Processing user action {action} for user {user_id} "
              f"in region {region}")
'''

        return lambda_.Function(
            self,
            "EventProcessorFunction",
            function_name=self.lambda_function_name,
            runtime=lambda_.Runtime.PYTHON_3_9,
            handler="index.lambda_handler",
            code=lambda_.Code.from_inline(lambda_code),
            timeout=Duration.seconds(30),
            role=self.lambda_execution_role,
            description="Lambda function for processing EventBridge events",
            environment={
                "EVENT_BUS_NAME": self.event_bus_name,
            },
            log_retention=logs.RetentionDays.ONE_WEEK,
        )

    def _create_event_rules(self) -> Dict[str, events.Rule]:
        """Create EventBridge rules for event processing and replication"""
        
        rules = {}

        # Cross-region replication rule (for primary region)
        cross_region_rule = events.Rule(
            self,
            "CrossRegionReplicationRule",
            rule_name="cross-region-replication-rule",
            event_bus=self.event_bus,
            description="Rule for cross-region event replication",
            event_pattern=events.EventPattern(
                source=["finance.transactions", "user.management"],
                detail_type=["Transaction Created", "User Action"],
                detail={
                    "priority": ["high", "critical"]
                }
            ),
        )

        # Add Lambda target for local processing
        cross_region_rule.add_target(
            targets.LambdaFunction(
                self.lambda_function,
                retry_attempts=3,
            )
        )

        rules["cross_region"] = cross_region_rule

        # Local processing rule
        local_rule = events.Rule(
            self,
            "LocalProcessingRule",
            rule_name="local-processing-rule",
            event_bus=self.event_bus,
            description="Rule for local event processing",
            event_pattern=events.EventPattern(
                source=["finance.transactions", "user.management"],
                detail_type=["Transaction Created", "User Action"],
            ),
        )

        # Add Lambda target
        local_rule.add_target(
            targets.LambdaFunction(
                self.lambda_function,
                retry_attempts=3,
            )
        )

        rules["local"] = local_rule

        # Financial events rule
        financial_rule = events.Rule(
            self,
            "FinancialEventsRule",
            rule_name="financial-events-rule",
            event_bus=self.event_bus,
            description="Rule for financial event processing",
            event_pattern=events.EventPattern(
                source=["finance.transactions", "finance.payments"],
                detail_type=["Transaction Created", "Payment Processed", "Fraud Detected"],
                detail={
                    "priority": ["high", "critical"],
                    "amount": events.Match.greater_than_or_equal_to(1000)
                }
            ),
        )

        financial_rule.add_target(
            targets.LambdaFunction(
                self.lambda_function,
                retry_attempts=3,
            )
        )

        rules["financial"] = financial_rule

        # User events rule
        user_rule = events.Rule(
            self,
            "UserEventsRule",
            rule_name="user-events-rule",
            event_bus=self.event_bus,
            description="Rule for user event processing",
            event_pattern=events.EventPattern(
                source=["user.management", "user.authentication"],
                detail_type=["User Login", "User Logout", "Password Reset"],
                detail={
                    "risk_level": ["medium", "high"],
                    "region": [self.primary_region, self.secondary_region, self.tertiary_region]
                }
            ),
        )

        user_rule.add_target(
            targets.LambdaFunction(
                self.lambda_function,
                retry_attempts=3,
            )
        )

        rules["user"] = user_rule

        # System events rule
        system_rule = events.Rule(
            self,
            "SystemEventsRule",
            rule_name="system-events-rule",
            event_bus=self.event_bus,
            description="Rule for system event processing",
            event_pattern=events.EventPattern(
                source=["system.monitoring", "system.alerts"],
                detail_type=["System Error", "Performance Alert", "Security Incident"],
                detail={
                    "severity": ["warning", "error", "critical"]
                }
            ),
        )

        system_rule.add_target(
            targets.LambdaFunction(
                self.lambda_function,
                retry_attempts=3,
            )
        )

        rules["system"] = system_rule

        return rules

    def _create_cloudwatch_monitoring(self) -> None:
        """Create CloudWatch alarms and dashboard for monitoring"""
        
        # Alarm for failed EventBridge invocations
        failed_invocations_alarm = cloudwatch.Alarm(
            self,
            "EventBridgeFailedInvocations",
            alarm_name="EventBridge-FailedInvocations",
            alarm_description="Alert when EventBridge rule fails",
            metric=cloudwatch.Metric(
                namespace="AWS/Events",
                metric_name="FailedInvocations",
                dimensions_map={
                    "RuleName": "cross-region-replication-rule"
                },
                statistic="Sum",
                period=Duration.minutes(5),
            ),
            threshold=5,
            evaluation_periods=2,
            treat_missing_data=cloudwatch.TreatMissingData.NOT_BREACHING,
        )

        # Add SNS action to alarm
        failed_invocations_alarm.add_alarm_action(
            cw_actions.SnsAction(self.sns_topic)
        )

        # Alarm for Lambda errors
        lambda_errors_alarm = cloudwatch.Alarm(
            self,
            "LambdaErrors",
            alarm_name="Lambda-Errors",
            alarm_description="Alert when Lambda function errors occur",
            metric=self.lambda_function.metric_errors(
                period=Duration.minutes(5),
                statistic="Sum",
            ),
            threshold=3,
            evaluation_periods=2,
            treat_missing_data=cloudwatch.TreatMissingData.NOT_BREACHING,
        )

        # Add SNS action to alarm
        lambda_errors_alarm.add_alarm_action(
            cw_actions.SnsAction(self.sns_topic)
        )

        # CloudWatch Dashboard
        dashboard = cloudwatch.Dashboard(
            self,
            "EventBridgeMultiRegionDashboard",
            dashboard_name="EventBridge-MultiRegion",
        )

        # Add widgets to dashboard
        dashboard.add_widgets(
            cloudwatch.GraphWidget(
                title="EventBridge Rule Performance",
                width=12,
                height=6,
                left=[
                    cloudwatch.Metric(
                        namespace="AWS/Events",
                        metric_name="SuccessfulInvocations",
                        dimensions_map={
                            "RuleName": "cross-region-replication-rule"
                        },
                        statistic="Sum",
                        period=Duration.minutes(5),
                    ),
                    cloudwatch.Metric(
                        namespace="AWS/Events",
                        metric_name="FailedInvocations",
                        dimensions_map={
                            "RuleName": "cross-region-replication-rule"
                        },
                        statistic="Sum",
                        period=Duration.minutes(5),
                    ),
                ],
            ),
            cloudwatch.GraphWidget(
                title="Lambda Function Performance",
                width=12,
                height=6,
                left=[
                    self.lambda_function.metric_invocations(
                        period=Duration.minutes(5),
                        statistic="Sum",
                    ),
                    self.lambda_function.metric_errors(
                        period=Duration.minutes(5),
                        statistic="Sum",
                    ),
                    self.lambda_function.metric_duration(
                        period=Duration.minutes(5),
                        statistic="Average",
                    ),
                ],
            ),
        )

    def _create_outputs(self) -> None:
        """Create CloudFormation outputs"""
        
        cdk.CfnOutput(
            self,
            "EventBusName",
            value=self.event_bus.event_bus_name,
            description="Name of the custom event bus",
        )

        cdk.CfnOutput(
            self,
            "EventBusArn",
            value=self.event_bus.event_bus_arn,
            description="ARN of the custom event bus",
        )

        cdk.CfnOutput(
            self,
            "LambdaFunctionName",
            value=self.lambda_function.function_name,
            description="Name of the Lambda function",
        )

        cdk.CfnOutput(
            self,
            "LambdaFunctionArn",
            value=self.lambda_function.function_arn,
            description="ARN of the Lambda function",
        )

        cdk.CfnOutput(
            self,
            "SNSTopicArn",
            value=self.sns_topic.topic_arn,
            description="ARN of the SNS topic for alerts",
        )

        cdk.CfnOutput(
            self,
            "CrossRegionRoleArn",
            value=self.cross_region_role.role_arn,
            description="ARN of the cross-region IAM role",
        )


class MultiRegionEventReplicationApp(cdk.App):
    """
    CDK Application for multi-region event replication
    """

    def __init__(self) -> None:
        super().__init__()

        # Environment configuration
        primary_region = self.node.try_get_context("primary_region") or "us-east-1"
        secondary_region = self.node.try_get_context("secondary_region") or "us-west-2"
        tertiary_region = self.node.try_get_context("tertiary_region") or "eu-west-1"

        # Resource naming
        random_suffix = self.node.try_get_context("random_suffix") or "default"
        event_bus_name = f"global-events-bus-{random_suffix}"
        lambda_function_name = f"event-processor-{random_suffix}"

        # Primary region stack
        MultiRegionEventReplicationStack(
            self,
            "MultiRegionEventReplicationStack-Primary",
            primary_region=primary_region,
            secondary_region=secondary_region,
            tertiary_region=tertiary_region,
            event_bus_name=event_bus_name,
            lambda_function_name=lambda_function_name,
            env=cdk.Environment(
                account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
                region=primary_region,
            ),
            description="Multi-region event replication stack for primary region",
        )

        # Secondary region stack
        MultiRegionEventReplicationStack(
            self,
            "MultiRegionEventReplicationStack-Secondary",
            primary_region=primary_region,
            secondary_region=secondary_region,
            tertiary_region=tertiary_region,
            event_bus_name=event_bus_name,
            lambda_function_name=lambda_function_name,
            env=cdk.Environment(
                account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
                region=secondary_region,
            ),
            description="Multi-region event replication stack for secondary region",
        )

        # Tertiary region stack
        MultiRegionEventReplicationStack(
            self,
            "MultiRegionEventReplicationStack-Tertiary",
            primary_region=primary_region,
            secondary_region=secondary_region,
            tertiary_region=tertiary_region,
            event_bus_name=event_bus_name,
            lambda_function_name=lambda_function_name,
            env=cdk.Environment(
                account=os.environ.get("CDK_DEFAULT_ACCOUNT"),
                region=tertiary_region,
            ),
            description="Multi-region event replication stack for tertiary region",
        )


if __name__ == "__main__":
    app = MultiRegionEventReplicationApp()
    app.synth()