# Get current Azure client configuration
data "azurerm_client_config" "current" {}

# Get current Azure AD user for Key Vault access
data "azuread_client_config" "current" {}

# Generate random suffix for globally unique resources
resource "random_id" "suffix" {
  count       = var.use_random_suffix ? 1 : 0
  byte_length = var.random_suffix_length / 2
}

locals {
  # Generate random suffix if enabled
  random_suffix = var.use_random_suffix ? random_id.suffix[0].hex : ""
  
  # Create unique resource names with optional random suffix
  acr_name_unique       = var.use_random_suffix ? "${var.acr_name}${local.random_suffix}" : var.acr_name
  keyvault_name_unique  = var.use_random_suffix ? "${var.keyvault_name}-${local.random_suffix}" : var.keyvault_name
  
  # Common tags with additional metadata
  common_tags = merge(var.common_tags, {
    CreatedBy = "terraform"
    CreatedOn = formatdate("YYYY-MM-DD", timestamp())
  })
}

# Create Resource Group for all container security resources
resource "azurerm_resource_group" "container_security" {
  name     = var.resource_group_name
  location = var.location
  tags     = local.common_tags
}

# Create Log Analytics Workspace for monitoring and alerting
resource "azurerm_log_analytics_workspace" "container_security" {
  name                = var.log_analytics_workspace_name
  location            = azurerm_resource_group.container_security.location
  resource_group_name = azurerm_resource_group.container_security.name
  sku                 = var.log_analytics_sku
  retention_in_days   = var.log_analytics_retention_days
  tags                = local.common_tags
}

# Create Azure Container Registry with Premium tier for advanced security features
resource "azurerm_container_registry" "container_security" {
  name                = local.acr_name_unique
  resource_group_name = azurerm_resource_group.container_security.name
  location            = azurerm_resource_group.container_security.location
  sku                 = var.acr_sku
  admin_enabled       = false
  
  # Enable content trust for image signing
  trust_policy {
    enabled = true
  }
  
  # Enable retention policy for untagged manifests
  retention_policy {
    enabled = true
    days    = 7
  }
  
  # Enable quarantine policy for vulnerable images
  quarantine_policy {
    enabled = true
  }
  
  # Configure network access rules
  network_rule_set {
    default_action = "Allow"
    
    # Allow access from Azure services
    virtual_network {
      action    = "Allow"
      subnet_id = azurerm_subnet.container_security.id
    }
  }
  
  # Enable identity for managed service identity
  identity {
    type = "SystemAssigned"
  }
  
  tags = local.common_tags
}

# Create Virtual Network for secure connectivity
resource "azurerm_virtual_network" "container_security" {
  name                = "vnet-container-security"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.container_security.location
  resource_group_name = azurerm_resource_group.container_security.name
  tags                = local.common_tags
}

# Create subnet for container services
resource "azurerm_subnet" "container_security" {
  name                 = "subnet-container-security"
  resource_group_name  = azurerm_resource_group.container_security.name
  virtual_network_name = azurerm_virtual_network.container_security.name
  address_prefixes     = ["10.0.1.0/24"]
  
  # Enable service endpoints for container registry
  service_endpoints = ["Microsoft.ContainerRegistry"]
}

# Create Azure Key Vault for secure secret storage
resource "azurerm_key_vault" "container_security" {
  name                = local.keyvault_name_unique
  location            = azurerm_resource_group.container_security.location
  resource_group_name = azurerm_resource_group.container_security.name
  tenant_id           = data.azurerm_client_config.current.tenant_id
  sku_name            = var.keyvault_sku
  
  # Enable RBAC authorization instead of access policies
  enable_rbac_authorization = true
  
  # Enable soft delete and purge protection
  soft_delete_retention_days = 90
  purge_protection_enabled   = true
  
  # Network access rules
  network_acls {
    default_action = "Allow"
    bypass         = "AzureServices"
    
    # Allow access from container subnet
    virtual_network_subnet_ids = [azurerm_subnet.container_security.id]
  }
  
  tags = local.common_tags
}

# Create Service Principal for Azure DevOps authentication
resource "azuread_application" "devops_app" {
  display_name = var.service_principal_name
  owners       = [data.azuread_client_config.current.object_id]
  
  # Configure required resource access
  required_resource_access {
    resource_app_id = "00000003-0000-0000-c000-000000000000" # Microsoft Graph
    
    resource_access {
      id   = "e1fe6dd8-ba31-4d61-89e7-88639da4683d" # User.Read
      type = "Scope"
    }
  }
}

# Create Service Principal
resource "azuread_service_principal" "devops_sp" {
  application_id = azuread_application.devops_app.application_id
  owners         = [data.azuread_client_config.current.object_id]
}

# Create Service Principal Password
resource "azuread_service_principal_password" "devops_sp_password" {
  service_principal_id = azuread_service_principal.devops_sp.object_id
  display_name         = "DevOps Service Principal Password"
}

# Assign Contributor role to Service Principal
resource "azurerm_role_assignment" "devops_sp_contributor" {
  scope                = azurerm_resource_group.container_security.id
  role_definition_name = "Contributor"
  principal_id         = azuread_service_principal.devops_sp.object_id
}

# Assign AcrPush role to Service Principal for Container Registry
resource "azurerm_role_assignment" "devops_sp_acr_push" {
  scope                = azurerm_container_registry.container_security.id
  role_definition_name = "AcrPush"
  principal_id         = azuread_service_principal.devops_sp.object_id
}

# Assign Key Vault Secrets Officer role to Service Principal
resource "azurerm_role_assignment" "devops_sp_kv_secrets" {
  scope                = azurerm_key_vault.container_security.id
  role_definition_name = "Key Vault Secrets Officer"
  principal_id         = azuread_service_principal.devops_sp.object_id
}

# Assign Key Vault Secrets Officer role to current user
resource "azurerm_role_assignment" "current_user_kv_secrets" {
  scope                = azurerm_key_vault.container_security.id
  role_definition_name = "Key Vault Secrets Officer"
  principal_id         = data.azuread_client_config.current.object_id
}

# Store Service Principal credentials in Key Vault
resource "azurerm_key_vault_secret" "devops_sp_appid" {
  name         = "devops-sp-appid"
  value        = azuread_application.devops_app.application_id
  key_vault_id = azurerm_key_vault.container_security.id
  
  depends_on = [azurerm_role_assignment.current_user_kv_secrets]
}

resource "azurerm_key_vault_secret" "devops_sp_password" {
  name         = "devops-sp-password"
  value        = azuread_service_principal_password.devops_sp_password.value
  key_vault_id = azurerm_key_vault.container_security.id
  
  depends_on = [azurerm_role_assignment.current_user_kv_secrets]
}

# Enable Microsoft Defender for Container Registries
resource "azurerm_security_center_subscription_pricing" "container_registry" {
  count         = var.enable_defender_for_containers ? 1 : 0
  tier          = var.defender_pricing_tier
  resource_type = "ContainerRegistry"
}

# Create Azure DevOps Project
resource "azuredevops_project" "container_security" {
  name               = var.azdo_project_name
  description        = var.azdo_project_description
  visibility         = var.azdo_project_visibility
  version_control    = "Git"
  work_item_template = "Agile"
  
  features = {
    "boards"       = "enabled"
    "repositories" = "enabled"
    "pipelines"    = "enabled"
    "testplans"    = "disabled"
    "artifacts"    = "enabled"
  }
}

# Create Azure DevOps Service Connection
resource "azuredevops_serviceendpoint_azurerm" "container_security" {
  project_id                = azuredevops_project.container_security.id
  service_endpoint_name     = "azure-container-security"
  description               = "Service connection for container security automation"
  service_endpoint_authentication_scheme = "ServicePrincipal"
  
  credentials {
    serviceprincipalid  = azuread_application.devops_app.application_id
    serviceprincipalkey = azuread_service_principal_password.devops_sp_password.value
  }
  
  azurerm_spn_tenantid      = data.azurerm_client_config.current.tenant_id
  azurerm_subscription_id   = data.azurerm_client_config.current.subscription_id
  azurerm_subscription_name = "Azure Subscription"
}

# Create Action Group for security alerts
resource "azurerm_monitor_action_group" "container_vulnerabilities" {
  count               = var.enable_security_alerts ? 1 : 0
  name                = "ag-container-vulnerabilities"
  resource_group_name = azurerm_resource_group.container_security.name
  short_name          = "ContVuln"
  
  # Email notification
  email_receiver {
    name          = "security-team"
    email_address = "security@company.com"
  }
  
  # Webhook for triggering remediation pipeline
  webhook_receiver {
    name        = "remediation-webhook"
    service_uri = "https://dev.azure.com/organization/_apis/pipelines/runs"
  }
  
  tags = local.common_tags
}

# Create Policy Definition for Container Vulnerability Assessment
resource "azurerm_policy_definition" "container_vulnerability_assessment" {
  count        = var.enable_vulnerability_policy ? 1 : 0
  name         = "container-vulnerability-assessment"
  policy_type  = "Custom"
  mode         = "All"
  display_name = "Container images should have vulnerability findings resolved"
  description  = "Ensure container images have vulnerability findings resolved before deployment"
  
  policy_rule = jsonencode({
    "if": {
      "allOf": [
        {
          "field": "type",
          "equals": "Microsoft.ContainerRegistry/registries/artifacts"
        },
        {
          "field": "Microsoft.ContainerRegistry/registries/artifacts/vulnerabilityAssessment.status",
          "in": ["Healthy", "Unhealthy"]
        }
      ]
    },
    "then": {
      "effect": "deny",
      "details": {
        "message": "Container images with unresolved high or critical vulnerabilities cannot be deployed"
      }
    }
  })
  
  parameters = jsonencode({
    "effect": {
      "type": "String",
      "defaultValue": "Deny",
      "allowedValues": ["Audit", "Deny", "Disabled"]
    }
  })
}

# Create Policy Definition for Container Image Age Limit
resource "azurerm_policy_definition" "container_image_age_limit" {
  count        = var.enable_image_age_policy ? 1 : 0
  name         = "container-image-age-limit"
  policy_type  = "Custom"
  mode         = "All"
  display_name = "Container images must be rebuilt within ${var.image_age_limit_days} days"
  description  = "Ensure container images are regularly rebuilt to include latest security patches"
  
  policy_rule = jsonencode({
    "if": {
      "allOf": [
        {
          "field": "type",
          "equals": "Microsoft.ContainerRegistry/registries/artifacts"
        },
        {
          "field": "Microsoft.ContainerRegistry/registries/artifacts/lastUpdateTime",
          "less": "[addDays(utcNow(), -${var.image_age_limit_days})]"
        }
      ]
    },
    "then": {
      "effect": "deny",
      "details": {
        "message": "Container images older than ${var.image_age_limit_days} days must be rebuilt"
      }
    }
  })
}

# Assign Policy Definition for Vulnerability Assessment
resource "azurerm_policy_assignment" "container_vulnerability_assessment" {
  count                = var.enable_vulnerability_policy ? 1 : 0
  name                 = "container-vulnerability-assessment"
  policy_definition_id = azurerm_policy_definition.container_vulnerability_assessment[0].id
  scope                = azurerm_resource_group.container_security.id
  display_name         = "Container Vulnerability Assessment Policy"
  description          = "Enforce vulnerability assessment for container images"
  
  parameters = jsonencode({
    "effect": {
      "value": "Deny"
    }
  })
}

# Assign Policy Definition for Image Age Limit
resource "azurerm_policy_assignment" "container_image_age_limit" {
  count                = var.enable_image_age_policy ? 1 : 0
  name                 = "container-image-age-limit"
  policy_definition_id = azurerm_policy_definition.container_image_age_limit[0].id
  scope                = azurerm_resource_group.container_security.id
  display_name         = "Container Image Age Limit Policy"
  description          = "Enforce age limits for container images"
}

# Create Metric Alert for Critical Vulnerabilities
resource "azurerm_monitor_metric_alert" "container_critical_vulnerabilities" {
  count               = var.enable_security_alerts ? 1 : 0
  name                = "container-critical-vulnerabilities"
  resource_group_name = azurerm_resource_group.container_security.name
  scopes              = [azurerm_log_analytics_workspace.container_security.id]
  description         = "Alert when critical vulnerabilities are detected in container images"
  severity            = var.alert_severity
  
  criteria {
    metric_namespace = "Microsoft.OperationalInsights/workspaces"
    metric_name      = "Heartbeat"
    aggregation      = "Count"
    operator         = "GreaterThan"
    threshold        = var.vulnerability_threshold
  }
  
  action {
    action_group_id = azurerm_monitor_action_group.container_vulnerabilities[0].id
  }
  
  tags = local.common_tags
}

# Create Scheduled Query Rule for Vulnerability Trend Analysis
resource "azurerm_monitor_scheduled_query_rules_alert" "vulnerability_trend_analysis" {
  count               = var.enable_security_alerts ? 1 : 0
  name                = "vulnerability-trend-analysis"
  location            = azurerm_resource_group.container_security.location
  resource_group_name = azurerm_resource_group.container_security.name
  
  action {
    action_group           = [azurerm_monitor_action_group.container_vulnerabilities[0].id]
    email_subject          = "Container Vulnerability Trend Alert"
    custom_webhook_payload = "{}"
  }
  
  data_source_id = azurerm_log_analytics_workspace.container_security.id
  description    = "Monitor vulnerability trends across container images"
  enabled        = true
  
  query = <<-QUERY
    ContainerRegistryVulnerabilityAssessment
    | where Severity in ('High', 'Critical')
    | summarize VulnCount = count() by bin(TimeGenerated, 1h), ImageName
    | where VulnCount > ${var.vulnerability_threshold}
  QUERY
  
  severity    = var.alert_severity
  frequency   = 60
  time_window = 60
  
  trigger {
    operator  = "GreaterThan"
    threshold = var.vulnerability_threshold
  }
  
  tags = local.common_tags
}

# Create Azure DevOps Variable Group for Pipeline Configuration
resource "azuredevops_variable_group" "container_security" {
  project_id   = azuredevops_project.container_security.id
  name         = "container-security-vars"
  description  = "Variables for container security automation pipelines"
  allow_access = true
  
  variable {
    name  = "ACR_NAME"
    value = azurerm_container_registry.container_security.name
  }
  
  variable {
    name  = "RESOURCE_GROUP"
    value = azurerm_resource_group.container_security.name
  }
  
  variable {
    name  = "SUBSCRIPTION_ID"
    value = data.azurerm_client_config.current.subscription_id
  }
  
  variable {
    name         = "SERVICE_PRINCIPAL_ID"
    secret_value = azuread_application.devops_app.application_id
    is_secret    = true
  }
  
  variable {
    name         = "SERVICE_PRINCIPAL_KEY"
    secret_value = azuread_service_principal_password.devops_sp_password.value
    is_secret    = true
  }
  
  variable {
    name  = "TENANT_ID"
    value = data.azurerm_client_config.current.tenant_id
  }
  
  variable {
    name  = "KEY_VAULT_NAME"
    value = azurerm_key_vault.container_security.name
  }
  
  variable {
    name  = "LOG_ANALYTICS_WORKSPACE_ID"
    value = azurerm_log_analytics_workspace.container_security.workspace_id
  }
}